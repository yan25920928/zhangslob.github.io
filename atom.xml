<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小歪的博客</title>
  
  <subtitle>人生苦短，我学Python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangslob.github.io/"/>
  <updated>2020-03-27T11:31:32.667Z</updated>
  <id>https://zhangslob.github.io/</id>
  
  <author>
    <name>崔斯特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO模型</title>
    <link href="https://zhangslob.github.io/2020/03/24/IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zhangslob.github.io/2020/03/24/IO模型/</id>
    <published>2020-03-24T11:36:03.592Z</published>
    <updated>2020-03-27T11:31:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>IO模型介绍 (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百一十八篇原创文章</div></pre></td></tr></table></figure><p>基础</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到IO模型，都会牵扯到同步、异步、阻塞、非阻塞这几个词。从词的表面上看，很多人都觉得很容易理解。但是细细一想，却总会发现有点摸不着头脑。自己也曾被这几个词弄的迷迷糊糊的，每次看相关资料弄明白了，然后很快又给搞混了。</p><p>经历过这么几次之后，发现这东西必须得有所总结提炼才不至于再次混为一谈。尤其是最近看到好几篇讲这个的文章，很多都有谬误，很容易把本来就搞不清楚的人弄的更加迷糊。</p><p>最适合IO模型的例子应该是咱们平常生活中的去餐馆吃饭这个场景，下文就结合这个来讲解一下经典的几个IO模型。在此之前，先需要说明以下几点：</p><ul><li>IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。</li><li>阻塞和非阻塞，是函数/方法的实现方式，即在数据就绪之前是立刻返回还是等待，即发起IO请求是否会被阻塞。</li><li>以文件IO为例,一个IO读过程是文件数据从磁盘→内核缓冲区→用户内存的过程。同步与异步的区别主要在于数据从内核缓冲区→用户内存这个过程需不需要用户进程等待，即实际的IO读写是否阻塞请求进程。(网络IO把磁盘换做网卡即可)</li></ul><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h2><p>去餐馆吃饭，点一个自己最爱吃的盖浇饭，然后在原地等着一直到盖浇饭做好，自己端到餐桌就餐。这就是典型的同步阻塞。当厨师给你做饭的时候，你需要一直在那里等着。</p><p>网络编程中，读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。这也是最简单的IO模型，在通常fd较少、就绪很快的情况下使用是没有问题的。</p><p><img src="https://www.rowkey.me/images/blog_images/io/bio.png" alt=""></p><h2 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h2><p>接着上面的例子，你每次点完饭就在那里等着，突然有一天你发现自己真傻。于是，你点完之后，就回桌子那里坐着，然后估计差不多了，就问老板饭好了没，如果好了就去端，没好的话就等一会再去问，依次循环直到饭做好。这就是同步非阻塞。</p><p>这种方式在编程中对socket设置O_NONBLOCK即可。但此方式仅仅针对网络IO有效，对磁盘IO并没有作用。因为本地文件IO就没有被认为是阻塞，我们所说的网络IO的阻塞是因为网路IO有无限阻塞的可能，而本地文件除非是被锁住，否则是不可能无限阻塞的，因此只有锁这种情况下，O_NONBLOCK才会有作用。而且，磁盘IO时要么数据在内核缓冲区中直接可以返回，要么需要调用物理设备去读取，这时候进程的其他工作都需要等待。因此，后续的IO复用和信号驱动IO对文件IO也是没有意义的。</p><p><img src="https://www.rowkey.me/images/blog_images/io/nio.png" alt=""></p><p>此外，需要说明的一点是nginx和node中对于本地文件的IO是用线程的方式模拟非阻塞的效果的，而对于静态文件的io，使用zero copy(例如sendfile、kafka、spark)的效率是非常高的。</p><h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><p>接着上面的列子，你点一份饭然后循环的去问好没好显然有点得不偿失，还不如就等在那里直到准备好，但是当你点了好几样饭菜的时候，你每次都去问一下所有饭菜的状态(未做好/已做好)肯定比你每次阻塞在那里等着好多了。当然，你问的时候是需要阻塞的，一直到有准备好的饭菜或者你等的不耐烦(超时)。</p><p>这就引出了IO复用，也叫多路IO就绪通知。这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。使得一个进程能在一连串的事件上等待。</p><p><img src="https://www.rowkey.me/images/blog_images/io/mulio.png" alt=""></p><p>IO复用的实现方式目前主要有select、poll和epoll。</p><p>select和poll的原理基本相同：</p><ul><li>注册待侦听的fd(这里的fd创建时最好使用非阻塞)</li><li>每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回</li><li>返回结果中包括已就绪和未就绪的fd</li></ul><p>相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。</p><p>此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。</p><p>select和poll就类似于上面说的就餐方式。但当你每次都去询问时，老板会把所有你点的饭菜都<strong>轮询</strong>一遍再告诉你情况，当大量饭菜很长时间都不能准备好的情况下是很低效的。于是，老板有些不耐烦了，就让厨师每做好一个菜就通知他。这样每次你再去问的时候，他会直接把已经准备好的菜告诉你，你再去端。这就是<strong>事件驱动IO</strong>就绪通知的方式-<strong>epoll</strong>。</p><p>epoll的出现，解决了select、poll的缺点：</p><ul><li>基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍。</li><li>epoll_wait只返回就绪的fd。</li><li>epoll使用mmap内存映射技术避免了内存复制的开销。</li><li>epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存有关，通常远大于1024。</li></ul><p>目前，epoll是Linux2.6下最高效的IO复用方式，也是Nginx、Node的IO实现方式。而在freeBSD下，kqueue是另一种类似于epoll的IO复用方式。</p><p>此外，对于IO复用还有一个水平触发和边缘触发的概念：</p><ul><li>水平触发：当就绪的fd未被用户进程处理后，下一次查询依旧会返回，这是select和poll的触发方式。</li><li>边缘触发：无论就绪的fd是否被处理，下一次不再返回。理论上性能更高，但是实现相当复杂，并且任何意外的丢失事件都会造成请求处理错误。epoll默认使用水平触发，通过相应选项可以使用边缘触发。</li></ul><h2 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h2><p>上文的就餐方式还是需要你每次都去问一下饭菜状况。于是，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然后就自己坐在桌子那里干自己的事情。更甚者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。</p><p><img src="https://www.rowkey.me/images/blog_images/io/sigio.png" alt="bio"></p><p>流程如下：</p><ul><li>开启套接字信号驱动IO功能</li><li>系统调用sigaction执行信号处理函数（非阻塞，立刻返回）</li><li>数据就绪，生成sigio信号，通过信号回调通知应用来读取数据。</li></ul><p>此种io方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据。</p><h2 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h2><p>之前的就餐方式，到最后总是需要你自己去把饭菜端到餐桌。这下你也不耐烦了，于是就告诉老板，能不能饭好了直接端到你的面前或者送到你的家里(外卖)。这就是异步非阻塞IO了。</p><p><img src="https://www.rowkey.me/images/blog_images/io/aio.png" alt="bio"></p><p>对比信号驱动IO，异步IO的主要区别在于：信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。</p><p>异步IO又叫做事件驱动IO，在Unix中，POSIX1003.1标准为异步方式访问文件定义了一套库函数，定义了AIO的一系列接口。使用aio_read或者aio_write发起异步IO操作，使用aio_error检查正在运行的IO操作的状态。但是其实现没有通过内核而是使用了多线程阻塞。此外，还有Linux自己实现的Native AIO，依赖两个函数：io_submit和io_getevents，虽然io是非阻塞的，但仍需要主动去获取读写的状态。</p><p>需要特别注意的是：AIO是I/O处理模式，是一种接口标准，各家操作系统可以实现也可以不实现。目前Linux中AIO的内核实现只对文件IO有效，如果要实现真正的AIO，需要用户自己来实现。</p><h1 id="网络编程模型"><a href="#网络编程模型" class="headerlink" title="网络编程模型"></a>网络编程模型</h1><p>上文讲述了UNIX环境的五种IO模型。基于这五种模型，在Java中，随着NIO和NIO2.0(AIO)的引入，一般具有以下几种网络编程模型：</p><ul><li>BIO</li><li>NIO</li><li>AIO</li></ul><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的过程，步骤如下：</p><ul><li>主线程accept请求阻塞</li><li>请求到达，创建新的线程来处理这个套接字，完成对客户端的响应。</li><li>主线程继续accept下一个请求</li></ul><p>这种模型有一个很大的问题是：当客户端连接增多时，服务端创建的线程也会暴涨，系统性能会急剧下降。因此，在此模型的基础上，类似于 tomcat的bio connector，采用的是线程池来避免对于每一个客户端都创建一个线程。有些地方把这种方式叫做伪异步IO(把请求抛到线程池中异步等待处理)。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>JDK1.4开始引入了NIO类库，这里的NIO指的是Non-blcok IO，主要是使用Selector多路复用器来实现。Selector在Linux等主流操作系统上是通过epoll实现的。</p><p>NIO的实现流程，类似于select：</p><ul><li>创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式。</li><li>创建Reactor线程，创建多路复用器(Selector)并启动线程。</li><li>将ServerSocketChannel注册到Reactor线程的Selector上。监听accept事件。</li><li>Selector在线程run方法中无线循环轮询准备就绪的Key。</li><li>Selector监听到新的客户端接入，处理新的请求，完成tcp三次握手，建立物理连接。</li><li>将新的客户端连接注册到Selector上，监听读操作。读取客户端发送的网络消息。</li><li>客户端发送的数据就绪则读取客户端请求，进行处理。</li></ul><p>相比BIO，NIO的编程非常复杂。</p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。其底层在windows上是通过IOCP，在Linux上是通过epoll来实现的(LinuxAsynchronousChannelProvider.java,UnixAsynchronousServerSocketChannelImpl.java)。</p><ul><li>创建AsynchronousServerSocketChannel，绑定监听端口</li><li>调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler。包括上一步，都是非阻塞的</li><li>连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler。</li><li>数据就绪，触发负责处理数据的CompletionHandler的completed方法。继续做下一步处理即可。</li><li>写入操作类似，也需要传入CompletionHandler。</li></ul><p>其编程模型相比NIO有了不少的简化。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table><thead><tr><th style="text-align:left">.</th><th style="text-align:left">同步阻塞IO</th><th style="text-align:left">伪异步IO</th><th style="text-align:left">NIO</th><th style="text-align:left">AIO</th></tr></thead><tbody><tr><td style="text-align:left">客户端数目 ：IO线程</td><td style="text-align:left">1 : 1</td><td style="text-align:left">m : n</td><td style="text-align:left">m : 1</td><td style="text-align:left">m : 0</td></tr><tr><td style="text-align:left">IO模型</td><td style="text-align:left">同步阻塞IO</td><td style="text-align:left">同步阻塞IO</td><td style="text-align:left">同步非阻塞IO</td><td style="text-align:left">异步非阻塞IO</td></tr><tr><td style="text-align:left">吞吐量</td><td style="text-align:left">低</td><td style="text-align:left">中</td><td style="text-align:left">高</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">编程复杂度</td><td style="text-align:left">简单</td><td style="text-align:left">简单</td><td style="text-align:left">非常复杂</td><td style="text-align:left">复杂</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://book.douban.com/subject/3924175/" target="_blank" rel="external">构建高性能Web站点</a></li><li><a href="http://book.douban.com/subject/26373138/" target="_blank" rel="external">Netty权威指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IO模型介绍 (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百一十八篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 和 I/O 多路复用</title>
    <link href="https://zhangslob.github.io/2020/03/24/Redis-%E5%92%8C-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://zhangslob.github.io/2020/03/24/Redis-和-I-O-多路复用/</id>
    <published>2020-03-24T02:37:50.155Z</published>
    <updated>2020-03-24T02:46:32.031Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.draveness.me/2016-11-26-blocking-io.png-1000width" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百一十七篇原创文章</div></pre></td></tr></table></figure><p>面试必问</p><a id="more"></a><p>最近在看 UNIX 网络编程并研究了一下 Redis 的实现，感觉 Redis 的源代码十分适合阅读和分析，其中 I/O 多路复用（mutiplexing）部分的实现非常干净和优雅，在这里想对这部分的内容进行简单的整理。</p><h1 id="几种-I-O-模型"><a href="#几种-I-O-模型" class="headerlink" title="几种 I/O 模型"></a>几种 I/O 模型</h1><p>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。</p><h1 id="Blocking-I-O"><a href="#Blocking-I-O" class="headerlink" title="Blocking I/O"></a>Blocking I/O</h1><p>先来看一下传统的阻塞 I/O 模型到底是如何工作的：当使用 read 或者 write 对某一个文件描述符（File Descriptor 以下简称 FD)进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p><p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：</p><p><img src="https://img.draveness.me/2016-11-26-blocking-io.png-1000width" alt=""></p><p>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p><h1 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h1><p>虽然还有很多其它的 I/O 模型，但是在这里都不会具体介绍。</p><p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了：</p><p><img src="https://img.draveness.me/2016-11-26-I:O-Multiplexing-Model.png-1000width" alt=""></p><p>在 I/O 多路复用模型中，最重要的函数调用就是 select，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，select 方法就会返回可读以及可写的文件描述符个数。</p><p>关于 select 的具体使用方法，在网络上资料很多，这里就不过多展开介绍了；</p><p>与此同时也有其它的 I/O 多路复用函数 epoll/kqueue/evport，它们相比 select 性能更优秀，同时也能支撑更多的服务。</p><h1 id="Reactor-设计模式"><a href="#Reactor-设计模式" class="headerlink" title="Reactor 设计模式"></a>Reactor 设计模式</h1><p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p><p><img src="https://img.draveness.me/2016-11-26-redis-reactor-pattern.png-1000width" alt=""></p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p><h1 id="I-O-多路复用模块"><a href="#I-O-多路复用模块" class="headerlink" title="I/O 多路复用模块"></a>I/O 多路复用模块</h1><p>I/O 多路复用模块封装了底层的 select、epoll、avport 以及 kqueue 这些 I/O 多路复用函数，为上层提供了相同的接口。</p><p><img src="https://img.draveness.me/2016-11-26-ae-module.jpg-1000width" alt=""></p><p>在这里我们简单介绍 Redis 是如何包装 select 和 epoll 的，简要了解该模块的功能，整个 I/O 多路复用模块抹平了不同平台上 I/O 多路复用函数的差异性，提供了相同的接口：</p><ul><li>static int  aeApiCreate(aeEventLoop *eventLoop)</li><li>static int  aeApiResize(aeEventLoop *eventLoop, int setsize)</li><li>static void aeApiFree(aeEventLoop *eventLoop)</li><li>static int  aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</li><li>static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) </li><li>static int  aeApiPoll(aeEventLoop <em>eventLoop, struct timeval </em>tvp)</li></ul><p>同时，因为各个函数所需要的参数不同，我们在每一个子模块内部通过一个 aeApiState 来存储需要的上下文信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// select</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    fd_set rfds, wfds;</div><div class="line">    fd_set _rfds, _wfds;</div><div class="line">&#125; aeApiState;</div><div class="line"></div><div class="line"><span class="comment">// epoll</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events;</div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure><p>这些上下文信息会存储在 eventLoop 的 void *state 中，不会暴露到上层，只在当前子模块中使用。</p><h1 id="封装-select-函数"><a href="#封装-select-函数" class="headerlink" title="封装 select 函数"></a>封装 select 函数</h1><p>select 可以监控 FD 的可读、可写以及出现错误的情况。</p><p>在介绍 I/O 多路复用模块如何对 select 函数封装之前，先来看一下 select 函数使用的大致流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fd = <span class="comment">/* file descriptor */</span></div><div class="line"></div><div class="line">fd_set rfds;</div><div class="line">FD_ZERO(&amp;rfds);</div><div class="line">FD_SET(fd, &amp;rfds)</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( ; ; ) &#123;</div><div class="line">    select(fd+<span class="number">1</span>, &amp;rfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (FD_ISSET(fd, &amp;rfds)) &#123;</div><div class="line">        <span class="comment">/* file descriptor `fd` becomes readable */</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>初始化一个可读的 fd_set 集合，保存需要监控可读性的 FD；</li><li>使用 FD_SET 将 fd 加入 rfds；</li><li>调用 select 方法监控 rfds 中的 FD 是否可读；</li><li>当 select 返回时，检查 FD 的状态并完成对应的操作。</li></ol><p>而在 Redis 的 ae_select 文件中代码的组织顺序也是差不多的，首先在 aeApiCreate 函数中初始化 rfds 和 wfds：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    FD_ZERO(&amp;state-&gt;rfds);</div><div class="line">    FD_ZERO(&amp;state-&gt;wfds);</div><div class="line">    eventLoop-&gt;apidata = state;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而 aeApiAddEvent 和 aeApiDelEvent 会通过 FD_SET 和 FD_CLR 修改 fd_set 中对应 FD 的标志位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) FD_SET(fd,&amp;state-&gt;rfds);</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) FD_SET(fd,&amp;state-&gt;wfds);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>整个 ae_select 子模块中最重要的函数就是 aeApiPoll，它是实际调用 select 函数的部分，其作用就是在 I/O 多路复用函数返回时，将对应的 FD 加入 aeEventLoop 的 fired 数组中，并返回事件的个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">int</span> retval, j, numevents = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(&amp;state-&gt;_rfds,&amp;state-&gt;rfds,<span class="keyword">sizeof</span>(fd_set));</div><div class="line">    <span class="built_in">memcpy</span>(&amp;state-&gt;_wfds,&amp;state-&gt;wfds,<span class="keyword">sizeof</span>(fd_set));</div><div class="line"></div><div class="line">    retval = select(eventLoop-&gt;maxfd+<span class="number">1</span>,</div><div class="line">                &amp;state-&gt;_rfds,&amp;state-&gt;_wfds,<span class="literal">NULL</span>,tvp);</div><div class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= eventLoop-&gt;maxfd; j++) &#123;</div><div class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[j];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask == AE_NONE) <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; AE_READABLE &amp;&amp; FD_ISSET(j,&amp;state-&gt;_rfds))</div><div class="line">                mask |= AE_READABLE;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; AE_WRITABLE &amp;&amp; FD_ISSET(j,&amp;state-&gt;_wfds))</div><div class="line">                mask |= AE_WRITABLE;</div><div class="line">            eventLoop-&gt;fired[numevents].fd = j;</div><div class="line">            eventLoop-&gt;fired[numevents].mask = mask;</div><div class="line">            numevents++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="封装-epoll-函数"><a href="#封装-epoll-函数" class="headerlink" title="封装 epoll 函数"></a>封装 epoll 函数</h1><p>Redis 对 epoll 的封装其实也是类似的，使用 epoll_create 创建 epoll 中使用的 epfd：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</div><div class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</div><div class="line">        zfree(state-&gt;events);</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    eventLoop-&gt;apidata = state;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 aeApiAddEvent 中使用 epoll_ctl 向 epfd 中添加需要监控的 FD 以及监听的事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">struct</span> epoll_event ee = &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></div><div class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></div><div class="line">     * operation. Otherwise we need an ADD operation. */</div><div class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">    ee.events = <span class="number">0</span>;</div><div class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">    ee.data.fd = fd;</div><div class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于 epoll 相比 select 机制略有不同，在 epoll_wait 函数返回时并不需要遍历所有的 FD 查看读写情况；在 epoll_wait 函数返回时会提供一个 epoll_event 数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</div><div class="line">    <span class="keyword">void</span>    *ptr;</div><div class="line">    <span class="keyword">int</span>      fd; <span class="comment">/* 文件描述符 */</span></div><div class="line">    <span class="keyword">uint32_t</span> u32;</div><div class="line">    <span class="keyword">uint64_t</span> u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> epoll_event &#123;</div><div class="line">    <span class="keyword">uint32_t</span>     events; <span class="comment">/* Epoll 事件 */</span></div><div class="line">    <span class="keyword">epoll_data_t</span> data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>其中保存了发生的 epoll 事件（EPOLLIN、EPOLLOUT、EPOLLERR 和 EPOLLHUP）以及发生该事件的 FD。</p><p>aeApiPoll 函数只需要将 epoll_event 数组中存储的信息加入 eventLoop 的 fired 数组中，将信息传递给上层模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</div><div class="line"></div><div class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</div><div class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</div><div class="line">            <span class="keyword">struct</span> epoll_event *e = state-&gt;events+j;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</div><div class="line">            eventLoop-&gt;fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="子模块的选择"><a href="#子模块的选择" class="headerlink" title="子模块的选择"></a>子模块的选择</h1><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；在 Redis 中，我们通过宏定义的使用，合理的选择不同的子模块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>因为 select 函数是作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p><img src="https://img.draveness.me/2016-11-26-redis-choose-io-function.jpg-1000width" alt=""></p><p>Redis 会优先选择时间复杂度为 𝑂(1) 的 I/O 多路复用函数作为底层实现，包括 Solaries 10 中的 evport、Linux 中的 epoll 和 macOS/FreeBSD 中的 kqueue，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 select 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 𝑂(𝑛)，并且只能同时服务 1024 个文件描述符，所以一般并不会以 select 作为第一方案使用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。</p><p>整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="external">Select-Man-Pages</a><br><a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="external">Reactor-Pattern</a><br><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html" target="_blank" rel="external">epoll vs kqueue</a></p><p>原文链接：<a href="https://draveness.me/redis-io-multiplexing" target="_blank" rel="external">Redis 和 I/O 多路复用 · 面向信仰编程</a></p><p>Follow: <a href="https://github.com/Draveness" target="_blank" rel="external">Draveness · GitHub</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2016-11-26-blocking-io.png-1000width&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百一十七篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;面试必问&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://zhangslob.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>我为什么很久没写博客了</title>
    <link href="https://zhangslob.github.io/2020/03/13/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E4%B9%85%E6%B2%A1%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/"/>
    <id>https://zhangslob.github.io/2020/03/13/我为什么很久没写博客了/</id>
    <published>2020-03-13T12:08:29.000Z</published>
    <updated>2020-03-15T02:38:08.017Z</updated>
    
    <content type="html"><![CDATA[<hr><p>看了下公众号记录，发现上次推文竟然还是去年双十二发的一篇薅羊毛的文章，有点小尴尬，这么久没发，不是因为密码完了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;看了下公众号记录，发现上次推文竟然还是去年双十二发的一篇薅羊毛的文章，有点小尴尬，这么久没发，不是因为密码完了&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java并发编程实战-01-可见性、原子性和有序性问题：并发编程Bug的源头</title>
    <link href="https://zhangslob.github.io/2020/03/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-01-%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BBug%E7%9A%84%E6%BA%90%E5%A4%B4/"/>
    <id>https://zhangslob.github.io/2020/03/10/Java并发编程实战-01-可见性、原子性和有序性问题：并发编程Bug的源头/</id>
    <published>2020-03-10T08:09:10.548Z</published>
    <updated>2020-03-10T11:25:04.818Z</updated>
    
    <content type="html"><![CDATA[<p>Java 并发编程实战 (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百一十六篇原创文章</div></pre></td></tr></table></figure><p>如果你细心观察的话，你会发现，不管是哪一门编程语言，并发类的知识都是在高级篇里。换句话说，这块知识点其实对于程序员来说，是比较进阶的知识。我自己这么多年学习过来，也确实觉得并发是比较难的，因为它会涉及到很多的底层知识，比如若你对操作系统相关的知识一无所知的话，那去理解一些原理就会费些力气。这是我们整个专栏的第一篇文章，我说这些话的意思是如果你在中间遇到自己没想通的问题，可以去查阅资料，也可以在评论区找我，以保证你能够跟上学习进度。</p><p>你我都知道，编写正确的并发程序是一件极困难的事情，并发程序的 Bug 往往会诡异地出现，然后又诡异地消失，很难重现，也很难追踪，很多时候都让人很抓狂。但要快速而又精准地解决“并发”类的疑难杂症，你就要理解这件事情的本质，追本溯源，深入分析这些 Bug 的源头在哪里。</p><p>那为什么并发编程容易出问题呢？它是怎么出问题的？今天我们就重点聊聊这些 Bug 的源头。</p><h1 id="并发程序幕后的故事"><a href="#并发程序幕后的故事" class="headerlink" title="并发程序幕后的故事"></a>并发程序幕后的故事</h1><p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个<strong>核心矛盾一直存在，就是这三者的速度差异</strong>。CPU 和内存的速度差异可以形象地描述为：CPU 是天上一天，内存是地上一年（假设 CPU 执行一条普通指令需要一天，那么 CPU 读写内存得等待一年的时间）。内存和 I/O 设备的速度差异就更大了，内存是天上一天，I/O 设备是地上十年。</p><p>程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论（一只水桶能装多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作——读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的。</p><p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ol><li>CPU 增加了缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。</li></ol><p>现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。</p><h1 id="源头之一：缓存导致的可见性问题"><a href="#源头之一：缓存导致的可见性问题" class="headerlink" title="源头之一：缓存导致的可见性问题"></a>源头之一：缓存导致的可见性问题</h1><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p><img src="https://static001.geekbang.org/resource/image/a0/da/a07e8182819e2b260ce85b2167d446da.png" alt="CPU缓存与内存的关系图"></p><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。</p><p><img src="https://static001.geekbang.org/resource/image/e2/ea/e2aa76928b2bc135e08e7590ca36e0ea.png" alt="多核CPU的缓存与内存关系图"></p><p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次 add10K()方法，都会循环 10000 次 count+=1 操作。在 calc()方法中我们创建了两个线程，每个线程调用一次 add10K()方法，我们来想一想执行 calc()方法得到的结果应该是多少呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</div><div class="line">      count += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">    <span class="comment">// 创建两个线程，执行add()操作</span></div><div class="line">    Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">      test.add10K();</div><div class="line">    &#125;);</div><div class="line">    Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</div><div class="line">      test.add10K();</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 启动两个线程</span></div><div class="line">    th1.start();</div><div class="line">    th2.start();</div><div class="line">    <span class="comment">// 等待两个线程执行结束</span></div><div class="line">    th1.join();</div><div class="line">    th2.join();</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K()方法，count 的值就是 20000，但实际上 calc()的执行结果是个 10000 到 20000 之间的随机数。为什么呢？</p><p>我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于 20000 的。这就是缓存的可见性问题。</p><p>循环 10000 次 count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count 的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。</p><p><img src="https://static001.geekbang.org/resource/image/ec/79/ec6743e74ccf9a3c6d6c819a41e52279.png" alt="变量count在CPU缓存和内存的分布图"></p><h1 id="源头之二：线程切换带来的原子性问题"><a href="#源头之二：线程切换带来的原子性问题" class="headerlink" title="源头之二：线程切换带来的原子性问题"></a>源头之二：线程切换带来的原子性问题</h1><p>由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。</p><p>操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为<strong>时间片</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/25/fb/254b129b145d80e9bb74123d6e620efb.png" alt="线程切换示意图"></p><p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。</p><p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。</p><p>是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix 就是因为解决了这个问题而名噪天下的。</p><p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的<code>count += 1</code>，至少需要三条 CPU 指令。</p><ol><li>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</li><li>指令 2：之后，在寄存器中执行+1 操作；</li><li>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ol><p>操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p><p><img src="https://static001.geekbang.org/resource/image/33/63/33777c468872cb9a99b3cdc1ff597063.png" alt="非原子操作的执行路径示意图"></p><p>我们潜意识里面觉得 <code>count+=1</code> 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。<strong>我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性</strong>。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><h1 id="源头之三：编译优化带来的有序性问题"><a href="#源头之三：编译优化带来的有序性问题" class="headerlink" title="源头之三：编译优化带来的有序性问题"></a>源头之三：编译优化带来的有序性问题</h1><p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p><p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance()的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> Singleton instance;</div><div class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</div><div class="line">          instance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设有两个线程 A、B 同时调用 getInstance()方法，他们会同时发现 <code>instance == null</code> ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 <code>instance == null</code> 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance()方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><ol><li>分配一块内存 M；</li><li>在内存 M 上初始化 Singleton 对象；</li><li>然后 M 的地址赋值给 instance 变量。</li></ol><p>但是实际上优化后的执行路径却是这样的：</p><ol><li>分配一块内存 M；</li><li>将 M 的地址赋值给 instance 变量；</li><li>最后在内存 M 上初始化 Singleton 对象。</li></ol><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance()方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance()方法，那么线程 B 在执行第一个判断时会发现 <code>instance != null</code>，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p><img src="https://static001.geekbang.org/resource/image/64/d8/64c955c65010aae3902ec918412827d8.png" alt="双重检查创建单例的异常执行路径"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要写好并发程序，首先要知道并发程序的问题在哪里，只有确定了“靶子”，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们，只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的.</p><p>在介绍可见性、原子性、有序性的时候，特意提到<strong>缓存</strong>导致的可见性问题，<strong>线程切换</strong>带来的原子性问题，<strong>编译优化</strong>带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p><p>我们这个专栏在讲解每项技术的时候，都会尽量将每项技术解决的问题以及产生的问题讲清楚，也希望你能够在这方面多思考、多总结。</p><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><p>常听人说，在 32 位的机器上对 long 型变量进行加减操作存在并发隐患，到底是不是这样呢？现在相信你一定能分析出来。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><h1 id="优秀回复"><a href="#优秀回复" class="headerlink" title="优秀回复"></a>优秀回复</h1><h3 id="Jialin"><a href="#Jialin" class="headerlink" title="@Jialin"></a>@Jialin</h3><p>对于双重锁的问题，我觉得任大鹏分析的蛮有道理，线程A进入第二个判空条件，进行初始化时，发生了时间片切换，即使没有释放锁，线程B刚要进入第一个判空条件时，发现条件不成立，直接返回instance引用，不用去获取锁。如果对instance进行volatile语义声明，就可以禁止指令重排序，避免该情况发生。<br>对于有些同学对CPU缓存和内存的疑问，CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片，至于什么时候把数据从缓存写到内存，没有固定的时间，同样地，对于有volatile语义声明的变量，线程A执行完后会强制将值刷新到内存中，线程B进行相关操作时会强制重新把内存中的内容写入到自己的缓存，这就涉及到了volatile的写入屏障问题，当然也就是所谓happen-before问题。</p><h3 id="coder"><a href="#coder" class="headerlink" title="@coder"></a>@coder</h3><p>long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题🌝🌝🌝</p><h3 id="嘎嘎"><a href="#嘎嘎" class="headerlink" title="@嘎嘎"></a>@嘎嘎</h3><p>针对阿根一世的问题，问题其实出现在new Singleton()这里。<br>这一行分对于CPU来讲，有3个指令：<br>1.分配内存空间<br>2.初始化对象<br>3.instance引用指向内存空间<br>正常执行顺序1-2-3<br>但是CPU重排序后执行顺序可能为1-3-2，那么问题就来了<br>步骤如下：<br>1.A、B线程同时进入了第一个if判断<br>2.A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();<br>3.然后线程A执行1-&gt; JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance<br>4.在还没有进行第三步（将instance引用指向内存空间）的时候，线程A离开了synchronized块<br>5.线程B进入synchronized块，读取到了A线程返回的instance，此时这个instance并未进行物理地址指向，是一个空对象。<br>有人说将对象设置成volatile，其实也不能完全解决问题。volatile只是保证可见性，并不保证原子性。</p><p>现行的比较通用的做法就是采用静态内部类的方式来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingletonHandler</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> MySingleton instanct = <span class="keyword">new</span> MySingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MySingletonHandler.instanct;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="别皱眉"><a href="#别皱眉" class="headerlink" title="@别皱眉"></a>@别皱眉</h3><p>周末了<br>对留言问题总结一下</p><p>——可见性问题——<br>对于可见性那个例子我们先看下定义:<br>可见性:一个线程对共享变量的修改，另外一个线程能够立刻看到</p><p>并发问题往往都是综合证，这里即使是单核CPU，只要出现线程切换就会有原子性问题。但老师的目的是为了让大家明白什么是可见性<br>或许我们可以把线程对变量的读可写都看作时原子操作，也就是cpu对变量的操作中间状态不可见，这样就能更加理解什么是可见性了。</p><p>——CPU缓存刷新到内存的时机——<br>cpu将缓存写入内存的时机是不确定的。除非你调用cpu相关指令强刷</p><p>——双重锁问题——<br>如果A线程与B线程如果同时进入第一个分支，那么这个程序就没有问题</p><p>如果A线程先获取锁并出现指令重排序时，B线程未进入第一个分支，那么就可能出现空指针问题，这里说可能出现问题是因为当把内存地址赋值给共享变量后，CPU将数据写回缓存的时机是随机的</p><p>—— synchronized——<br>线程在synchronized块中，发生线程切换，锁是不会释放的</p><p>——指令优化——<br>除了编译优化,有一部分可以通过看汇编代码来看，但是CPU和解释器在运行期也会做一部分优化，所以很多时候都是看不到的，也很难重现。</p><p>——JMM模型和物理内存、缓存等关系——<br>内存、cpu缓存是物理存在，jvm内存是软件存在的。<br>关于线程的工作内存和寄存器、cpu缓存的关系 大家可以参考这篇文章<br><a href="https://blog.csdn.net/u013851082/article/details/70314778/" target="_blank" rel="external">https://blog.csdn.net/u013851082/article/details/70314778/</a></p><p>——IO操作——<br>io操作不占用cpu，读文件，是设备驱动干的事，cpu只管发命令。发完命令，就可以干别的事情了。</p><p>——寄存器切换——<br>寄存器是共用的，A线程切换到B线程的时候，寄存器会把操作A的相关内容会保存到内存里，切换回来的时候，会从内存把内容加载到寄存器。可以理解为每个线程有自己的寄存器</p><p>请老师帮忙看看，有没问题。希望我的总结能帮到更多人😄😄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 并发编程实战 (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java匠人手法-优雅的处理空值</title>
    <link href="https://zhangslob.github.io/2020/03/04/Java%E5%8C%A0%E4%BA%BA%E6%89%8B%E6%B3%95-%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC/"/>
    <id>https://zhangslob.github.io/2020/03/04/Java匠人手法-优雅的处理空值/</id>
    <published>2020-03-04T12:34:00.939Z</published>
    <updated>2020-03-04T12:40:32.287Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十五篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><blockquote><p>在笔者几年的开发经验中，经常看到项目中存在到处空值判断的情况，这些判断，会让人觉得摸不这头绪，它的出现很有可能和当前的业务逻辑并没有关系。但它会让你很头疼。<br>有时候，更可怕的是系统因为这些空值的情况，会抛出空指针异常，导致业务系统发生问题。<br>此篇文章，我总结了几种关于空值的处理手法，希望对读者有帮助。</p></blockquote><h1 id="业务中的空值"><a href="#业务中的空值" class="headerlink" title="业务中的空值"></a>业务中的空值</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>存在一个UserSearchService用来提供用户查询的功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="问题现场"><a href="#问题现场" class="headerlink" title="问题现场"></a>问题现场</h2><p>对于面向对象语言来讲，抽象层级特别的重要。尤其是对接口的抽象，它在设计和开发中占很大的比重，我们在开发时希望尽量面向接口编程。<br>对于以上描述的接口方法来看，大概可以推断出可能它包含了以下两个含义:</p><ol><li>listUser(): 查询用户列表</li><li>get(Integer id): 查询单个用户</li></ol><p>在所有的开发中，XP推崇的TDD模式可以很好的引导我们对接口的定义，所以我们将TDD作为开发代码的”推动者”。<br>对于以上的接口，当我们使用TDD进行测试用例先行时，发现了潜在的问题：</p><ol><li>listUser() 如果没有数据，那它是返回空集合还是null呢？</li><li>get(Integer id) 如果没有这个对象，是抛异常还是返回null呢？</li></ol><h3 id="深入listUser研究"><a href="#深入listUser研究" class="headerlink" title="深入listUser研究"></a>深入listUser研究</h3><p>我们先来讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listUser()</div></pre></td></tr></table></figure><p>这个接口，我经常看到如下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>&#123;</div><div class="line">    List&lt;User&gt; userList = userListRepostity.selectByExample(<span class="keyword">new</span> UserExample());</div><div class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList))&#123;<span class="comment">//spring util工具类</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码返回是null,从我多年的开发经验来讲，对于集合这样返回值，最好不要返回null，因为如果返回了null，会给调用者带来很多麻烦。你将会把这种调用风险交给调用者来控制。</p><p>如果调用者是一个谨慎的人，他会进行是否为null的条件判断。如果他并非谨慎，或者他是一个面向接口编程的狂热分子(当然，面向接口编程是正确的方向)，他会按照自己的理解去调用接口，而不进行是否为null的条件判断，如果这样的话，是非常危险的，它很有可能出现空指针异常！</p><p>根据墨菲定律来判断: “很有可能出现的问题，在将来一定会出现!”</p><p>基于此，我们将它进行优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>&#123;</div><div class="line">    List&lt;User&gt; userList = userListRepostity.selectByExample(<span class="keyword">new</span> UserExample());</div><div class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList))&#123;</div><div class="line">      <span class="keyword">return</span> Lists.newArrayList();<span class="comment">//guava类库提供的方式</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于接口(List listUser())，它一定会返回List，即使没有数据，它仍然会返回List（集合中没有任何元素）;</p><p>通过以上的修改，我们成功的避免了有可能发生的空指针异常，这样的写法更安全！</p><h3 id="深入研究get方法"><a href="#深入研究get方法" class="headerlink" title="深入研究get方法"></a>深入研究get方法</h3><p>对于接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span></div></pre></td></tr></table></figure><p>你能看到的现象是，我给出id，它一定会给我返回User。但事实真的很有可能不是这样的。</p><p>我看到过的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> userRepository.selectByPrimaryKey(id);<span class="comment">//从数据库中通过id直接获取实体对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相信很多人也都会这样写。</p><p>通过代码的时候得知它的返回值很有可能是null! 但我们通过的接口是分辨不出来的!这个是个非常危险的事情。尤其对于调用者来说！</p><p>我给出的建议是，需要在接口明明时补充文档,比如对于异常的说明,使用注解@exception:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们把接口定义加上了说明之后，调用者会看到，如果调用此接口，很有可能抛出“UserNotFoundException(找不到用户)”这样的异常。</p><p>这种方式可以在调用者调用接口的时候看到接口的定义，但是，这种方式是”弱提示”的！如果调用者忽略了注释，有可能就对业务系统产生了风险，这个风险有可能导致一个亿！</p><p>除了以上这种”弱提示”的方式，还有一种方式是，返回值是有可能为空的。那要怎么办呢？</p><p>我认为我们需要增加一个接口，用来描述这种场景。引入jdk8的Optional,或者使用guava的Optional.看如下定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Optional有两个含义: 存在 or 缺省。</p><p>那么通过阅读接口getOptional()，我们可以很快的了解返回值的意图，这个其实是我们想看到的，它去除了二义性。</p><p>它的实现可以写成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(Integer id)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> Optional.ofNullable(userRepository.selectByPrimaryKey(id));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="深入入参"><a href="#深入入参" class="headerlink" title="深入入参"></a>深入入参</h3><p>通过上述的所有接口的描述，你能确定入参id一定是必传的吗？ 我觉得答案应该是：不能确定。除非接口的文档注释上加以说明。</p><p>那如何约束入参呢?</p><p>我给大家推荐两种方式：</p><ol><li>强制约束</li><li>文档性约束（弱提示）</li></ol><p>1.强制约束，我们可以通过jsr 303进行严格的约束声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(@NotNull Integer id)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(@NotNull Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，这样写，要配合AOP的操作进行验证，但让spring已经提供了很好的集成方案，在此我就不在赘述了。</p><p>2.文档性约束</p><p>在很多时候，我们会遇到遗留代码，对于遗留代码，整体性改造的可能性很小。<br>我们更希望通过阅读接口的实现，来进行接口的说明。</p><p>jsr 305规范，给了我们一个描述接口入参的一个方式(需要引入库 com.google.code.findbugs:jsr305):</p><p>可以使用注解: @Nullable @Nonnull @CheckForNull 进行接口说明。<br>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="meta">@CheckForNull</span></div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(@NonNull Integer id)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(@NonNull Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过 空集合返回值，Optional，jsr 303，jsr 305这几种方式，可以让我们的代码可读性更强，出错率更低！</p><ol><li>空集合返回值 ： 如果有集合这样返回值时，除非真的有说服自己的理由，否则，一定要返回空集合，而不是null</li><li>Optional: 如果你的代码是jdk8，就引入它！ 如果不是，则使用Guava的Optional,或者升级jdk版本！ 它很大程度的能增加了接口的可读性！</li><li>jsr 303: 如果新的项目正在开发，不防加上这个试试！ 一定有一种特别爽的感觉!</li><li>jsr 305: 如果老的项目在你的手上，你可以尝试的加上这种文档型注解，有助于你后期的重构，或者新功能增加了，对于老接口的理解!</li></ol><h1 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>我们来看一个DTO转化的场景，对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> String dtoName;</div><div class="line">  <span class="keyword">private</span> String dtoAge;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String age;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需求是将Person对象转化成PersonDTO，然后进行返回。</p><p>当然对于实际操作来讲，返回如果Person为空，将返回null,但是PersonDTO是不能返回null的（尤其Rest接口返回的这种DTO）。</p><p>在这里，我们只关注转化操作，看如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">  PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">  Person person = <span class="keyword">new</span> Person();</div><div class="line">  <span class="keyword">if</span>(!Objects.isNull(person))&#123;</div><div class="line">    personDTO.setDtoAge(person.getAge());</div><div class="line">    personDTO.setDtoName(person.getName());</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    personDTO.setDtoAge(<span class="string">""</span>);</div><div class="line">    personDTO.setDtoName(<span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优化修改"><a href="#优化修改" class="headerlink" title="优化修改"></a>优化修改</h2><p>这样的数据转化，我们认识可读性非常差，每个字段的判断，如果是空就设置为空字符串(“”)</p><p>换一种思维方式进行思考，我们是拿到Person这个类的数据，然后进行赋值操作(setXXX),其实是不关系Person的具体实现是谁的。</p><p>那我们可以创建一个Person子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它作为Person的一种特例而存在，如果当Person为空的时候，则返回一些get的默认行为.</p><p>所以代码可以修改为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">   PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">   Person person = getPerson();</div><div class="line">   personDTO.setDtoAge(person.getAge());</div><div class="line">   personDTO.setDtoName(person.getName());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> NullPerson();<span class="comment">//如果Person是null ,则返回空对象</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>其中getPerson()方法，可以用来根据业务逻辑获取Person有可能的对象（对当前例子来讲，如果Person不存在，返回Person的的特例NUllPerson），如果修改成这样，代码的可读性就会变的很强了。</p><h2 id="使用Optional可以进行优化"><a href="#使用Optional可以进行优化" class="headerlink" title="使用Optional可以进行优化"></a>使用Optional可以进行优化</h2><p>空对象模式，它的弊端在于需要创建一个特例对象，但是如果特例的情况比较多，我们是不是需要创建多个特例对象呢，虽然我们也使用了面向对象的多态特性，但是，业务的复杂性如果真的让我们创建多个特例对象，我们还是要再三考虑一下这种模式，它可能会带来代码的复杂性。</p><p>对于上述代码，还可以使用Optional进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">    Optional.ofNullable(getPerson()).ifPresent(person -&gt; &#123;</div><div class="line">      personDTO.setDtoAge(person.getAge());</div><div class="line">      personDTO.setDtoName(person.getName());</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>Optional对空值的使用，我觉得更为贴切，它只适用于”是否存在”的场景。</p><p>如果只对控制的存在判断，我建议使用Optional.</p><h1 id="Optioanl的正确使用"><a href="#Optioanl的正确使用" class="headerlink" title="Optioanl的正确使用"></a>Optioanl的正确使用</h1><p>Optional如此强大，它表达了计算机最原始的特性(0 or 1),那它如何正确的被使用呢!</p><h2 id="Optional不要作为参数"><a href="#Optional不要作为参数" class="headerlink" title="Optional不要作为参数"></a>Optional不要作为参数</h2><p>如果你写了一个public方法，这个方法规定了一些输入参数，这些参数中有一些是可以传入null的，那这时候是否可以使用Optional呢？</p><p>我给的建议是: 一定不要这样使用!</p><p>举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">(Optional&lt;String&gt; username)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个例子的方法 listUser,可能在告诉我们需要根据username查询所有数据集合，如果username是空，也要返回所有的用户集合.</p><p>当我们看到这个方法的时候，会觉得有一些歧义:</p><p>“如果username是absent,是返回空集合吗？还是返回全部的用户数据集合？”</p><p>Optioanl是一种分支的判断，那我们究竟是关注 Optional还是Optional.get()呢？</p><p>我给大家的建议是，如果不想要这样的歧义，就不要使用它！</p><p>如果你真的想表达两个含义，就給它拆分出两个接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">(String username)</span></span>;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我觉得这样的语义更强，并且更能满足 软件设计原则中的 “单一职责”。</p><p>如果你觉得你的入参真的有必要可能传null,那请使用jsr 303或者jsr 305进行说明和验证!</p><p>请记住! Optional不能作为入参的参数!</p><h2 id="Optional作为返回值"><a href="#Optional作为返回值" class="headerlink" title="Optional作为返回值"></a>Optional作为返回值</h2><h3 id="当个实体的返回"><a href="#当个实体的返回" class="headerlink" title="当个实体的返回"></a>当个实体的返回</h3><p>那Optioanl可以做为返回值吗？</p><p>其实它是非常满足是否存在这个语义的。</p><p>你如说，你要根据id获取用户信息，这个用户有可能存在或者不存在。</p><p>你可以这样使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当调用这个方法的时候，调用者很清楚get方法返回的数据，有可能不存在，这样可以做一些更合理的判断，更好的防止空指针的错误！</p><p>当然，如果业务方真的需要根据id必须查询出User的话，就不要这样使用了，请说明，你要抛出的异常.</p><p>只有当考虑它返回null是合理的情况下，才进行Optional的返回</p><h3 id="集合实体的返回"><a href="#集合实体的返回" class="headerlink" title="集合实体的返回"></a>集合实体的返回</h3><p>不是所有的返回值都可以这样用的！ 如果你返回的是集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  Optional&lt;List&lt;User&gt;&gt; listUser();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样的返回结果，会让调用者不知所措，是否我判断Optional之后，还用进行isEmpty的判断呢？</p><p>这样带来的返回值歧义！ 我认为是没有必要的。</p><p>我们要约定，对于List这种集合返回值，如果集合真的是null的，请返回空集合(Lists.newArrayList);</p><h2 id="使用Optional变量"><a href="#使用Optional变量" class="headerlink" title="使用Optional变量"></a>使用Optional变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; userOpt = ...</div></pre></td></tr></table></figure><p>如果有这样的变量userOpt,请记住 ：</p><ol><li>一定不能直接使用get ，如果这样用，就丧失了Optional本身的含义 （ 比如userOp.get() ）</li><li>不要直接使用getOrThrow ,如果你有这样的需求：获取不到就抛异常。 那就要考虑，是否是调用的接口设计的是否合理</li></ol><h2 id="getter中的使用"><a href="#getter中的使用" class="headerlink" title="getter中的使用"></a>getter中的使用</h2><p>对于一个java bean,所有的属性都有可能返回null,那是否需要改写所有的getter成为Optional类型呢？</p><p>我给大家的建议是，不要这样滥用Optional.</p><p>即便 我java bean中的getter是符合Optional的，但是因为java bean 太多了，这样会导致你的代码有50%以上进行Optinal的判断，这样便污染了代码。(我想说，其实你的实体中的字段应该都是由业务含义的，会认真的思考过它存在的价值的，不能因为Optional的存在而滥用)</p><p>我们应该更关注于业务，而不只是空值的判断。</p><p>请不要在getter中滥用Optional.</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>可以这样总结Optional的使用：</p><ol><li>当使用值为空的情况，并非源于错误时，可以使用Optional!</li><li>Optional不要用于集合操作!</li><li>不要滥用Optional,比如在java bean的getter中!</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-136-只出现一次的数字</title>
    <link href="https://zhangslob.github.io/2020/02/23/Leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://zhangslob.github.io/2020/02/23/Leetcode-136-只出现一次的数字/</id>
    <published>2020-02-23T06:28:19.620Z</published>
    <updated>2020-02-23T07:00:07.701Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十四篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="external">https://leetcode-cn.com/problems/single-number</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="粗暴解法"><a href="#粗暴解法" class="headerlink" title="粗暴解法"></a>粗暴解法</h2><p>使用map保存每个元素在数组中出现的次数，key是元素，value是出现次数。</p><p>这种方法显然不符合题目需求，不使用额外空间。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>按位异或：<strong>参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。</strong></p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0^0 = 0，</div><div class="line">1^0 = 1，</div><div class="line">0^1 = 1，</div><div class="line">1^1 = 0</div></pre></td></tr></table></figure><p>异或运算的符号是<code>^</code>，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a xor b = (a &amp; ^b) | (^a &amp; b)</div></pre></td></tr></table></figure><p>真值表：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">a xor b</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>因为有定律<code>a ^ b ^ a = b</code>，所以我们这里就可以使用异或来做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_number</span><span class="params">(numbers)</span>:</span></div><div class="line">    tmp = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        tmp ^= n</div><div class="line">    <span class="keyword">return</span> tmp</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">        result ^= num;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到非常简单。</p><p>这些全都是计算机基础知识，但是自己不知道，只能说明自己基础差，以后补得起来吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十四篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka 消费者 Java 实现</title>
    <link href="https://zhangslob.github.io/2020/01/09/Kafka-%E6%B6%88%E8%B4%B9%E8%80%85-Java-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangslob.github.io/2020/01/09/Kafka-消费者-Java-实现/</id>
    <published>2020-01-09T13:01:06.553Z</published>
    <updated>2020-01-09T13:33:23.013Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十三篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/UveOWwz.jpg" alt=""></p><a id="more"></a><p>应用程序使用 KafkaConsumer向 Kafka 订阅 Topic 接收消息，首先理解 Kafka 中消费者（consumer）和消费者组（consumer group）的概念和特性。</p><h1 id="KafkaConsumer"><a href="#KafkaConsumer" class="headerlink" title="KafkaConsumer"></a>KafkaConsumer</h1><h2 id="消费者和消费者组"><a href="#消费者和消费者组" class="headerlink" title="消费者和消费者组"></a>消费者和消费者组</h2><p>当生产者向 Topic 写入消息的速度超过了消费者（consumer）的处理速度，导致大量的消息在 Kafka 中淤积，此时需要对消费者进行横向伸缩，用多个消费者从同一个主题读取消息，对消息进行分流。</p><p>Kafka 的消费者都属于消费者组（consumer group）。一个组中的 consumer 订阅同样的 topic，每个 consumer 接收 topic 一些分区（partition）中的消息。<strong>同一个分区不能被一个组中的多个 consumer 消费</strong>。</p><p>假设现在有一个 Topic 有4个分区，有一个消费者组订阅了这个 Topic，随着组中的消费者数量从1个增加到5个时，Topic 中分区被读取的情况：</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/kakfa_consumer.png" alt=""></p><p>如果组中 consumer 的数量超过分区数，多出的 consumer 会被闲置。因此，如果想提高消费者的并行处理能力，需要设置足够多的 partition 数量。</p><p>除了通过增加 consumer 来横向伸缩单个应用程序外，还会出现多个应用程序从同一个 Topic 读取数据的情况。这也是 Kafka 设计的主要目标之一：让 Topic 中的数据能够满足各种应用场景的需求。</p><p>如果要每个应用程序都可以获取到所有的消息，而不只是其中的一部分，只要保证每个应用程序有自己的 consumer group，就可以获取到 Topic 所有的消息：</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/kakfa_consumer2.png" alt=""></p><p>横向伸缩 Kafka 消费者和消费者群组并不会对性能造成负面影响。</p><h2 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h2><p>一个消费者组内的 consumer 共同读取 Topic 的分区。</p><ol><li>当一个 consumer 加入组时，读取的是原本由其他 consumer 读取的分区。</li><li>当一个 consumer 离开组时（被关闭或发生崩溃），原本由它读取的分区将由组里的其他 consumer 来读取。</li><li>当 Topic 发生变化时，比如添加了新的分区，会发生分区重分配。</li></ol><p>分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡（rebalance）。再均衡非常重要，为消费者组带来了高可用性和伸缩性，可以放心的增加或移除消费者。</p><p>再均衡期间，消费者无法读取消息，造成整个 consumer group 一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，当前的读取状态会丢失。</p><p>消费者通过向作为组协调器（GroupCoordinator）的 broker（不同的组可以有不同的协调器）发送心跳来维持和群组以及分区的关系。心跳表明消费者在读取分区里的消息。消费者会在轮询消息或提交偏移量（offset）时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，组协调器认为消费者已经死亡，会触发一次再均衡。</p><p>在 Kafka 0.10.1 的版本中，对心跳行为进行了修改，由一个独立的线程负责心跳。</p><h1 id="消费-Kafka"><a href="#消费-Kafka" class="headerlink" title="消费 Kafka"></a>消费 Kafka</h1><h2 id="创建-Kafka-消费者"><a href="#创建-Kafka-消费者" class="headerlink" title="创建 Kafka 消费者"></a>创建 Kafka 消费者</h2><p>在读取消息之前，需要先创建一个 KafkaConsumer 对象。创建 KafkaConsumer 对象与创建 KafkaProducer 非常相似，创建 KafkaConsumer 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092, broker2:9092"</span>);</div><div class="line"><span class="comment">// group.id，指定了消费者所属群组</span></div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serializaiton.StrignDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serializaiton.StrignDeserializer"</span>);</div><div class="line"></div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</div></pre></td></tr></table></figure><h2 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h2><p>创建了消费者之后，需要订阅 Topic，subscribe() 方法接受一个主题列表作为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// topic name is “customerCountries”</span></div><div class="line">consumer.subscribe(Collections.singletonList(<span class="string">"customerCountries"</span>));</div></pre></td></tr></table></figure><p>subscribe() 也可以接收一个正则表达式，匹配多个主题（如果有新的名称匹配的主题创建，会立即触发一次再均衡，消费者就可以读取新添加的主题）。在 Kafka 和其他系统之间复制数据时，使用正则表达式的方式订阅多个主题是很常见的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅所有 test 前缀的 Topic：</span></div><div class="line">consumer.subscribe(<span class="string">"test.*"</span>);</div></pre></td></tr></table></figure><h2 id="消息轮询"><a href="#消息轮询" class="headerlink" title="消息轮询"></a>消息轮询</h2><p>消息轮询是消费者的核心，通过轮询向服务器请求数据。消息轮询 API 会处理所有的细节，包括群组协调、分区再均衡、发送心跳和获取数据，开发者只需要处理从分区返回的数据。消费者代码的主要部分如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 100 是超时时间（ms），在该时间内 poll 会等待服务器返回数据</span></div><div class="line">        ConsumerReccords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>); </div><div class="line"></div><div class="line">        <span class="comment">// poll 返回一个记录列表。</span></div><div class="line">        <span class="comment">// 每条记录都包含了记录所属主题的信息、记录所在分区的信息、记录在分区里的偏移量，以及记录的键值对。</span></div><div class="line">        <span class="keyword">for</span> (ConsumerReccord&lt;String, String&gt; record : records) &#123;</div><div class="line">            log.debug(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">                record.topic(), record.partition(), record.offset(), </div><div class="line">                record.key(), record.value());</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭消费者,网络连接和 socket 也会随之关闭，并立即触发一次再均衡</span></div><div class="line">    consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在第一次调用新消费者的 poll() 方法时，会负责查找 GroupCoordinator，然后加入群组，接受分配的分区。如果发生了再均衡，整个过程也是在轮询期间进行的。心跳也是从轮询里发送出去的。</p><h1 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h1><p>Kafka 与消费者相关的配置大部分参数都有合理的默认值，一般不需要修改，不过有一些参数与消费者的性能和可用性有很大关系。接下来介绍这些重要的属性。</p><h3 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a>fetch.min.bytes</h3><p>指定消费者从服务器获取记录的最小字节数。服务器在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes，那么会等到有足够的可用数据时才返回给消费者。</p><p>合理的设置可以降低消费者和 broker 的工作负载，在 Topic 消息生产不活跃时，减少处理消息次数。如果没有很多可用数据，但消费者的 CPU 使用率却很高，需要调高该属性的值。如果消费者的数量比较多，调高该属性的值也可以降低 broker 的工作负载。</p><h3 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a>fetch.max.wait.ms</h3><p>指定在 broker 中的等待时间，默认是500ms。如果没有足够的数据流入 Kafka，消费者获取的数据量的也没有达到 fetch.min.bytes，最终导致500ms的延迟。</p><p>如果要降低潜在的延迟（提高 SLA），可以调低该属性的值。fetch.max.wait.ms 和 fetch.min.bytes 有一个满足条件就会返回数据。</p><h3 id="max-parition-fetch-bytes"><a href="#max-parition-fetch-bytes" class="headerlink" title="max.parition.fetch.bytes"></a>max.parition.fetch.bytes</h3><p>指定了服务器从每个分区里返回给消费者的最大字节数，默认值是1MB。也就是说 KafkaConsumer#poll() 方法从每个分区里返回的记录最多不超过 max.parition.fetch.bytes 指定的字节。</p><p>如果一个主题有20个分区和5个消费者（同一个组内），那么每个消费者需要至少4MB 的可用内存（每个消费者读取4个分区）来接收记录。如果组内有消费者发生崩溃，剩下的消费者需要处理更多的分区。</p><p>max.parition.fetch.bytes 必须比 broker 能够接收的最大消息的字节数（max.message.size）大，否则消费者可能无法读取这些消息，导致消费者一直重试。</p><p>另一个需要考虑的因素是消费者处理数据的时间。消费者需要频繁调用 poll() 方法来避免会话过期和发生分区再均衡，如果单次调用 poll() 返回的数据太多，消费者需要更多的时间来处理，可能无法及时进行下一个轮询来避免会话过期。如果出现这种情况，可以把 max.parition.fetch.bytes 值改小或者延长会话过期时间。</p><h3 id="session-timeout-ms"><a href="#session-timeout-ms" class="headerlink" title="session.timeout.ms"></a>session.timeout.ms</h3><p>指定了消费者与服务器断开连接的最大时间，默认是3s。如果消费者没有在指定的时间内发送心跳给 GroupCoordinator，就被认为已经死亡，会触发再均衡，把它的分区分配给其他消费者。</p><p>该属性与 heartbeat.interval.ms 紧密相关，heartbeat.interval.ms 指定了 poll() 方法向协调器发送心跳的频率，session.timeout.ms 指定了消费者最长多久不发送心跳。所以，一般需要同时修改这两个属性，heartbeat.interval.ms 必须比 session.timeout.ms 小，一般是 session.timeout.ms 的三分之一，如果 session.timeout.ms 是 3s，那么 heartbeat.interval.ms 应该是 1s。</p><p>调低属性的值可以更快地检测和恢复崩溃的节点，不过长时间的轮询或垃圾收集可能导致非预期的再均衡。调高属性的值，可以减少意外的再均衡，不过检测节点崩溃需要更长的时间。</p><h3 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h3><p>指定了消费者在读取一个没有偏移量（offset）的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时井被删除）该作何处理，默认值是 latest，表示在 offset 无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）。</p><p>另一个值是 earliest，消费者将从起始位置读取分区的记录。</p><h3 id="enable-auto-commit"><a href="#enable-auto-commit" class="headerlink" title="enable.auto.commit"></a>enable.auto.commit</h3><p>指定了消费者是否自动提交偏移量，默认值是 true，自动提交。</p><p>设为 false 可以程序自己控制何时提交偏移量。如果设为 true，需要通过配置 auto.commit.interval.ms 属性来控制提交的频率。</p><h3 id="partition-assignment-strategy"><a href="#partition-assignment-strategy" class="headerlink" title="partition.assignment.strategy"></a>partition.assignment.strategy</h3><p>分区分配给组内消费者的策略，根据给定的消费者和 Topic，决定哪些分区应该被分配给哪个消费者。Kafka 有两个默认的分配策略：</p><ul><li>Range，把 Topic 的若干个连续的分区分配给消费者。<br>假设 consumer1 和 consumer2（c1、c2 代替）订阅了 topic1 和 topic2（t1、t2 代替），每个 Topic 都有3个分区。那么 c1 可能分配到 t1-part-0、t1-part-1、t2-part-0 和 t2-part1，而 c2 可能分配到 t1-part-2 和 t2-part-2。只要使用了 Range 策略，而且分区数量无法被消费者数量整除，就会出现这种情况。</li><li>RoundRobin，把所有分区逐个分配给消费者。<br>上面的例子如果使用 RoundRobin 策略，那么 c1 可能分配到 t1-part-0、t1-part-2 和 t2-part-1，c2 可能分配到 t1-part-1、t2-part-0 和 t2-part-2。一般来说，RoundRobin 策略会给所有消费者分配大致相同的分区数。</li></ul><p>默认值是 org.apache.kafka.clients.consumer.RangeAssignor，这个类实现了 Range 策略，org.apache.kafka.clients.consumer.RoundRobinAssignor 是 RoundRobin 策略的实现类。还可以使用自定义策略，属性值设为自定义类的名字。</p><h3 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a>client.id</h3><p>broker 用来标识从客户端发送过来的消息，可以是任意字符串，通常被用在日志、度量指标和配额中。</p><h3 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h3><p>用于控制单次调用 call() 方法能够返回的记录数量，帮助控制在轮询里需要处理的数据量。</p><h3 id="receive-buffer-bytes-和-send-buffer-bytes"><a href="#receive-buffer-bytes-和-send-buffer-bytes" class="headerlink" title="receive.buffer.bytes 和 send.buffer.bytes"></a>receive.buffer.bytes 和 send.buffer.bytes</h3><p>分别指定了 TCP socket 接收和发送数据包的缓冲区大小。如果设为-1就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p><h1 id="消费与提交"><a href="#消费与提交" class="headerlink" title="消费与提交"></a>消费与提交</h1><h2 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h2><p>每次调用 poll() 方法，总是返回 Kafka 中还没有被消费者读取过的记录，使用偏移量（offset）来记录消费者读取的分区的位置。</p><p>更新分区当前位置的操作叫做“提交（commit）”，消费者是如何提交偏移量的呢？</p><p>消费者向一个特殊的 Topic：<code>_consumer_offset</code> 发送消息，消息包含每个分区的偏移量。偏移量只有在消费者发生崩溃或者有新的消费者加入群组触发再均衡时有用。完成再均衡之后，消费者可能分配到新的分区，为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的 offset，然后从 offset 指定的地方继续处理。<br>如果提交的 offset 大于客户端处理的最后一个消息偏移量，那么处于两个偏移量之间的消息会丢失。反之则会消息重复。</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/commit-offset-2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/commit-offset-1.png" alt=""></p><p>所以，处理偏移量的方式对应用程序会有很大的影响。KafkaConsumer API 提供了多种方式来提交偏移量。</p><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>最简单的方式是消费者自动提交偏移量。如果 enable.auto.commit 设为 true，那 么每过一定时间间隔，消费者会自动把从 poll() 方法接收到的最大偏移量提交上去。提交时间间隔由 auto.commit.interval.ms 控制，默认是5s。</p><p>自动提交是在轮询里进行的。消费者每次在进行轮询时会检查是否需要提交偏移量，如果是，那么会提交从上一次轮询返回的偏移量。</p><p>假设我们使用默认的5s提交时间间隔，在最近一次提交之后的3s发生了再均衡，再 均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了3s，这3s内的数据已经处理过，再次消费是还会获取到。通过调低提交时间间隔来更频繁地提交偏移量，减小可能出现重复消费的时间窗，不过这种情况是无法完全避免的。</p><p>在使用自动提交时，每次调用轮询方法都会把上一次调用返回的偏移量提交上去，并不 知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（在调用 close() 方法前也会进行自动提交）。</p><p>在处理异常或提前退出轮询时要格外小心。自动提交虽然方便，不过并没有为开发者留有余地来避免重复处理消息。</p><h2 id="提交当前偏移量"><a href="#提交当前偏移量" class="headerlink" title="提交当前偏移量"></a>提交当前偏移量</h2><p>KafkaConsumer API 提供的另一种提交偏移量的方式，程序主动触发提交当前偏移量，而不是基于时间间隔自动提交。</p><p>把 auto.commit.offset 设为 false，使用 commitSync() 方法提交偏移量最简单也最可靠，该方法会提交由 poll() 方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。</p><p>需要注意，commitSync() 将会提交 poll() 返回的最新偏移量，在处理完所有记录后调用 commitSync()，否则还是会有丢失消息的风险。</p><p>commitSync() 提交偏移量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>, </div><div class="line">            record.topic(), record.partition(), record.offset(),</div><div class="line">            record.key(), record.value());</div><div class="line">        <span class="comment">// 处理消息的逻辑省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// poll 的数据全部处理完提交</span></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">        log.error(<span class="string">"commit failed"</span>, e)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只要没有发生不可恢复的错误，commitSync() 会一直尝试直至提交成功。如果提交 失败会抛出 CommitFailedException 异常。</p><h2 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h2><p>手动提交有一个不足之处，在 broker 对提交请求作出回应之前，应用程序会阻塞，这会影响应用程序的吞吐量。可以使用异步提交的方式，不等待 broker 的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>, </div><div class="line">            record.topic(), record.partition(), record.offset(),</div><div class="line">            record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 异步提交</span></div><div class="line">    consumer.commitAsync();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在成功提交或发生无法恢复的错误之前，commitSync() 会一直尝试直至提交成功，但是 commitAsync() 不会，这也是该方法的一个问题。之所以不进行重试，是因为在收到服务器响应之前，可能有一个更大的偏移量已经提交成功。</p><p>假设我们发出一个请求提交偏移量2000，这个时候发生了短暂的通信问题，服务器收不到请求，与此同时，程序处理了另外一批消息，并成功提交了偏移量3000。如果 commitAsync() 重新尝试提交偏移量2000，有可能将偏移量3000改为2000，这个时候如果发生再均衡，就会出现重复消息。</p><p>commitAsync() 支持回调，在 broker 作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标，如果要用它来进行重试，一定要注意提交的顺序。</p><p>commitAsync() 支持回调，在 broker 作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标，如果要用它来进行重试，一定要注意提交的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">            record.topic(), record.partition(), record.offset(), </div><div class="line">            record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 提交完成时回回调此函数</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                log.error(<span class="string">"Commit failed for offsets &#123;&#125;"</span>, offsets, e);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重试异步提交</p><p>可以使用一个单调递增的序列号来维护异步提交的顺序。在每次提交偏移量之后或在回调里提交偏移量时递增序列号。在进行重试前，先检查回调的序列号和即将提交的偏移量是否相等，如果相等，说明没有新的提交，那么可以安全地进行重试。如果序列号比较大，说明有一个新的提交已经发送出去了，放弃重试。</p><h2 id="同步与异步混合提交"><a href="#同步与异步混合提交" class="headerlink" title="同步与异步混合提交"></a>同步与异步混合提交</h2><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，如果因为临时网络问题导致的，那么后续的提交总会有成功的。但如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功。</p><p>在消费者关闭前一般会组合使用 commitAsync() 和 commitSync()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">                record.topic(), record.partition(), record.offset(), </div><div class="line">                record.key(), record.value());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 异步提交</span></div><div class="line">        consumer.commitAsync();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Unexpected error"</span>, e);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 同步提交</span></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        consumer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在正常处理流程中，使用异步提交来提高性能，最后使用同步提交来保证位移提交成功。</p><h2 id="提交特定的偏移量"><a href="#提交特定的偏移量" class="headerlink" title="提交特定的偏移量"></a>提交特定的偏移量</h2><p>一般提交偏移量的频率与处理消息批次的频率是一样的。如果想要更频繁地提交怎么办？如果 poll() 方法返回一大批数据，为了避免因再均衡引起的重复处理整批消息，想要在批次中间提交偏移量该怎么办？</p><p>这种情况无法通过调用 commitSync() 或 commitAsync() 来实现，只会提交最后一个偏移量，而此时该批次里的消息还没有处理完。</p><p>KafkaConsumer API 允许在调用 commitSync() 和 commitAsync() 方法时传进去希望提交的分区和偏移量的 map。因为消费者可能不只读取一个分区，需要跟踪所有分区的偏移量，所以在这个层面上控制偏移量的提交会让代码变复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录分区的 offset 信息</span></div><div class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">            record.topic(), record.partition(), record.offset(), </div><div class="line">            record.key(), record.value());</div><div class="line"></div><div class="line">        <span class="comment">// 省略消息处理逻辑 ...</span></div><div class="line"></div><div class="line">        <span class="comment">// 记录分区的 offset</span></div><div class="line">        currentOffsets.put(</div><div class="line">            <span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">            <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>, <span class="string">"no metadata"</span>)</div><div class="line">        );</div><div class="line"></div><div class="line">        <span class="comment">// 最多每处理 1000 条记录就提交一次偏移量</span></div><div class="line">        <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>)</div><div class="line">            consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        count++;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h1><p>消费者在退出和进行分区再均衡之前，如果消费者知道要失去对一个分区的所有权，它可能需要提交最后一个已处理记录的偏移量。KafakConsumer API 可以在消费者新增分区或者失去分区时进行处理，在调用 subscribe() 方法时传入 ConsumerRebalanceListener 对象，该对象有两个方法：</p><ul><li>public void onPartitionRevoked(Collection partitions): 在消费者停止消费消费后，在再均衡开始前调用。</li><li>public void onPartitionAssigned(Collection partitions): 在分区分配给消费者后，在消费者开始读取消息前调用。</li></ul><p>下面来看一个的例子，在消费者失去某个分区时提交 offset，以便其他消费者可以接着消费消息并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录分区的 offset 信息</span></div><div class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleRebalance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果发生再均衡，即将失去分区所有权时提交偏移量。</span></div><div class="line">    <span class="comment">// 提交的是最近处理过的偏移量，而不是批次中还在处理的最后一个偏移量。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Lost partitions in rebalance. Committing current offsets:"</span> </div><div class="line">            + currentOffsets);</div><div class="line">        consumer.commitSync(currentOffsets);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 把 ConsumerRebalanceListener 对象传给 subscribe() 方法</span></div><div class="line">    consumer.subscribe(topics, <span class="keyword">new</span> HandleRebalance());</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line"></div><div class="line">            currentOffsets.put(</div><div class="line">                <span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">                <span class="keyword">new</span> OffsetAndMetadata(record.offset()+<span class="number">1</span>, <span class="string">"no metadata"</span>)</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">    <span class="comment">// ignore</span></div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Unexpected error"</span>, e);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        consumer.commitSync(currentOffsets);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        consumer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="从指定位移开始消费"><a href="#从指定位移开始消费" class="headerlink" title="从指定位移开始消费"></a>从指定位移开始消费</h1><p>除了读取最近一次提交的位置开始消费数据，有时候也需要从特定的偏移量处开始读取消息。</p><p>如果想从分区起始位置开始消费，可以使用 seekToBeginning(TopicPartition tp)；如果想从分区的最末端消费最新的消息，可以使用 seekToEnd(TopicPartition tp)。Kafka 还支持从指定 offset 处开始消费。最典型的一个是：offset 维护在其他系统（例如数据库）中，并且以其他系统的值为准。</p><p>考虑下面的场景：从 Kafka 中读取消息进行处理，最后把结果写入数据库，可能会按如下逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">            record.offset());</div><div class="line">        processRecord(record);</div><div class="line">        storeRecordInDB(record);</div><div class="line">        consumer.commitAsync(currentOffsets);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看似正确的逻辑要注意的是，在持久化到数据库成功后，提交位移到 Kafka 可能会失败，出现不一致的情况，那么这可能会导致消息会重复处理。对于这种情况，我们需要将持久化到数据库与提交 offset 实现为原子性操作，最简单的做法，在保存记录到数据库的同时保存 offset 信息，在消费者开始消费时指定数据库的 offset 开始消费。</p><p>只需要通过 seek() 来指定分区位移开始消费即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveOffsetsOnRebalance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在分区被回收前提交数据库事务，保存消费的记录和位移</span></div><div class="line">        commitDBTransaction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在开始消费前，从数据库中获取分区的位移，使用 seek() 指定开始消费的偏移量</span></div><div class="line">        <span class="keyword">for</span>(TopicPartition partition: partitions)</div><div class="line">            consumer.seek(partition, getOffsetFromDB(partition));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">consumer.subscribe(topics, <span class="keyword">new</span> SaveOffsetOnRebalance(consumer));</div><div class="line"><span class="comment">// 调用一次 poll() 方怯，让消费者加入到消费者群组里，并获取分配到的分区</span></div><div class="line">consumer.poll(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 然后马上调用 seek() 方法定位分区的偏移量。 </span></div><div class="line"><span class="comment">// seek() 方法只更新我们正在使用的位置，在下一次调用 poll() 时就可以获得正确的消息。</span></div><div class="line"><span class="comment">// 如果 seek() 发生错误, poll() 就会抛出异常。</span></div><div class="line"><span class="keyword">for</span> (TopicPartition partition: consumer.assignment())</div><div class="line">    consumer.seek(partition, getOffsetFromDB(partition));</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        processRecord(record);</div><div class="line">        <span class="comment">// 保存记录结果</span></div><div class="line">        storeRecordInDB(record);</div><div class="line">        <span class="comment">// 保存位移信息</span></div><div class="line">        storeOffsetInDB(record.topic(), record.partition(), record.offset());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 提交数据库事务</span></div><div class="line">    commitDBTransaction();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h1><p>一般情况下，在主线程中循环 poll() 消息并进行处理。当需要退出循环时，使用另一个线程调用 consumer.wakeup()，会使得 poll() 抛出 WakeupException。如果主线程正在处理消息，那么在下一次主线程调用 poll() 时会抛出异常。样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 JVM 关闭时的回调，当 JVM 关闭时调用</span></div><div class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Starting exit..."</span>);</div><div class="line">        <span class="comment">// 调用消费者的 wakeup 方法通知主线程退出</span></div><div class="line">        consumer.wakeup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 等待主线程退出</span></div><div class="line">            mainThread.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 消费主线程</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">    <span class="comment">// ignore</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="消息序列化"><a href="#消息序列化" class="headerlink" title="消息序列化"></a>消息序列化</h1><p>Kafka 生产者将对象序列化成字节数组并发送到服务器，消费者需要将字节数组转换成对象（反序列化）。序列化与反序列化需要匹配，与生产者类似，推荐使用 Avro 序列化方式。</p><h2 id="使用-Avro-反序列化"><a href="#使用-Avro-反序列化" class="headerlink" title="使用 Avro 反序列化"></a>使用 Avro 反序列化</h2><p>样例代码如下（与生产者实现类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"io.confluent.kafka.serializers.KafkaAvroDeserializer"</span>);</div><div class="line">props.put(<span class="string">"schema.registry.url"</span>, schemaUrl);</div><div class="line">String topic = <span class="string">"customerContacts"</span></div><div class="line"></div><div class="line">KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(createConsumerConfig(brokers, groupId, url));</div><div class="line">consumer.subscribe(Collections.singletonList(topic));</div><div class="line"></div><div class="line">System.out.println(<span class="string">"Reading topic:"</span> + topic);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">// 这里使用之前生产者使用的Avro生成的Customer类</span></div><div class="line">    ConsumerRecords&lt;String, Customer&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, Customer&gt; record: records) &#123;</div><div class="line">        System.out.println(<span class="string">"Current customer name is: "</span> + record.value().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    consumer.commitSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h1><p>一般情况下都是使用消费者组（即使只有一个消费者）来消费消息的，这样可以在增加或减少消费者时自动进行分区重平衡，这种方式是推荐的。</p><p>在知道主题和分区的情况下，也可以使用单个消费者来进行消费，需要实现给消费者分配分区，而不是让消费者订阅主题。代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取主题下所有的分区</span></div><div class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(<span class="string">"topic"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (partitionInfos != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (PartitionInfo partition : partitionInfos)</div><div class="line">        partitions.add(<span class="keyword">new</span> TopicPartition(partition.topic(), partition.partition()));</div><div class="line">    <span class="comment">// 为消费者指定分区</span></div><div class="line">    consumer.assign(partitions);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record: records) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了需要主动获取分区以及没有分区重平衡，其他的处理逻辑是一样的。需要注意的是，如果添加了新的分区，这个消费者是感知不到的，需要通过 consumer.partitionsFor() 来重新获取分区。</p><hr><p>《Kafka权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UveOWwz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://zhangslob.github.io/2020/01/05/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://zhangslob.github.io/2020/01/05/从尾到头打印链表/</id>
    <published>2020-01-05T09:19:25.036Z</published>
    <updated>2020-01-09T03:38:38.576Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十二篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>链表从头到尾输出会比较简单，于是我们很自然的想到把链表中链接节点的指正翻转过来，改变链表的方向，然后就可以从头到尾的输出了。但是该方法会修改原来链表的结构，这应该不是一个好的选择。</p><blockquote><p>在面试中，如果我们打算修改输入的数据，最好先问面试官是否允许修改。</p></blockquote><p>这道题肯定需要遍历链表的，但是遍历肯定是顺序，可是最终需要的是从尾到头，这就是典型的”先进先出“，可以使用栈实现。遍历该链表时，没经过一个节点，便把该节点放入栈中。遍历结束之后，再从栈顶输出所有值。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="解法一【推荐】"><a href="#解法一【推荐】" class="headerlink" title="解法一【推荐】"></a>解法一【推荐】</h2><p>遍历链表，每个链表结点值 push 进栈，最后将栈中元素依次 pop 到 list 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">        <span class="keyword">this</span>.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</div><div class="line">            stack.push(listNode.val);</div><div class="line">            listNode = listNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            res.add(stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().printListFromTailToHead(listNode));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>面试官看到使用了栈，会不会手动让你完成栈的实现呢。下面有栈的实现。</p><h2 id="解法二【不推荐】"><a href="#解法二【不推荐】" class="headerlink" title="解法二【不推荐】"></a>解法二【不推荐】</h2><p>利用递归方式：</p><ol><li>若不是链表尾结点，继续递归；</li><li>若是，添加到 list 中。</li></ol><p>这种方式不推荐，当递归层数过多时，容易发生 Stack Overflow。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        addElement(listNode, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(ListNode listNode, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (listNode.next != <span class="keyword">null</span>) &#123;</div><div class="line">            addElement(listNode.next, res);</div><div class="line">        &#125;</div><div class="line">        res.add(listNode.val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().printListFromTailToHead(listNode));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>通过遍历实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ListNode pre = <span class="keyword">null</span>;</div><div class="line">        ListNode next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</div><div class="line">            next = listNode.next;</div><div class="line">            listNode.next = pre;</div><div class="line">            pre = listNode;</div><div class="line">            listNode = next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(pre.val);</div><div class="line">            pre = pre.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        <span class="keyword">new</span> Solution().printListFromTailToHead(listNode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>研究了下源码，简单实现了下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.EmptyStackException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2020/1/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 元素数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elementCount;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 储存数据的数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object[] elementData;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义最大数组容量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法，默认大小为10</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 入栈</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> item</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (elementCount + <span class="number">1</span> - elementData.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            grow(elementCount + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        elementData[elementCount++] = item;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 出栈</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        E item;</div><div class="line">        item = peek();</div><div class="line">        removeElementAt(elementCount - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> elementCount == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 取出数组最右边元素</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = elementCount;</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (E) elementData[len - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除数组最右边元素</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> index</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</div><div class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</div><div class="line">        &#125;</div><div class="line">        elementCount--;</div><div class="line">        elementData[elementCount] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数组长度不够时，为数组扩大空间</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> minCapacity</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newCapacity &gt; MAX_ARRAY_SIZE) &#123;</div><div class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">            &#125;</div><div class="line">            newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</div><div class="line">        &#125;</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JDK源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">        addElement(item);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        E       obj;</div><div class="line">        <span class="keyword">int</span>     len = size();</div><div class="line"></div><div class="line">        obj = peek();</div><div class="line">        removeElementAt(len - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>     len = size();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> size() - i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>细节满满，想要看更多实现就需要去看<code>Vector</code>的源码了。<code>Vector</code>日常使用的太少了，是线程安全的，但实现同步需要很高的花费，因此访问比<code>ArrayList</code>慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://zhangslob.github.io/2020/01/03/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://zhangslob.github.io/2020/01/03/替换空格/</id>
    <published>2020-01-03T03:03:47.228Z</published>
    <updated>2020-01-03T06:56:40.551Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十一篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成 <code>%20</code>。例如，当字符串为 <code>We Are Happy</code>，则经过替换之后的字符串为 <code>We%20Are%20Happy</code>。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>其实看到这道题，我最开始想到的就是字符串的replace方法，这显然不是面试官想要的答案，我就去看了下实现源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</div><div class="line">            <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>原来是用正则去匹配再替换的，再去看看正则替换的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span> </span>&#123;</div><div class="line">    reset();</div><div class="line">    <span class="keyword">boolean</span> result = find();</div><div class="line">    <span class="keyword">if</span> (result) &#123;</div><div class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            appendReplacement(sb, replacement);</div><div class="line">            result = find();</div><div class="line">        &#125; <span class="keyword">while</span> (result);</div><div class="line">        appendTail(sb);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> text.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>发现用的是<code>StringBuffer</code>，保证线程安全。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>好了，下面步入正题，创建 <code>StringBuilder</code>，遍历原字符串，遇到非空格，直接 append 到 <code>StringBuilder</code> 中，遇到空格则将 <code>%20</code> append 到 <code>StringBuilder</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str == None || str.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> len = str.length();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</div><div class="line">            <span class="keyword">char</span> ch = str.charAt(i);</div><div class="line">            sb.append(ch == <span class="string">' '</span> ? <span class="string">"%20"</span> : ch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"We Are Happy"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().replaceSpace(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="解法三（推荐）"><a href="#解法三（推荐）" class="headerlink" title="解法三（推荐）"></a>解法三（推荐）</h2><p>先遍历原字符串，遇到空格，则在原字符串末尾 <code>append</code> 任意两个字符，如两个空格。</p><p>用指针 <code>p</code> 指向原字符串末尾，<code>q</code> 指向现字符串末尾，<code>p</code>, <code>q</code> 从后往前遍历，当 <code>p</code> 遇到空格，<code>q</code> 位置依次要 <code>append</code> ‘02%’，若不是空格，直接 <code>append</code> <code>p</code> 指向的字符。</p><blockquote><p>🤔思路扩展<br>在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">        <span class="keyword">int</span> len = stringBuilder.length();</div><div class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(stringBuilder);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (strBuilder.charAt(i) == <span class="string">' '</span>) &#123;</div><div class="line">                strBuilder.append(<span class="string">"  "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> p = len - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> q = strBuilder.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">char</span> ch = stringBuilder.charAt(p--);</div><div class="line">            <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'0'</span>);</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'2'</span>);</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'%'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                strBuilder.setCharAt(q--, ch);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strBuilder.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"We Are Happy"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().replaceSpace(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace_space</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(s, str) <span class="keyword">or</span> len(s) &lt;= <span class="number">0</span> <span class="keyword">or</span> s <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">        space_num = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</div><div class="line">                space_num += <span class="number">1</span></div><div class="line"></div><div class="line">        new_str_len = len(s) + space_num * <span class="number">2</span></div><div class="line">        new_str = new_str_len * [<span class="keyword">None</span>]</div><div class="line">        index_of_origin, index_of_new = len(s) - <span class="number">1</span>, new_str_len - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> index_of_new &gt;= <span class="number">0</span> <span class="keyword">and</span> index_of_origin &lt;= index_of_new:</div><div class="line">            <span class="keyword">if</span> s[index_of_origin] == <span class="string">' '</span>:</div><div class="line">                new_str[index_of_new - <span class="number">2</span>: index_of_new + <span class="number">1</span>] = [<span class="string">'%'</span>, <span class="string">'2'</span>, <span class="string">'0'</span>]</div><div class="line">                index_of_new -= <span class="number">3</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                new_str[index_of_new] = s[index_of_origin]</div><div class="line">                index_of_new -= <span class="number">1</span></div><div class="line">            index_of_origin -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_str)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().replace_space(<span class="string">'We Are Happy'</span>)</div><div class="line">    print(s)</div></pre></td></tr></table></figure><blockquote><p>看着都头大</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十一篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>MapReduce例子</title>
    <link href="https://zhangslob.github.io/2019/12/30/MapReduce%E4%BE%8B%E5%AD%90/"/>
    <id>https://zhangslob.github.io/2019/12/30/MapReduce例子/</id>
    <published>2019-12-30T12:13:16.755Z</published>
    <updated>2019-12-30T12:57:07.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/gHMms0X.jpg" alt=""></p><pre><code>这是崔斯特的第一百一十篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><p>最近在学习《Hive编程指南》，尝试动手了第一个MapReduce案例，记录下。</p><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.StringTokenizer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/29.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorldCount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable ONE = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</div><div class="line">        <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">            String line = value.toString();</div><div class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(line);</div><div class="line">            <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</div><div class="line">                word.set(tokenizer.nextToken());</div><div class="line">                context.write(value, ONE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (IntWritable val : values) &#123;</div><div class="line">                sum += val.get();</div><div class="line">            &#125;</div><div class="line">            context.write(key, <span class="keyword">new</span> IntWritable(sum));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">        Job job = <span class="keyword">new</span> Job(conf, <span class="string">"world count"</span>);</div><div class="line">        job.setOutputKeyClass(Text.class);</div><div class="line">        job.setOutputValueClass(IntWritable.class);</div><div class="line"></div><div class="line">        job.setMapperClass(Map.class);</div><div class="line">        job.setReducerClass(Reduce.class);</div><div class="line"></div><div class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</div><div class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</div><div class="line"></div><div class="line">        job.waitForCompletion(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分别继承<code>Mapper</code>和<code>Reducer</code>这两个方法，重写自己的处理逻辑，最后设置map和reduce。</p><h1 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h1><p>同样的功能用HQL来写会简单很多：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> docs (line <span class="keyword">STRING</span>);</div><div class="line"></div><div class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">'docs'</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> docs;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> world_counts <span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> world, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">count</span></div><div class="line"><span class="keyword">FROM</span> (</div><div class="line">    <span class="keyword">SELECT</span> explode(<span class="keyword">split</span>(line, <span class="string">'\s'</span>)) <span class="keyword">AS</span> word</div><div class="line">    <span class="keyword">FROM</span> docs</div><div class="line">) w</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> word</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> word;</div></pre></td></tr></table></figure><p>so simple</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gHMms0X.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://zhangslob.github.io/2019/12/29/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://zhangslob.github.io/2019/12/29/二维数组中的查找/</id>
    <published>2019-12-29T06:32:25.513Z</published>
    <updated>2019-12-29T07:31:45.586Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零九篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>例如下面的二维数组，如果查找7，返回true，查找5，返回false。</p><table><thead><tr><th>1</th><th>2</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>9</td><td>12</td></tr><tr><td>4</td><td>7</td><td>10</td><td>13</td></tr><tr><td>6</td><td>8</td><td>11</td><td>15</td></tr></tbody></table><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找目标数字b，从数组中选一个数字a，如果<code>a=b</code>，结束查找；如果<code>a&gt;b</code>，那么接下来查找的范围就是a的左边或上边；如果<code>a&lt;b</code>，那么接下来搜索范围就是右边或下边。</p><p>当我们需要解决一个复杂的问题时，一个很有效的方法就是从一个具体的问题入手。本题可以从查找数字7入手，一步步分析过程。如果我们在二维数组中间随机选一个数字，那么下次搜索范围就是两个区域，而且有重叠。如果从数组的某一个角上开始搜索，就不会遇到这个问题。</p><p>比如从数组右上方开始，</p><ol><li>a=9，b=7，<code>a&gt;b</code>，接着查找左边和上边，由于没有上边，所以只能查找左边，也就是1、2、8这三列</li><li>a=8，<code>a&gt;b</code>，接着查找左边和上边，因为没有上边，只能接着找左边，也就是1，2这两列</li><li>a=2，<code>a&lt;b</code>，接着就是右边和下边，右边已经查找过，所以接下来就是一直往下查找，也就是1、2这两列的下方</li><li>a=4，<code>a&lt;b</code>，接着查找1、2这两列的下面两行</li><li>a=7，<code>a=b</code>，结束查找。</li></ol><p><img src="https://i.imgur.com/2rt2LSr.png" alt=""></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>从二维数组的右上方开始查找：</p><ul><li>若元素值等于 <code>target</code>，返回 <code>true</code>；</li><li>若元素值大于 <code>target</code>，砍掉这一列，即 <code>--j</code>；</li><li>若元素值小于 <code>target</code>，砍掉这一行，即 <code>++i</code>。</li></ul><p>也可以从二维数组的左下方开始查找，以下代码使用左下方作为查找的起点。</p><p>注意，不能选择左上方或者右下方的数字，因为这样无法缩小查找的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows = array.length;</div><div class="line">        <span class="keyword">int</span> columns = array[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> i = rows - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; columns) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i][j] == target) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (array[i][j] &lt; target) &#123;</div><div class="line">                ++j;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                --i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</div><div class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</div><div class="line">                &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</div><div class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">boolean</span> res = <span class="keyword">new</span> Solution().find(<span class="number">7</span>, arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如果是我自己去写这道题的话，肯定想不出这样的方法，可能就是遍历所有数字，这肯定不是面试官要问的。看了书中介绍的方法，分析过程确实很重要，一步步去寻找规律。我想起了高中数学的<code>数列</code>，老师常说“数列就是列数，如果不知道规律，就多写几个例子”。对于现在的这种算法题，一定要多试几个例子，从中找到规律。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零九篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>找出数组中重复的数字</title>
    <link href="https://zhangslob.github.io/2019/12/26/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://zhangslob.github.io/2019/12/26/找出数组中重复的数字/</id>
    <published>2019-12-26T08:44:27.000Z</published>
    <updated>2019-12-27T03:13:32.809Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零八篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 <code>7</code> 的数组 <code>{2, 3, 1, 0, 2, 5, 3}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>排序后，顺序扫描，判断是否有重复，时间复杂度为 <code>O(n²)</code>。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>利用哈希表，遍历数组，如果哈希表中没有该元素，则存入哈希表中，否则返回重复的元素。时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>。</p><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>长度为 <code>n</code>，元素的数值范围也为 <code>n</code>，如果没有重复元素，那么数组每个下标对应的值与下标相等。</p><p>从头到尾遍历数组，当扫描到下标 <code>i</code> 的数字 <code>nums[i]</code>：</p><ul><li>如果等于 <code>i</code>，继续向下扫描；</li><li>如果不等于 <code>i</code>，拿它与第 <code>nums[i]</code> 个数进行比较，如果相等，说明有重复值，返回 <code>nums[i]</code>。如果不相等，就把第 <code>i</code> 个数 和第 <code>nums[i]</code> 个数交换。重复这个比较交换的过程。</li></ul><p>此算法时间复杂度为 <code>O(n)</code>，因为每个元素最多只要两次交换，就能确定位置。空间复杂度为 <code>O(1)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (array[i] != i) &#123;</div><div class="line">                <span class="keyword">if</span> (array[i] == array[array[i]]) &#123;</div><div class="line">                    <span class="keyword">return</span> array[i];</div><div class="line">                &#125;</div><div class="line">                swap(array, i, array[i]);</div><div class="line">                System.out.println(Arrays.toString(array));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中有一个两重循环，但每个数字最多只要交换两次就可以找到属于自己的位置，因此时间复杂度是O(n)。不需要额外分配内存，空间复杂度是O(1)。</p><p>Output<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1, 3, 2, 0, 2, 5, 3]</div><div class="line">[3, 1, 2, 0, 2, 5, 3]</div><div class="line">[0, 1, 2, 3, 2, 5, 3]</div><div class="line">2</div></pre></td></tr></table></figure></p><p>以数组[2, 3, 1, 0, 2, 5, 3]为例来分析找到重复数字的步骤：</p><ol><li>数组的第 0 个数字（从 0 开始计数，和数组的下标保持一致）是 2，与它的下标不相等，于是把它和下标为 2 的数字 1 交换。交换之后的数组是[1, 3, 2, 0, 2, 5, 3]。</li><li>此时第 0 个数字是 1，仍然与它的下标不相等，继续把它和下标为 1 的数字 3 交换，得到数组[3, 1, 2, 0, 2, 5, 3]</li><li>接下来继续交换第 0 个数字 3 和第 3 个数字 0，得到数组[0, 1, 2, 3, 2, 5, 3]。</li><li>此时第 0 个数字的数值为 0，接着扫描下一个数字。在接下来的几个数字中，下标为 1，2，3 的三个数字分别为 1，2，3 它们的下标和数值都分别相等，因此不需要做任何操作。</li><li>接下来扫描到下标为 4 的数字 2。由于它的数值与它的下标不相等，再比较它和下标为 2 的数字。注意到此时数组中下标为 2 的数字也是 2，也就是数字在下标为 2 和下标为 4 的两个位置都出现了，因此找到一个重复的数字。</li></ol><p>本题关键是：<strong>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内并且有重复</strong>，这说明数组是可以排序的，把每个数字交换到自己应该在的位置，排序时就能找到重复字段。理想状态下的情况：[0, 1, 2, 3, 4, x, x, x]</p><p>Python解法更简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</div><div class="line">        <span class="keyword">while</span> arr[i] != i:</div><div class="line">            tmp = arr[i]</div><div class="line">            <span class="keyword">if</span> tmp == arr[tmp]:</div><div class="line">                <span class="keyword">return</span> tmp</div><div class="line">            arr[i], arr[tmp] = arr[tmp], arr[i]</div><div class="line">            print(arr)</div><div class="line"></div><div class="line"></div><div class="line">print(solution([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]))</div></pre></td></tr></table></figure><h1 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n+1</code> 的数组里的所有数字都在 <code>1</code> 到 <code>n</code> 的范围内，数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 <code>8</code> 的数组 <code>{2, 3, 5, 4, 3, 2, 6, 7}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h3><p>创建长度为 <code>n+1</code> 的辅助数组，把原数组的元素复制到辅助数组中。如果原数组被复制的数是 <code>m</code>，则放到辅助数组第 <code>m</code> 个位置。这样很容易找出重复元素。空间复杂度为 <code>O(n)</code>。</p><h3 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h3><p>数组元素的取值范围是 <code>[1, n]</code>，对该范围对半划分，分成 <code>[1, middle]</code>, <code>[middle+1, n]</code>。计算数组中有多少个(count)元素落在 <code>[1, middle]</code> 区间内，如果 <code>count</code> 大于 <code>middle</code>，那么说明这个范围内有重复元素，否则在另一个范围内。继续对这个范围对半划分，继续统计区间内元素数量。</p><p>时间复杂度 O(n * log n)，空间复杂度 O(1)。</p><p>注意，此方法无法找出所有重复的元素。如果左右半区同时存在重复值，先算哪个半区就会先得到哪边的重复值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</div><div class="line">            <span class="keyword">int</span> middle = start + ((end - start) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> count = countRange(array, start, middle);</div><div class="line">            <span class="keyword">if</span> (end == start) &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> start;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; (middle - start) + <span class="number">1</span>) &#123;</div><div class="line">                    end = middle;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= start &amp;&amp; i &lt;= end) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>按照二分法查找的思路，如果输出长度为<code>n</code>的数组，那么函数<code>countRange</code>将被调用<code>O(log n)</code>次，每次需要<code>O(n)</code>时间，因此总的时间复杂度是<code>O(nlog n)</code> ，空间复杂度是<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零八篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>大数据学习路线</title>
    <link href="https://zhangslob.github.io/2019/12/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://zhangslob.github.io/2019/12/06/大数据学习路线/</id>
    <published>2019-12-06T02:34:57.481Z</published>
    <updated>2019-12-06T02:40:07.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><pre><code>这是崔斯特的第一百零七篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="大数据处理流程"><a href="#大数据处理流程" class="headerlink" title="大数据处理流程"></a>大数据处理流程</h1><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><p>上图是一个简化的大数据处理流程图，大数据处理的主要流程包括数据收集、数据存储、数据处理、数据应用等主要环节。下面我们逐一对各个环节所需要的技术栈进行讲解：</p><h2 id="1-1-数据收集"><a href="#1-1-数据收集" class="headerlink" title="1.1 数据收集"></a>1.1 数据收集</h2><p>大数据处理的第一步是数据的收集。现在的中大型项目通常采用微服务架构进行分布式部署，所以数据的采集需要在多台服务器上进行，且采集过程不能影响正常业务的开展。基于这种需求，就衍生了多种日志收集工具，如 Flume 、Logstash、Kibana 等，它们都能通过简单的配置完成复杂的数据收集和数据聚合。</p><h2 id="1-2-数据存储"><a href="#1-2-数据存储" class="headerlink" title="1.2 数据存储"></a>1.2 数据存储</h2><p>收集到数据后，下一个问题就是：数据该如何进行存储？通常大家最为熟知是 MySQL、Oracle 等传统的关系型数据库，它们的优点是能够快速存储结构化的数据，并支持随机访问。但大数据的数据结构通常是半结构化（如日志数据）、甚至是非结构化的（如视频、音频数据），为了解决海量半结构化和非结构化数据的存储，衍生了 Hadoop HDFS 、KFS、GFS 等分布式文件系统，它们都能够支持结构化、半结构和非结构化数据的存储，并可以通过增加机器进行横向扩展。</p><p>分布式文件系统完美地解决了海量数据存储的问题，但是一个优秀的数据存储系统需要同时考虑数据存储和访问两方面的问题，比如你希望能够对数据进行随机访问，这是传统的关系型数据库所擅长的，但却不是分布式文件系统所擅长的，那么有没有一种存储方案能够同时兼具分布式文件系统和关系型数据库的优点，基于这种需求，就产生了 HBase、MongoDB。</p><h2 id="1-3-数据分析"><a href="#1-3-数据分析" class="headerlink" title="1.3 数据分析"></a>1.3 数据分析</h2><p>大数据处理最重要的环节就是数据分析，数据分析通常分为两种：批处理和流处理。</p><ul><li><strong>批处理</strong>：对一段时间内海量的离线数据进行统一的处理，对应的处理框架有 Hadoop MapReduce、Spark、Flink 等；</li><li><strong>流处理</strong>：对运动中的数据进行处理，即在接收数据的同时就对其进行处理，对应的处理框架有 Storm、Spark Streaming、Flink Streaming 等。</li></ul><p>批处理和流处理各有其适用的场景，时间不敏感或者硬件资源有限，可以采用批处理；时间敏感和及时性要求高就可以采用流处理。随着服务器硬件的价格越来越低和大家对及时性的要求越来越高，流处理越来越普遍，如股票价格预测和电商运营数据分析等。</p><p>上面的框架都是需要通过编程来进行数据分析，那么如果你不是一个后台工程师，是不是就不能进行数据的分析了？当然不是，大数据是一个非常完善的生态圈，有需求就有解决方案。为了能够让熟悉 SQL 的人员也能够进行数据的分析，查询分析框架应运而生，常用的有 Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix 等。这些框架都能够使用标准的 SQL 或者 类 SQL 语法灵活地进行数据的查询分析。这些 SQL 经过解析优化后转换为对应的作业程序来运行，如 Hive 本质上就是将 SQL 转换为 MapReduce 作业，Spark SQL 将 SQL 转换为一系列的 RDDs 和转换关系（transformations），Phoenix 将 SQL 查询转换为一个或多个 HBase Scan。</p><h2 id="1-4-数据应用"><a href="#1-4-数据应用" class="headerlink" title="1.4 数据应用"></a>1.4 数据应用</h2><p>数据分析完成后，接下来就是数据应用的范畴，这取决于你实际的业务需求。比如你可以将数据进行可视化展现，或者将数据用于优化你的推荐算法，这种运用现在很普遍，比如短视频个性化推荐、电商商品推荐、头条新闻推荐等。当然你也可以将数据用于训练你的机器学习模型，这些都属于其他领域的范畴，都有着对应的框架和技术栈进行处理，这里就不一一赘述。</p><h2 id="1-5-其他框架"><a href="#1-5-其他框架" class="headerlink" title="1.5 其他框架"></a>1.5 其他框架</h2><p>上面是一个标准的大数据处理流程所用到的技术框架。但是实际的大数据处理流程比上面复杂很多，针对大数据处理中的各种复杂问题分别衍生了各类框架：</p><ul><li>单机的处理能力都是存在瓶颈的，所以大数据框架都是采用集群模式进行部署，为了更方便的进行集群的部署、监控和管理，衍生了 Ambari、Cloudera Manager 等集群管理工具；</li><li>想要保证集群高可用，需要用到 ZooKeeper ，ZooKeeper 是最常用的分布式协调服务，它能够解决大多数集群问题，包括首领选举、失败恢复、元数据存储及其一致性保证。同时针对集群资源管理的需求，又衍生了 Hadoop YARN ;</li><li>复杂大数据处理的另外一个显著的问题是，如何调度多个复杂的并且彼此之间存在依赖关系的作业？基于这种需求，产生了 Azkaban 和 Oozie 等工作流调度框架；</li><li>大数据流处理中使用的比较多的另外一个框架是 Kafka，它可以用于消峰，避免在秒杀等场景下并发数据对流处理程序造成冲击；</li><li>另一个常用的框架是 Sqoop ，主要是解决了数据迁移的问题，它能够通过简单的命令将关系型数据库中的数据导入到 HDFS 、Hive 或 HBase 中，或者从 HDFS 、Hive 导出到关系型数据库上。</li></ul><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>介绍完大数据框架，接着就可以介绍其对应的学习路线了，主要分为以下几个方面：</p><h2 id="2-1-语言基础"><a href="#2-1-语言基础" class="headerlink" title="2.1 语言基础"></a>2.1 语言基础</h2><h3 id="1-Java"><a href="#1-Java" class="headerlink" title="1.  Java"></a>1.  Java</h3><p>大数据框架大多采用 Java 语言进行开发，并且几乎全部的框架都会提供 Java API 。Java 是目前比较主流的后台开发语言，所以网上免费的学习资源也比较多。如果你习惯通过书本进行学习，这里推荐以下入门书籍：</p><ul><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="external">《Java 编程的逻辑》</a>：这里一本国人编写的系统入门 Java 的书籍，深入浅出，内容全面；</li><li>《Java 核心技术》：目前最新的是第 10 版，有<a href="https://book.douban.com/subject/26880667/" target="_blank" rel="external">卷一</a> 和<a href="https://book.douban.com/subject/27165931/" target="_blank" rel="external">卷二</a> 两册，卷二可以选择性阅读，因为其中很多章节的内容在实际开发中很少用到。</li></ul><p>目前大多数框架要求 Java 版本至少是 1.8，这是由于 Java 1.8 提供了函数式编程，使得可以用更精简的代码来实现之前同样的功能，比如你调用 Spark API，使用 1.8 可能比 1.7 少数倍的代码，所以这里额外推荐阅读 <a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8 实战》</a> 这本书籍。</p><h3 id="2-Scala"><a href="#2-Scala" class="headerlink" title="2. Scala"></a>2. Scala</h3><p>Scala 是一门综合了面向对象和函数式编程概念的静态类型的编程语言，它运行在 Java 虚拟机上，可以与所有的 Java 类库无缝协作，著名的 Kafka 就是采用 Scala 语言进行开发的。</p><p>为什么需要学习 Scala 语言 ？ 这是因为当前最火的计算框架 Flink 和 Spark 都提供了 Scala 语言的接口，使用它进行开发，比使用 Java 8 所需要的代码更少，且 Spark 就是使用 Scala 语言进行编写的，学习 Scala 可以帮助你更深入的理解 Spark。同样的，对于习惯书本学习的小伙伴，这里推荐两本入门书籍：</p><ul><li><a href="https://book.douban.com/subject/27093751/" target="_blank" rel="external">《快学 Scala(第 2 版)》</a> </li><li><a href="https://book.douban.com/subject/27591387/" target="_blank" rel="external">《Scala 编程 (第 3 版)》</a> </li></ul><blockquote><p>这里说明一下，如果你的时间有限，不一定要学完 Scala 才去学习大数据框架。Scala 确实足够的精简和灵活，但其在语言复杂度上略大于 Java，例如隐式转换和隐式参数等概念在初次涉及时会比较难以理解，所以你可以在了解 Spark 后再去学习 Scala，因为类似隐式转换等概念在 Spark 源码中有大量的运用。</p></blockquote><h2 id="2-2-Linux-基础"><a href="#2-2-Linux-基础" class="headerlink" title="2.2 Linux 基础"></a>2.2 Linux 基础</h2><p>通常大数据框架都部署在 Linux 服务器上，所以需要具备一定的 Linux 知识。Linux 书籍当中比较著名的是 《鸟哥私房菜》系列，这个系列很全面也很经典。但如果你希望能够快速地入门，这里推荐<a href="https://www.linuxprobe.com/" target="_blank" rel="external">《Linux 就该这么学》</a>，其网站上有免费的电子书版本。</p><h2 id="2-3-构建工具"><a href="#2-3-构建工具" class="headerlink" title="2.3  构建工具"></a>2.3  构建工具</h2><p>这里需要掌握的自动化构建工具主要是 Maven。Maven 在大数据场景中使用比较普遍，主要在以下三个方面：</p><ul><li>管理项目 JAR 包，帮助你快速构建大数据应用程序；</li><li>不论你的项目是使用 Java 语言还是 Scala 语言进行开发，提交到集群环境运行时，都需要使用 Maven 进行编译打包；</li><li>大部分大数据框架使用 Maven 进行源码管理，当你需要从其源码编译出安装包时，就需要使用到 Maven。</li></ul><h2 id="2-4-框架学习"><a href="#2-4-框架学习" class="headerlink" title="2.4 框架学习"></a>2.4 框架学习</h2><h3 id="1-框架分类"><a href="#1-框架分类" class="headerlink" title="1. 框架分类"></a>1. 框架分类</h3><p>上面我们介绍了很多大数据框架，这里进行一下分类总结：</p><p><strong>日志收集框架</strong>：Flume 、Logstash、Kibana</p><p><strong>分布式文件存储系统</strong>：Hadoop HDFS</p><p><strong>数据库系统</strong>：Mongodb、HBase</p><p><strong>分布式计算框架</strong>：</p><ul><li>批处理框架：Hadoop MapReduce</li><li>流处理框架：Storm</li><li>混合处理框架：Spark、Flink</li></ul><p><strong>查询分析框架</strong>：Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix </p><p><strong>集群资源管理器</strong>：Hadoop YARN</p><p><strong>分布式协调服务</strong>：Zookeeper</p><p><strong>数据迁移工具</strong>：Sqoop</p><p><strong>任务调度框架</strong>：Azkaban、Oozie</p><p><strong>集群部署和监控</strong>：Ambari、Cloudera Manager</p><p>上面列出的都是比较主流的大数据框架，社区都很活跃，学习资源也比较丰富。建议从 Hadoop 开始入门学习，因为它是整个大数据生态圈的基石，其它框架都直接或者间接依赖于 Hadoop 。接着就可以学习计算框架，Spark 和 Flink 都是比较主流的混合处理框架，Spark 出现得较早，所以其应用也比较广泛。 Flink 是当下最火热的新一代的混合处理框架，其凭借众多优异的特性得到了众多公司的青睐。两者可以按照你个人喜好或者实际工作需要进行学习。</p><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/HADOOP-ECOSYSTEM-Edureka.png" alt=""></p><blockquote><p><em>图片引用自</em> ：<em><a href="https://www.edureka.co/blog/hadoop-ecosystem" target="_blank" rel="external">https://www.edureka.co/blog/hadoop-ecosystem</a></em></p></blockquote><p>至于其它框架，在学习上并没有特定的先后顺序，如果你的学习时间有限，建议初次学习时候，同一类型的框架掌握一种即可，比如日志收集框架就有很多种，初次学习时候只需要掌握一种，能够完成日志收集的任务即可，之后工作上有需要可以再进行针对性地学习。</p><h3 id="2-学习资料"><a href="#2-学习资料" class="headerlink" title="2.  学习资料"></a>2.  学习资料</h3><p>大数据最权威和最全面的学习资料就是官方文档。热门的大数据框架社区都比较活跃、版本更新迭代也比较快，所以其出版物都明显滞后于其实际版本，基于这个原因采用书本学习不是一个最好的方案。比较庆幸的是，大数据框架的官方文档都写的比较好，内容完善，重点突出，同时都采用了大量配图进行辅助讲解。当然也有一些优秀的书籍历经时间的检验，至今依然很经典，这里列出部分个人阅读过的经典书籍：</p><ul><li><a href="https://book.douban.com/subject/27115351/" target="_blank" rel="external">《hadoop 权威指南 (第四版)》</a> 2017 年</li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="external">《Kafka 权威指南》</a> 2017 年</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="external">《从 Paxos 到 Zookeeper  分布式一致性原理与实践》</a>  2015 年</li><li><a href="https://book.douban.com/subject/26649141/" target="_blank" rel="external">《Spark 技术内幕  深入解析 Spark 内核架构设计与实现原理》</a> 2015 年</li><li><a href="https://book.douban.com/subject/27035127/" target="_blank" rel="external">《Spark.The.Definitive.Guide》</a> 2018 年</li><li><a href="https://book.douban.com/subject/10748460/" target="_blank" rel="external">《HBase 权威指南》</a> 2012 年</li><li><a href="https://book.douban.com/subject/25791255/" target="_blank" rel="external">《Hive 编程指南》</a> 2013 年</li></ul><h3 id="3-视频学习资料"><a href="#3-视频学习资料" class="headerlink" title="3. 视频学习资料"></a>3. 视频学习资料</h3><p>上面我推荐的都是书籍学习资料，很少推荐视频学习资料，这里说明一下原因：因为书籍历经时间的考验，能够再版的或者豆瓣等平台评价高的证明都是被大众所认可的，从概率的角度上来说，其必然更加优秀，不容易浪费大家的学习时间和精力，所以我个人更倾向于官方文档或者书本的学习方式，而不是视频。因为视频学习资料，缺少一个公共的评价平台和完善的评价机制，所以其质量良莠不齐。但是视频任然有其不可替代的好处，学习起来更直观、印象也更深刻，所以对于习惯视频学习的小伙伴，这里我各推荐一个免费的和付费的视频学习资源，大家按需选择：</p><ul><li>免费学习资源：尚硅谷大数据学习路线 ——  <a href="http://www.atguigu.com/bigdata_video.shtml#bigdata" target="_blank" rel="external">下载链接</a> \ <a href="https://space.bilibili.com/302417610/" target="_blank" rel="external">在线观看链接</a></li><li>付费学习资源：<a href="https://www.imooc.com/t/2781843" target="_blank" rel="external">慕课网 Michael PK 的系列课程</a></li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>这里推荐一些大数据常用的开发工具：</p><p><strong>Java IDE</strong>：IDEA  和 Eclipse 都可以。从个人使用习惯而言，更倾向于 IDEA ;</p><p><strong>VirtualBox</strong>：在学习过程中，你可能经常要在虚拟机上搭建服务和集群。VirtualBox 是一款开源、免费的虚拟机管理软件，虽然是轻量级软件，但功能很丰富，基本能够满足日常的使用需求；</p><p><strong>MobaXterm</strong>：大数据的框架通常都部署在服务器上，这里推荐使用 MobaXterm 进行连接。同样是免费开源的，支持多种连接协议，支持拖拽上传文件，支持使用插件扩展；</p><p><strong>Translate Man</strong>：一款浏览器上免费的翻译插件 (谷歌和火狐均支持)。它采用谷歌的翻译接口，准确性非常高，支持划词翻译，可以辅助进行官方文档的阅读。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是个人关于大数据的学习心得和路线推荐。本片文章对大数据技术栈做了比较狭义的限定，随着学习的深入，大家也可以把 Python 语言、推荐系统、机器学习等逐步加入到自己的大数据技术栈中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零七篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-394-字符串解码</title>
    <link href="https://zhangslob.github.io/2019/11/28/Leetcode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://zhangslob.github.io/2019/11/28/Leetcode-394-字符串解码/</id>
    <published>2019-11-28T03:46:18.174Z</published>
    <updated>2019-11-28T07:57:01.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><pre><code>这是崔斯特的第一百零六篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</div><div class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</div><div class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</div></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">输入:<span class="string">'3[a2[c]]'</span></div><div class="line">初始化栈: 栈nums 存要重复的次数k,栈str 存字符串</div><div class="line"></div><div class="line">遍历字符串:</div><div class="line">指针指向字符<span class="string">'3'</span>,为数字</div><div class="line">num暂存数字3</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'['</span></div><div class="line">循环次数num入栈nums，空字符串res入栈str</div><div class="line">nums: 3        res: <span class="string">''</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'a'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'a'</span>,res=<span class="string">'a'</span></div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'2'</span>,为数字</div><div class="line">num暂存数字2</div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">'['</span></div><div class="line">num入栈nums,res入栈str</div><div class="line">nums: 3 -&gt; 2    str: <span class="string">''</span> -&gt; <span class="string">'a'</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'c'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'c'</span>,res=<span class="string">'c'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数2</div><div class="line">res = res*2 = <span class="string">'cc'</span></div><div class="line">str弹出栈顶元素<span class="string">'a'</span>与res拼接并入栈:</div><div class="line">res = <span class="string">'a'</span>+<span class="string">'cc'</span>=<span class="string">'acc'</span></div><div class="line">str: <span class="string">''</span> -&gt; <span class="string">'acc'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数3</div><div class="line">res = res*3 = <span class="string">'accaccacc'</span></div><div class="line">str弹出栈顶元素空字符串<span class="string">''</span>与res拼接并入栈:</div><div class="line">res=<span class="string">''</span>+<span class="string">'accaccacc'</span>=<span class="string">'accaccacc'</span></div><div class="line">str: <span class="string">'accaccacc'</span></div><div class="line"></div><div class="line">结束返回res</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>由于重复次数可能大于10，所以暂存数字时要适当处理，如 <code>num*10+当前数字</code></li><li>在c++里可以直接修改拼接字符，但Java不支持运算符重载，可以借助 StringBuilder 或 StringBuffer 类。</li><li>用栈暂存的逻辑与递归基本一致，可以理解为用递归实现栈。</li><li>python没有栈这种数据结构，可以用 list() 数组或双端队列 deque()</li><li>python可以只用一个栈以元组的形式重复次数和字符串，如<code>(num,res)</code></li></ul><h2 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;StringBuilder&gt; str = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</div><div class="line">                str.push(res);</div><div class="line">                nums.push(num);</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">                res = <span class="keyword">new</span> StringBuilder();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</div><div class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.pop(); i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">                    stringBuilder.append(res);</div><div class="line">                &#125;</div><div class="line">                res = str.pop().append(stringBuilder);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (c - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.append(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        stack, res, num = [], <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i.isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(i)</div><div class="line">            <span class="keyword">elif</span> i.isalpha():</div><div class="line">                res += i</div><div class="line">            <span class="keyword">elif</span> i == <span class="string">'['</span>:</div><div class="line">                stack.append((res, num))</div><div class="line">                res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                last_str, this_num = stack.pop()</div><div class="line">                res = last_str + this_num * res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line">c = Solution().decodeString(<span class="string">'3[a2[c]]'</span>)  <span class="comment"># aaabcbc</span></div><div class="line">print(c)</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>发现一种解法：倒序遍历字符串<code>s</code>，如果不是<code>[</code>则直接入栈；遇到<code>[</code>时，先找出<code>[</code>前边的数字<code>nums</code>表示为<code>k</code>，然后找出编码字符串<code>encodedStr</code>，重复<code>k</code>次入栈，跳过数字继续遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"strconv"</span></div><div class="line">   <span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">   stack := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">   <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; &#123;</div><div class="line">      <span class="keyword">if</span> s[i] == <span class="string">'['</span> &#123;</div><div class="line">         nums := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</div><div class="line">            <span class="keyword">if</span> s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span> &#123;</div><div class="line">               nums = <span class="built_in">append</span>(nums, <span class="keyword">string</span>(s[j]))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">         reverse(nums)</div><div class="line">         k, _ := strconv.Atoi(strings.Join(nums, <span class="string">""</span>))</div><div class="line">         encodedStr := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="string">"]"</span> &#123;</div><div class="line">            encodedStr = <span class="built_in">append</span>(encodedStr, stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</div><div class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         &#125;</div><div class="line">         stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         reverse(encodedStr)</div><div class="line">         <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; j++ &#123;</div><div class="line">            stack = <span class="built_in">append</span>(stack, encodedStr...)</div><div class="line">         &#125;</div><div class="line">         i -= <span class="built_in">len</span>(nums)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         stack = <span class="built_in">append</span>(stack, <span class="keyword">string</span>(s[i]))</div><div class="line">      &#125;</div><div class="line">      i -= <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   reverse(stack)</div><div class="line">   <span class="keyword">return</span> strings.Join(stack, <span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(arr []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">   length := <span class="built_in">len</span>(arr)</div><div class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length/<span class="number">2</span>; i++ &#123;</div><div class="line">      arr[i], arr[length-i<span class="number">-1</span>] = arr[length-i<span class="number">-1</span>], arr[i]</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   s := <span class="string">"3[a]2[bc]"</span></div><div class="line">   r := decodeString(s)</div><div class="line">   fmt.Println(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ZdIwN57.png" alt=""></p><p>惊了惊了，这么牛逼</p><h1 id="利用递归"><a href="#利用递归" class="headerlink" title="利用递归"></a>利用递归</h1><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><p>将 s.length() 的值以参数传递，减少重复调用 length() 造成的时间损耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(s.toCharArray(), s.length()).toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">'0'</span> &amp;&amp; chars[i] &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">'['</span>) &#123;</div><div class="line">                StringBuilder tmp = dfs(chars, len);</div><div class="line">                <span class="keyword">while</span> (--num &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    str.append(tmp);</div><div class="line">                &#125;</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">']'</span>) &#123;</div><div class="line">                <span class="keyword">return</span> str;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                str.append(chars[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    i = <span class="number">-1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> self.i &lt; len(s) - <span class="number">1</span>:</div><div class="line">            self.i += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> s[self.i].isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(s[self.i])</div><div class="line">            <span class="keyword">elif</span> s[self.i].isalpha():</div><div class="line">                res += s[self.i]</div><div class="line">            <span class="keyword">elif</span> s[self.i] == <span class="string">'['</span>:</div><div class="line">                res += self.decodeString(s) * num</div><div class="line">                num = <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a]2[bc]'</span>) == <span class="string">'aaabcbc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a2[c]]'</span>) == <span class="string">'accaccacc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'2[abc]3[cd]ef'</span>) == <span class="string">'abcabccdcdcdef'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零六篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>抓包：淘宝、支付宝</title>
    <link href="https://zhangslob.github.io/2019/11/27/%E6%8A%93%E5%8C%85%EF%BC%9A%E6%B7%98%E5%AE%9D%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    <id>https://zhangslob.github.io/2019/11/27/抓包：淘宝、支付宝/</id>
    <published>2019-11-27T12:05:52.084Z</published>
    <updated>2019-11-27T12:27:44.327Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零五篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>Frida抓包技巧</code><br><a id="more"></a></p><p>对于淘宝、支付宝之类的App，想要直接抓包是不可能的，可以使用 frida 实现抓包。</p><h1 id="Frida介绍"><a href="#Frida介绍" class="headerlink" title="Frida介绍"></a>Frida介绍</h1><p>Frida是一款基于python + javascript 的hook框架，通杀android\ios\linux\win\osx等各平台，由于是基于脚本的交互，因此相比xposed和substrace cydia更加便捷。Frida的官网为：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.frida.re%2F" target="_blank" rel="external">http://www.frida.re/</a></p><p>首先要保证你的android手机已经root。通过pip安装frida:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install frida</div></pre></td></tr></table></figure><p>adb连接手机，到 <a href="https://github.com/frida/frida/releases" target="_blank" rel="external">https://github.com/frida/frida/releases</a> 下载frida-server，根据情况选择android-arm 版本，安卓手机一般是是下载<code>android-arm</code>和<code>android-arm64</code>这两种。</p><p>push到android手机上并且运行，需要取得手机root权限</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb push frida-server /data/local/tmp/</div><div class="line">adb shell</div><div class="line">su</div><div class="line"><span class="built_in">cd</span> /data/local/tmp/</div><div class="line">chmod <span class="number">777</span> frida-server</div><div class="line">./frida-server</div></pre></td></tr></table></figure><p>到此为止环境已经搭建完毕。</p><h1 id="编写抓包脚本"><a href="#编写抓包脚本" class="headerlink" title="编写抓包脚本"></a>编写抓包脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> frida</div><div class="line"></div><div class="line">rdev = frida.get_usb_device()</div><div class="line"><span class="comment"># session = rdev.attach('com.taobao.etao')</span></div><div class="line">session = rdev.attach(<span class="string">'com.taobao.taobao'</span>)</div><div class="line"><span class="comment"># session = rdev.attach('com.tmall.wireless')</span></div><div class="line"></div><div class="line">scr = <span class="string">"""</span></div><div class="line">Java.perform(function () &#123;</div><div class="line">    var SwitchConfig = Java.use('mtopsdk.mtop.global.SwitchConfig');</div><div class="line">        SwitchConfig.isGlobalSpdySwitchOpen.overload().implementation = function()&#123;</div><div class="line">            var ret = this.isGlobalSpdySwitchOpen.apply(this, arguments);</div><div class="line">            console.log("isGlobalSpdySwitchOpenl "+ret)</div><div class="line">            </div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">"""</div><div class="line"></div><div class="line">script = session.create_script(scr)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></div><div class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</div><div class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(message)</div><div class="line"></div><div class="line"></div><div class="line">script.on(<span class="string">"message"</span>, on_message)</div><div class="line">script.load()</div><div class="line">sys.stdin.read()</div></pre></td></tr></table></figure><p>运行该脚本，打开淘宝就可以抓包了。要注入的进程名已经写好了：</p><ol><li><code>com.taobao.etao</code> 是一淘</li><li><code>com.taobao.taobao</code>是淘宝</li><li><code>com.tmall.wireless</code> 是天猫</li></ol><p><img src="https://i.imgur.com/WIfQJiG.png" alt=""></p><p>想要抓淘宝App数据还有很多步要走，还有<code>x-sign</code>和<code>x-min-wua</code>等着你。(^o^)/~</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frida抓包技巧&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://zhangslob.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-581-最短无序连续子数组</title>
    <link href="https://zhangslob.github.io/2019/11/26/Leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://zhangslob.github.io/2019/11/26/Leetcode-581-最短无序连续子数组/</id>
    <published>2019-11-26T02:41:36.925Z</published>
    <updated>2019-11-26T13:07:59.036Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零四篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目详述"><a href="#题目详述" class="headerlink" title="题目详述"></a>题目详述</h1><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: [2, 6, 4, 8, 10, 9, 15]</div><div class="line">输出: 5</div><div class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</div></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><h1 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>将原数组拷贝一份，然后对拷贝后的数组进行排序。</li><li>对比原数组和排序后的数组，除去前面一部分和后面一部分相同的元素，剩余区间的长度就是结果。</li><li>时间复杂度为 O(nlogn)。</li></ul><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, nums.length);</div><div class="line">        Arrays.sort(sortedNums);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = sortedNums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] == sortedNums[i]) &#123;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] == sortedNums[j]) &#123;</div><div class="line">            --j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"sort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">   sortedNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</div><div class="line">   <span class="built_in">copy</span>(sortedNum, nums)</div><div class="line">   sort.Ints(sortedNum)</div><div class="line">   i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[i] == sortedNum[i] &#123;</div><div class="line">      i++</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[j] == sortedNum[j] &#123;</div><div class="line">      j--</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> i &gt;= j &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">   n := findUnsortedSubarray(nums)</div><div class="line">   fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        sortedarray = sorted(nums)</div><div class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] == sortedarray[i]:</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == sortedarray[j]:</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">1</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>遍历数组，同时进行从头到尾，从尾到头的遍历，分别找出无序连续子数组区间的右边和左边节点；</li><li>右边点，是从左到右不递增的点，</li><li>左边点，是从右到左不递减的点，</li><li>两点之间的距离就是所求值</li></ol><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> min = nums[n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt;= max) &#123;</div><div class="line">                max = nums[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[n - i - <span class="number">1</span>] &lt;= min) &#123;</div><div class="line">                min = nums[n - i - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = n - i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">n := <span class="built_in">len</span>(nums)</div><div class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line">start, end := n<span class="number">-1</span>, <span class="number">0</span></div><div class="line">max, min := nums[<span class="number">0</span>], nums[n<span class="number">-1</span>]</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line"><span class="keyword">if</span> nums[i] &gt;= max &#123;</div><div class="line">max = nums[i]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">end = i</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> nums[n-i<span class="number">-1</span>] &lt;= min &#123;</div><div class="line">min = nums[n-i<span class="number">-1</span>]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = n - i - <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> start &gt;= end &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> end - start + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">n := findUnsortedSubarray(nums)</div><div class="line">fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        start, end = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line">        ma, mi = nums[start], nums[end]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> ma &lt;= nums[i]:</div><div class="line">                ma = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                start = i</div><div class="line">            <span class="keyword">if</span> mi &gt;= nums[n - i - <span class="number">1</span>]:</div><div class="line">                mi = nums[n - i - <span class="number">1</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                end = n - i - <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> start &lt;= end:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> start - end + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><p>等我提交之后，发现排在第一的解法比我快很多，我当时就呵呵呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        max_num = nums[<span class="number">0</span>]</div><div class="line">        right = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt;= max_num:</div><div class="line">                max_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                right = i</div><div class="line">        left = n</div><div class="line">        min_num = nums[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] &lt;= min_num:</div><div class="line">                min_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = i</div><div class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span> <span class="keyword">if</span> right - left &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零四篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink介绍</title>
    <link href="https://zhangslob.github.io/2019/11/24/Flink%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zhangslob.github.io/2019/11/24/Flink介绍/</id>
    <published>2019-11-24T09:17:09.814Z</published>
    <updated>2019-11-24T09:43:27.250Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零三篇原创文章</code></pre><p><img src="https://flink.apache.org/img/flink-header-logo.svg" alt=""></p><p><code>Flink读书笔记（一）</code><br><a id="more"></a></p><p>最近在看一本书，《Flink原理、实战与性能优化》，记录下重点。</p><h1 id="Flink是什么"><a href="#Flink是什么" class="headerlink" title="Flink是什么"></a>Flink是什么</h1><p>Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</p><h1 id="Flink优势"><a href="#Flink优势" class="headerlink" title="Flink优势"></a>Flink优势</h1><ol><li>同时支持高吞吐、低延迟、高性能。Spark或Storm不能同时支持这三种。</li><li>支持事件事件（Event Time）概念。大多数框架仅支持系统时间（Process Time）。</li><li>支持有状态的计算。在流失计算中，将算子的中间计算结果保存在内存或磁盘中。</li><li>支持高度灵活的窗口（Window）操作。</li><li>基于轻量分布式快照（SnapShot）实现的容错。任务出现任务问题都可以从CheckPoints中自动恢复。</li><li>基于JVM实现独立的内存管理。Flink实现自身内存管理机制，通过序列化/反序列化将所有数据转化为二进制储存在内存中。</li><li>Save Points（保存点）。Flink将任务执行的快照保存在储存介质上。（和第5点类似）。</li></ol><h1 id="Flink应用场景"><a href="#Flink应用场景" class="headerlink" title="Flink应用场景"></a>Flink应用场景</h1><ol><li>实时智能推荐</li><li>复杂事件处理</li><li>实时欺诈检测</li><li>实时数仓与ETL</li><li>流数据处理</li><li>实时报表分析</li></ol><h1 id="Flink组件栈"><a href="#Flink组件栈" class="headerlink" title="Flink组件栈"></a>Flink组件栈</h1><p>Flink作为一个软件堆栈，是一个分层系统。堆栈的不同层相互叠加，并提高它们接受的程序表示的抽象级别:</p><ul><li>运行时层以JobGraph的形式接收程序。JobGraph是一个通用的并行数据流，其中包含使用和生成数据流的任意任务。</li><li>DataStream API和DataSet API都通过单独的编译过程生成JobGraphs。数据集API使用优化器来确定程序的最佳计划，而DataStream API使用流构建器。</li><li>JobGraph是根据Flink中可用的各种部署选项执行的(例如，本地、远程、Yarn等)</li><li>Connector层所能对接的技术更是丰富多样，将不同类型、不同来源的数据介入到Flink组件栈中。</li></ul><p><img src="https://raw.githubusercontent.com/Jonathan-Wei/Flink-Docs-CN/master/.gitbook/assets/4d9108a9-ab87-4380-be77-1ad455fa2d8f.png" alt=""></p><h1 id="Flink架构图"><a href="#Flink架构图" class="headerlink" title="Flink架构图"></a>Flink架构图</h1><p>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p><ul><li><strong>Client</strong> 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</li><li><strong>JobManager</strong> 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li><li><strong>TaskManager</strong> 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</li></ul><p>可以看到 Flink 的任务调度是多线程模型，并且不同Job/Task混合在一个 TaskManager 进程中。虽然这种方式可以有效提高 CPU 利用率，但是个人不太喜欢这种设计，因为不仅缺乏资源隔离机制，同时也不方便调试。类似 Storm 的进程模型，一个JVM 中只跑该 Job 的 Tasks 实际应用中更为合理。</p><p><img src="https://i.imgur.com/sg6tXAa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://flink.apache.org/img/flink-header-logo.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flink读书笔记（一）&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Flink" scheme="https://zhangslob.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 287. 寻找重复数</title>
    <link href="https://zhangslob.github.io/2019/11/21/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://zhangslob.github.io/2019/11/21/Leetcode-287-寻找重复数/</id>
    <published>2019-11-21T05:53:36.612Z</published>
    <updated>2019-11-21T06:35:36.592Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零二篇原创文章</code></pre><p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [1,3,4,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [3,1,3,4,2]</div><div class="line">输出: 3</div></pre></td></tr></table></figure><p><strong>说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">不能更改原数组（假设数组是只读的）。</div><div class="line">只能使用额外的 O(1) 的空间。</div><div class="line">时间复杂度小于 O(n2) 。</div><div class="line">数组中只有一个重复的数字，但它可能不止重复出现一次。</div></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>思路是采用了二分法+抽屉原理。首先解释一下为什么用二分法，因为O(n2)时间复杂度不能A，所以往下应该是n*logn，很容易联想到二分法，因为其复杂度为logn。</p><p>抽屉原理是说假设你有11个苹果，要放进10个抽屉，那么至少有一个抽屉里是有两个苹果的。</p><p>对应到这题，1~n的n+1个数字，有1个数字会至少重复两次。</p><p>比如取数组为｛1，2，2，3，4，5｝，一共6个数，范围是1~5，其中位数应该是（5+1）/2 = 3，那么，如果小于等于3的数的个数如果超过了3，那么重复的数字一定出现在[1，3]之间，否则出现在[4，5]之间。以该数组为例，中位数为3，小于等于3的数一共有4个，大于3的数有两个，所以重复的数字在[1,3]之间。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt;= mid) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        left, right = <span class="number">1</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right:</div><div class="line">            mid = (left + right) // <span class="number">2</span></div><div class="line">            count = sum(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums)</div><div class="line">            <span class="keyword">if</span> count &gt; mid:</div><div class="line">                right = mid</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> right</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">start, end := <span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line"><span class="keyword">for</span> start &lt; end &#123;</div><div class="line">mid := (start + end) / <span class="number">2</span></div><div class="line">count := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</div><div class="line"><span class="keyword">if</span> v &lt;= mid &#123;</div><div class="line">count++</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> count &gt; mid &#123;</div><div class="line">end = mid</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = mid + <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> start</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>数组的索引与存储的数值之间形成了特殊<strong>链表</strong>。</p><p>如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。</p><p>环的入口即为结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// 快慢指针</span></div><div class="line">        <span class="keyword">int</span> fast = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> low = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            low = nums[low];</div><div class="line">            fast = nums[nums[fast]];</div><div class="line">        &#125;<span class="keyword">while</span>(fast != low);</div><div class="line">        <span class="keyword">int</span> step = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 寻找环链表的入口，即为结果</span></div><div class="line">        <span class="keyword">while</span>(step != low)&#123;</div><div class="line">            step = nums[step];</div><div class="line">            low = nums[low];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>现在还没看懂这种方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://zhangslob.github.io/2019/11/12/%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangslob.github.io/2019/11/12/算法/</id>
    <published>2019-11-12T13:47:02.238Z</published>
    <updated>2019-11-13T05:59:37.192Z</updated>
    
    <content type="html"><![CDATA[<p>java基础  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h2 id="算法-Algorithms"><a href="#算法-Algorithms" class="headerlink" title="算法 - Algorithms"></a><strong>算法 - Algorithms</strong></h2><ol><li>排序算法：快速排序、归并排序、计数排序</li><li>搜索算法：回溯、递归、剪枝技巧</li><li>图论：最短路、最小生成树、网络流建模</li><li>动态规划：背包问题、最长子序列、计数问题</li><li>基础技巧：分治、倍增、二分、贪心</li></ol><h2 id="数据结构-Data-Structures"><a href="#数据结构-Data-Structures" class="headerlink" title="数据结构 - Data Structures"></a><strong>数据结构 - Data Structures</strong></h2><ol><li>数组与链表：单 / 双向链表、跳舞链</li><li>栈与队列</li><li>树与图：最近公共祖先、并查集</li><li>哈希表</li><li>堆：大 / 小根堆、可并堆</li><li>字符串：字典树、后缀树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合框架常见面试题</title>
    <link href="https://zhangslob.github.io/2019/11/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhangslob.github.io/2019/11/11/Java集合框架常见面试题/</id>
    <published>2019-11-11T08:21:46.065Z</published>
    <updated>2019-11-20T03:40:43.026Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="说说List-Set-Map三者的区别"><a href="#说说List-Set-Map三者的区别" class="headerlink" title="说说List,Set,Map三者的区别"></a>说说List,Set,Map三者的区别</h1><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h1><ul><li><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong><ul><li>① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li>② <strong>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响</strong>，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度应为o(n))因为需要新创立一个新的链表，复制前i-1个元素并在第i位加入新的元素，最后附上n-i个元素。</li></ul></li><li><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a><strong>补充内容:RandomAccess接口</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（</code>）方法中，它要判断传入的list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch（）</code>方法，如果不是，那么调用<code>iteratorBinarySearch（）</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</div><div class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</li><li>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</li></ul><h1 id="双向链表和双向循环链表"><a href="#双向链表和双向循环链表" class="headerlink" title="双向链表和双向循环链表"></a>双向链表和双向循环链表</h1><p><strong>双向链表：</strong> 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。</p><p><a href="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" alt="双向链表"></a></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。</p><p><a href="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" alt="双向循环链表"></a></p><h1 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h1><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p><h1 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h1><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="external">通过源码一步一步分析ArrayList 扩容机制</a></p><p>#HashMap 和 Hashtable 的区别</p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put（）</code>向map中添加元素</td><td>调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></div><div class="line">    <span class="comment">// ^ ：按位异或</span></div><div class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line"></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><a href="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" alt="jdk1.8之前的内部结构-HashMap"></a></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><a href="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" alt="jdk1.8之后的内部结构-HashMap"></a></p><blockquote><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong>推荐阅读：</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p><h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="external">https://coolshell.cn/articles/9606.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
</feed>
