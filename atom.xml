<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小歪的博客</title>
  
  <subtitle>人生苦短，我学Python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangslob.github.io/"/>
  <updated>2020-03-04T12:40:32.287Z</updated>
  <id>https://zhangslob.github.io/</id>
  
  <author>
    <name>崔斯特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java匠人手法-优雅的处理空值</title>
    <link href="https://zhangslob.github.io/2020/03/04/Java%E5%8C%A0%E4%BA%BA%E6%89%8B%E6%B3%95-%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC/"/>
    <id>https://zhangslob.github.io/2020/03/04/Java匠人手法-优雅的处理空值/</id>
    <published>2020-03-04T12:34:00.939Z</published>
    <updated>2020-03-04T12:40:32.287Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十五篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><blockquote><p>在笔者几年的开发经验中，经常看到项目中存在到处空值判断的情况，这些判断，会让人觉得摸不这头绪，它的出现很有可能和当前的业务逻辑并没有关系。但它会让你很头疼。<br>有时候，更可怕的是系统因为这些空值的情况，会抛出空指针异常，导致业务系统发生问题。<br>此篇文章，我总结了几种关于空值的处理手法，希望对读者有帮助。</p></blockquote><h1 id="业务中的空值"><a href="#业务中的空值" class="headerlink" title="业务中的空值"></a>业务中的空值</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>存在一个UserSearchService用来提供用户查询的功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="问题现场"><a href="#问题现场" class="headerlink" title="问题现场"></a>问题现场</h2><p>对于面向对象语言来讲，抽象层级特别的重要。尤其是对接口的抽象，它在设计和开发中占很大的比重，我们在开发时希望尽量面向接口编程。<br>对于以上描述的接口方法来看，大概可以推断出可能它包含了以下两个含义:</p><ol><li>listUser(): 查询用户列表</li><li>get(Integer id): 查询单个用户</li></ol><p>在所有的开发中，XP推崇的TDD模式可以很好的引导我们对接口的定义，所以我们将TDD作为开发代码的”推动者”。<br>对于以上的接口，当我们使用TDD进行测试用例先行时，发现了潜在的问题：</p><ol><li>listUser() 如果没有数据，那它是返回空集合还是null呢？</li><li>get(Integer id) 如果没有这个对象，是抛异常还是返回null呢？</li></ol><h3 id="深入listUser研究"><a href="#深入listUser研究" class="headerlink" title="深入listUser研究"></a>深入listUser研究</h3><p>我们先来讨论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listUser()</div></pre></td></tr></table></figure><p>这个接口，我经常看到如下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>&#123;</div><div class="line">    List&lt;User&gt; userList = userListRepostity.selectByExample(<span class="keyword">new</span> UserExample());</div><div class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList))&#123;<span class="comment">//spring util工具类</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码返回是null,从我多年的开发经验来讲，对于集合这样返回值，最好不要返回null，因为如果返回了null，会给调用者带来很多麻烦。你将会把这种调用风险交给调用者来控制。</p><p>如果调用者是一个谨慎的人，他会进行是否为null的条件判断。如果他并非谨慎，或者他是一个面向接口编程的狂热分子(当然，面向接口编程是正确的方向)，他会按照自己的理解去调用接口，而不进行是否为null的条件判断，如果这样的话，是非常危险的，它很有可能出现空指针异常！</p><p>根据墨菲定律来判断: “很有可能出现的问题，在将来一定会出现!”</p><p>基于此，我们将它进行优化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>&#123;</div><div class="line">    List&lt;User&gt; userList = userListRepostity.selectByExample(<span class="keyword">new</span> UserExample());</div><div class="line">    <span class="keyword">if</span>(CollectionUtils.isEmpty(userList))&#123;</div><div class="line">      <span class="keyword">return</span> Lists.newArrayList();<span class="comment">//guava类库提供的方式</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> userList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于接口(List listUser())，它一定会返回List，即使没有数据，它仍然会返回List（集合中没有任何元素）;</p><p>通过以上的修改，我们成功的避免了有可能发生的空指针异常，这样的写法更安全！</p><h3 id="深入研究get方法"><a href="#深入研究get方法" class="headerlink" title="深入研究get方法"></a>深入研究get方法</h3><p>对于接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span></div></pre></td></tr></table></figure><p>你能看到的现象是，我给出id，它一定会给我返回User。但事实真的很有可能不是这样的。</p><p>我看到过的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Integer id)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> userRepository.selectByPrimaryKey(id);<span class="comment">//从数据库中通过id直接获取实体对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相信很多人也都会这样写。</p><p>通过代码的时候得知它的返回值很有可能是null! 但我们通过的接口是分辨不出来的!这个是个非常危险的事情。尤其对于调用者来说！</p><p>我给出的建议是，需要在接口明明时补充文档,比如对于异常的说明,使用注解@exception:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们把接口定义加上了说明之后，调用者会看到，如果调用此接口，很有可能抛出“UserNotFoundException(找不到用户)”这样的异常。</p><p>这种方式可以在调用者调用接口的时候看到接口的定义，但是，这种方式是”弱提示”的！如果调用者忽略了注释，有可能就对业务系统产生了风险，这个风险有可能导致一个亿！</p><p>除了以上这种”弱提示”的方式，还有一种方式是，返回值是有可能为空的。那要怎么办呢？</p><p>我认为我们需要增加一个接口，用来描述这种场景。引入jdk8的Optional,或者使用guava的Optional.看如下定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Optional有两个含义: 存在 or 缺省。</p><p>那么通过阅读接口getOptional()，我们可以很快的了解返回值的意图，这个其实是我们想看到的，它去除了二义性。</p><p>它的实现可以写成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(Integer id)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> Optional.ofNullable(userRepository.selectByPrimaryKey(id));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="深入入参"><a href="#深入入参" class="headerlink" title="深入入参"></a>深入入参</h3><p>通过上述的所有接口的描述，你能确定入参id一定是必传的吗？ 我觉得答案应该是：不能确定。除非接口的文档注释上加以说明。</p><p>那如何约束入参呢?</p><p>我给大家推荐两种方式：</p><ol><li>强制约束</li><li>文档性约束（弱提示）</li></ol><p>1.强制约束，我们可以通过jsr 303进行严格的约束声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(@NotNull Integer id)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(@NotNull Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当然，这样写，要配合AOP的操作进行验证，但让spring已经提供了很好的集成方案，在此我就不在赘述了。</p><p>2.文档性约束</p><p>在很多时候，我们会遇到遗留代码，对于遗留代码，整体性改造的可能性很小。<br>我们更希望通过阅读接口的实现，来进行接口的说明。</p><p>jsr 305规范，给了我们一个描述接口入参的一个方式(需要引入库 com.google.code.findbugs:jsr305):</p><p>可以使用注解: @Nullable @Nonnull @CheckForNull 进行接口说明。<br>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSearchService</span></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体</div><div class="line">   * <span class="doctag">@exception</span> UserNotFoundException</div><div class="line">   */</div><div class="line">  <span class="meta">@CheckForNull</span></div><div class="line">  <span class="function">User <span class="title">get</span><span class="params">(@NonNull Integer id)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 根据用户id获取用户信息</div><div class="line">   * <span class="doctag">@param</span> id 用户id</div><div class="line">   * <span class="doctag">@return</span> 用户实体,此实体有可能是缺省值</div><div class="line">   */</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">getOptional</span><span class="params">(@NonNull Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过 空集合返回值，Optional，jsr 303，jsr 305这几种方式，可以让我们的代码可读性更强，出错率更低！</p><ol><li>空集合返回值 ： 如果有集合这样返回值时，除非真的有说服自己的理由，否则，一定要返回空集合，而不是null</li><li>Optional: 如果你的代码是jdk8，就引入它！ 如果不是，则使用Guava的Optional,或者升级jdk版本！ 它很大程度的能增加了接口的可读性！</li><li>jsr 303: 如果新的项目正在开发，不防加上这个试试！ 一定有一种特别爽的感觉!</li><li>jsr 305: 如果老的项目在你的手上，你可以尝试的加上这种文档型注解，有助于你后期的重构，或者新功能增加了，对于老接口的理解!</li></ol><h1 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h2><p>我们来看一个DTO转化的场景，对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> String dtoName;</div><div class="line">  <span class="keyword">private</span> String dtoAge;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="keyword">private</span> String age;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需求是将Person对象转化成PersonDTO，然后进行返回。</p><p>当然对于实际操作来讲，返回如果Person为空，将返回null,但是PersonDTO是不能返回null的（尤其Rest接口返回的这种DTO）。</p><p>在这里，我们只关注转化操作，看如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">  PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">  Person person = <span class="keyword">new</span> Person();</div><div class="line">  <span class="keyword">if</span>(!Objects.isNull(person))&#123;</div><div class="line">    personDTO.setDtoAge(person.getAge());</div><div class="line">    personDTO.setDtoName(person.getName());</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    personDTO.setDtoAge(<span class="string">""</span>);</div><div class="line">    personDTO.setDtoName(<span class="string">""</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优化修改"><a href="#优化修改" class="headerlink" title="优化修改"></a>优化修改</h2><p>这样的数据转化，我们认识可读性非常差，每个字段的判断，如果是空就设置为空字符串(“”)</p><p>换一种思维方式进行思考，我们是拿到Person这个类的数据，然后进行赋值操作(setXXX),其实是不关系Person的具体实现是谁的。</p><p>那我们可以创建一个Person子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它作为Person的一种特例而存在，如果当Person为空的时候，则返回一些get的默认行为.</p><p>所以代码可以修改为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">   PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">   Person person = getPerson();</div><div class="line">   personDTO.setDtoAge(person.getAge());</div><div class="line">   personDTO.setDtoName(person.getName());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> NullPerson();<span class="comment">//如果Person是null ,则返回空对象</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>其中getPerson()方法，可以用来根据业务逻辑获取Person有可能的对象（对当前例子来讲，如果Person不存在，返回Person的的特例NUllPerson），如果修改成这样，代码的可读性就会变的很强了。</p><h2 id="使用Optional可以进行优化"><a href="#使用Optional可以进行优化" class="headerlink" title="使用Optional可以进行优化"></a>使用Optional可以进行优化</h2><p>空对象模式，它的弊端在于需要创建一个特例对象，但是如果特例的情况比较多，我们是不是需要创建多个特例对象呢，虽然我们也使用了面向对象的多态特性，但是，业务的复杂性如果真的让我们创建多个特例对象，我们还是要再三考虑一下这种模式，它可能会带来代码的复杂性。</p><p>对于上述代码，还可以使用Optional进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldConvertDTO</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</div><div class="line"></div><div class="line">    Optional.ofNullable(getPerson()).ifPresent(person -&gt; &#123;</div><div class="line">      personDTO.setDtoAge(person.getAge());</div><div class="line">      personDTO.setDtoName(person.getName());</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>Optional对空值的使用，我觉得更为贴切，它只适用于”是否存在”的场景。</p><p>如果只对控制的存在判断，我建议使用Optional.</p><h1 id="Optioanl的正确使用"><a href="#Optioanl的正确使用" class="headerlink" title="Optioanl的正确使用"></a>Optioanl的正确使用</h1><p>Optional如此强大，它表达了计算机最原始的特性(0 or 1),那它如何正确的被使用呢!</p><h2 id="Optional不要作为参数"><a href="#Optional不要作为参数" class="headerlink" title="Optional不要作为参数"></a>Optional不要作为参数</h2><p>如果你写了一个public方法，这个方法规定了一些输入参数，这些参数中有一些是可以传入null的，那这时候是否可以使用Optional呢？</p><p>我给的建议是: 一定不要这样使用!</p><p>举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">(Optional&lt;String&gt; username)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个例子的方法 listUser,可能在告诉我们需要根据username查询所有数据集合，如果username是空，也要返回所有的用户集合.</p><p>当我们看到这个方法的时候，会觉得有一些歧义:</p><p>“如果username是absent,是返回空集合吗？还是返回全部的用户数据集合？”</p><p>Optioanl是一种分支的判断，那我们究竟是关注 Optional还是Optional.get()呢？</p><p>我给大家的建议是，如果不想要这样的歧义，就不要使用它！</p><p>如果你真的想表达两个含义，就給它拆分出两个接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">(String username)</span></span>;</div><div class="line">  <span class="function">List&lt;User&gt; <span class="title">listUser</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我觉得这样的语义更强，并且更能满足 软件设计原则中的 “单一职责”。</p><p>如果你觉得你的入参真的有必要可能传null,那请使用jsr 303或者jsr 305进行说明和验证!</p><p>请记住! Optional不能作为入参的参数!</p><h2 id="Optional作为返回值"><a href="#Optional作为返回值" class="headerlink" title="Optional作为返回值"></a>Optional作为返回值</h2><h3 id="当个实体的返回"><a href="#当个实体的返回" class="headerlink" title="当个实体的返回"></a>当个实体的返回</h3><p>那Optioanl可以做为返回值吗？</p><p>其实它是非常满足是否存在这个语义的。</p><p>你如说，你要根据id获取用户信息，这个用户有可能存在或者不存在。</p><p>你可以这样使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  <span class="function">Optional&lt;User&gt; <span class="title">get</span><span class="params">(Integer id)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当调用这个方法的时候，调用者很清楚get方法返回的数据，有可能不存在，这样可以做一些更合理的判断，更好的防止空指针的错误！</p><p>当然，如果业务方真的需要根据id必须查询出User的话，就不要这样使用了，请说明，你要抛出的异常.</p><p>只有当考虑它返回null是合理的情况下，才进行Optional的返回</p><h3 id="集合实体的返回"><a href="#集合实体的返回" class="headerlink" title="集合实体的返回"></a>集合实体的返回</h3><p>不是所有的返回值都可以这样用的！ 如果你返回的是集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</div><div class="line">  Optional&lt;List&lt;User&gt;&gt; listUser();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样的返回结果，会让调用者不知所措，是否我判断Optional之后，还用进行isEmpty的判断呢？</p><p>这样带来的返回值歧义！ 我认为是没有必要的。</p><p>我们要约定，对于List这种集合返回值，如果集合真的是null的，请返回空集合(Lists.newArrayList);</p><h2 id="使用Optional变量"><a href="#使用Optional变量" class="headerlink" title="使用Optional变量"></a>使用Optional变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;User&gt; userOpt = ...</div></pre></td></tr></table></figure><p>如果有这样的变量userOpt,请记住 ：</p><ol><li>一定不能直接使用get ，如果这样用，就丧失了Optional本身的含义 （ 比如userOp.get() ）</li><li>不要直接使用getOrThrow ,如果你有这样的需求：获取不到就抛异常。 那就要考虑，是否是调用的接口设计的是否合理</li></ol><h2 id="getter中的使用"><a href="#getter中的使用" class="headerlink" title="getter中的使用"></a>getter中的使用</h2><p>对于一个java bean,所有的属性都有可能返回null,那是否需要改写所有的getter成为Optional类型呢？</p><p>我给大家的建议是，不要这样滥用Optional.</p><p>即便 我java bean中的getter是符合Optional的，但是因为java bean 太多了，这样会导致你的代码有50%以上进行Optinal的判断，这样便污染了代码。(我想说，其实你的实体中的字段应该都是由业务含义的，会认真的思考过它存在的价值的，不能因为Optional的存在而滥用)</p><p>我们应该更关注于业务，而不只是空值的判断。</p><p>请不要在getter中滥用Optional.</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>可以这样总结Optional的使用：</p><ol><li>当使用值为空的情况，并非源于错误时，可以使用Optional!</li><li>Optional不要用于集合操作!</li><li>不要滥用Optional,比如在java bean的getter中!</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-136-只出现一次的数字</title>
    <link href="https://zhangslob.github.io/2020/02/23/Leetcode-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://zhangslob.github.io/2020/02/23/Leetcode-136-只出现一次的数字/</id>
    <published>2020-02-23T06:28:19.620Z</published>
    <updated>2020-02-23T07:00:07.701Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十四篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/single-number" target="_blank" rel="external">https://leetcode-cn.com/problems/single-number</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="粗暴解法"><a href="#粗暴解法" class="headerlink" title="粗暴解法"></a>粗暴解法</h2><p>使用map保存每个元素在数组中出现的次数，key是元素，value是出现次数。</p><p>这种方法显然不符合题目需求，不使用额外空间。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>按位异或：<strong>参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。</strong></p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0^0 = 0，</div><div class="line">1^0 = 1，</div><div class="line">0^1 = 1，</div><div class="line">1^1 = 0</div></pre></td></tr></table></figure><p>异或运算的符号是<code>^</code>，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a xor b = (a &amp; ^b) | (^a &amp; b)</div></pre></td></tr></table></figure><p>真值表：</p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">a xor b</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>因为有定律<code>a ^ b ^ a = b</code>，所以我们这里就可以使用异或来做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_number</span><span class="params">(numbers)</span>:</span></div><div class="line">    tmp = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</div><div class="line">        tmp ^= n</div><div class="line">    <span class="keyword">return</span> tmp</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</div><div class="line">        result ^= num;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到非常简单。</p><p>这些全都是计算机基础知识，但是自己不知道，只能说明自己基础差，以后补得起来吗。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十四篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Kafka 消费者 Java 实现</title>
    <link href="https://zhangslob.github.io/2020/01/09/Kafka-%E6%B6%88%E8%B4%B9%E8%80%85-Java-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhangslob.github.io/2020/01/09/Kafka-消费者-Java-实现/</id>
    <published>2020-01-09T13:01:06.553Z</published>
    <updated>2020-01-09T13:33:23.013Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十三篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/UveOWwz.jpg" alt=""></p><a id="more"></a><p>应用程序使用 KafkaConsumer向 Kafka 订阅 Topic 接收消息，首先理解 Kafka 中消费者（consumer）和消费者组（consumer group）的概念和特性。</p><h1 id="KafkaConsumer"><a href="#KafkaConsumer" class="headerlink" title="KafkaConsumer"></a>KafkaConsumer</h1><h2 id="消费者和消费者组"><a href="#消费者和消费者组" class="headerlink" title="消费者和消费者组"></a>消费者和消费者组</h2><p>当生产者向 Topic 写入消息的速度超过了消费者（consumer）的处理速度，导致大量的消息在 Kafka 中淤积，此时需要对消费者进行横向伸缩，用多个消费者从同一个主题读取消息，对消息进行分流。</p><p>Kafka 的消费者都属于消费者组（consumer group）。一个组中的 consumer 订阅同样的 topic，每个 consumer 接收 topic 一些分区（partition）中的消息。<strong>同一个分区不能被一个组中的多个 consumer 消费</strong>。</p><p>假设现在有一个 Topic 有4个分区，有一个消费者组订阅了这个 Topic，随着组中的消费者数量从1个增加到5个时，Topic 中分区被读取的情况：</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/kakfa_consumer.png" alt=""></p><p>如果组中 consumer 的数量超过分区数，多出的 consumer 会被闲置。因此，如果想提高消费者的并行处理能力，需要设置足够多的 partition 数量。</p><p>除了通过增加 consumer 来横向伸缩单个应用程序外，还会出现多个应用程序从同一个 Topic 读取数据的情况。这也是 Kafka 设计的主要目标之一：让 Topic 中的数据能够满足各种应用场景的需求。</p><p>如果要每个应用程序都可以获取到所有的消息，而不只是其中的一部分，只要保证每个应用程序有自己的 consumer group，就可以获取到 Topic 所有的消息：</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/kakfa_consumer2.png" alt=""></p><p>横向伸缩 Kafka 消费者和消费者群组并不会对性能造成负面影响。</p><h2 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h2><p>一个消费者组内的 consumer 共同读取 Topic 的分区。</p><ol><li>当一个 consumer 加入组时，读取的是原本由其他 consumer 读取的分区。</li><li>当一个 consumer 离开组时（被关闭或发生崩溃），原本由它读取的分区将由组里的其他 consumer 来读取。</li><li>当 Topic 发生变化时，比如添加了新的分区，会发生分区重分配。</li></ol><p>分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡（rebalance）。再均衡非常重要，为消费者组带来了高可用性和伸缩性，可以放心的增加或移除消费者。</p><p>再均衡期间，消费者无法读取消息，造成整个 consumer group 一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，当前的读取状态会丢失。</p><p>消费者通过向作为组协调器（GroupCoordinator）的 broker（不同的组可以有不同的协调器）发送心跳来维持和群组以及分区的关系。心跳表明消费者在读取分区里的消息。消费者会在轮询消息或提交偏移量（offset）时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，组协调器认为消费者已经死亡，会触发一次再均衡。</p><p>在 Kafka 0.10.1 的版本中，对心跳行为进行了修改，由一个独立的线程负责心跳。</p><h1 id="消费-Kafka"><a href="#消费-Kafka" class="headerlink" title="消费 Kafka"></a>消费 Kafka</h1><h2 id="创建-Kafka-消费者"><a href="#创建-Kafka-消费者" class="headerlink" title="创建 Kafka 消费者"></a>创建 Kafka 消费者</h2><p>在读取消息之前，需要先创建一个 KafkaConsumer 对象。创建 KafkaConsumer 对象与创建 KafkaProducer 非常相似，创建 KafkaConsumer 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092, broker2:9092"</span>);</div><div class="line"><span class="comment">// group.id，指定了消费者所属群组</span></div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serializaiton.StrignDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serializaiton.StrignDeserializer"</span>);</div><div class="line"></div><div class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</div></pre></td></tr></table></figure><h2 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h2><p>创建了消费者之后，需要订阅 Topic，subscribe() 方法接受一个主题列表作为参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// topic name is “customerCountries”</span></div><div class="line">consumer.subscribe(Collections.singletonList(<span class="string">"customerCountries"</span>));</div></pre></td></tr></table></figure><p>subscribe() 也可以接收一个正则表达式，匹配多个主题（如果有新的名称匹配的主题创建，会立即触发一次再均衡，消费者就可以读取新添加的主题）。在 Kafka 和其他系统之间复制数据时，使用正则表达式的方式订阅多个主题是很常见的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 订阅所有 test 前缀的 Topic：</span></div><div class="line">consumer.subscribe(<span class="string">"test.*"</span>);</div></pre></td></tr></table></figure><h2 id="消息轮询"><a href="#消息轮询" class="headerlink" title="消息轮询"></a>消息轮询</h2><p>消息轮询是消费者的核心，通过轮询向服务器请求数据。消息轮询 API 会处理所有的细节，包括群组协调、分区再均衡、发送心跳和获取数据，开发者只需要处理从分区返回的数据。消费者代码的主要部分如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="comment">// 100 是超时时间（ms），在该时间内 poll 会等待服务器返回数据</span></div><div class="line">        ConsumerReccords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>); </div><div class="line"></div><div class="line">        <span class="comment">// poll 返回一个记录列表。</span></div><div class="line">        <span class="comment">// 每条记录都包含了记录所属主题的信息、记录所在分区的信息、记录在分区里的偏移量，以及记录的键值对。</span></div><div class="line">        <span class="keyword">for</span> (ConsumerReccord&lt;String, String&gt; record : records) &#123;</div><div class="line">            log.debug(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">                record.topic(), record.partition(), record.offset(), </div><div class="line">                record.key(), record.value());</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭消费者,网络连接和 socket 也会随之关闭，并立即触发一次再均衡</span></div><div class="line">    consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在第一次调用新消费者的 poll() 方法时，会负责查找 GroupCoordinator，然后加入群组，接受分配的分区。如果发生了再均衡，整个过程也是在轮询期间进行的。心跳也是从轮询里发送出去的。</p><h1 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h1><p>Kafka 与消费者相关的配置大部分参数都有合理的默认值，一般不需要修改，不过有一些参数与消费者的性能和可用性有很大关系。接下来介绍这些重要的属性。</p><h3 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a>fetch.min.bytes</h3><p>指定消费者从服务器获取记录的最小字节数。服务器在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes，那么会等到有足够的可用数据时才返回给消费者。</p><p>合理的设置可以降低消费者和 broker 的工作负载，在 Topic 消息生产不活跃时，减少处理消息次数。如果没有很多可用数据，但消费者的 CPU 使用率却很高，需要调高该属性的值。如果消费者的数量比较多，调高该属性的值也可以降低 broker 的工作负载。</p><h3 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a>fetch.max.wait.ms</h3><p>指定在 broker 中的等待时间，默认是500ms。如果没有足够的数据流入 Kafka，消费者获取的数据量的也没有达到 fetch.min.bytes，最终导致500ms的延迟。</p><p>如果要降低潜在的延迟（提高 SLA），可以调低该属性的值。fetch.max.wait.ms 和 fetch.min.bytes 有一个满足条件就会返回数据。</p><h3 id="max-parition-fetch-bytes"><a href="#max-parition-fetch-bytes" class="headerlink" title="max.parition.fetch.bytes"></a>max.parition.fetch.bytes</h3><p>指定了服务器从每个分区里返回给消费者的最大字节数，默认值是1MB。也就是说 KafkaConsumer#poll() 方法从每个分区里返回的记录最多不超过 max.parition.fetch.bytes 指定的字节。</p><p>如果一个主题有20个分区和5个消费者（同一个组内），那么每个消费者需要至少4MB 的可用内存（每个消费者读取4个分区）来接收记录。如果组内有消费者发生崩溃，剩下的消费者需要处理更多的分区。</p><p>max.parition.fetch.bytes 必须比 broker 能够接收的最大消息的字节数（max.message.size）大，否则消费者可能无法读取这些消息，导致消费者一直重试。</p><p>另一个需要考虑的因素是消费者处理数据的时间。消费者需要频繁调用 poll() 方法来避免会话过期和发生分区再均衡，如果单次调用 poll() 返回的数据太多，消费者需要更多的时间来处理，可能无法及时进行下一个轮询来避免会话过期。如果出现这种情况，可以把 max.parition.fetch.bytes 值改小或者延长会话过期时间。</p><h3 id="session-timeout-ms"><a href="#session-timeout-ms" class="headerlink" title="session.timeout.ms"></a>session.timeout.ms</h3><p>指定了消费者与服务器断开连接的最大时间，默认是3s。如果消费者没有在指定的时间内发送心跳给 GroupCoordinator，就被认为已经死亡，会触发再均衡，把它的分区分配给其他消费者。</p><p>该属性与 heartbeat.interval.ms 紧密相关，heartbeat.interval.ms 指定了 poll() 方法向协调器发送心跳的频率，session.timeout.ms 指定了消费者最长多久不发送心跳。所以，一般需要同时修改这两个属性，heartbeat.interval.ms 必须比 session.timeout.ms 小，一般是 session.timeout.ms 的三分之一，如果 session.timeout.ms 是 3s，那么 heartbeat.interval.ms 应该是 1s。</p><p>调低属性的值可以更快地检测和恢复崩溃的节点，不过长时间的轮询或垃圾收集可能导致非预期的再均衡。调高属性的值，可以减少意外的再均衡，不过检测节点崩溃需要更长的时间。</p><h3 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h3><p>指定了消费者在读取一个没有偏移量（offset）的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时井被删除）该作何处理，默认值是 latest，表示在 offset 无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）。</p><p>另一个值是 earliest，消费者将从起始位置读取分区的记录。</p><h3 id="enable-auto-commit"><a href="#enable-auto-commit" class="headerlink" title="enable.auto.commit"></a>enable.auto.commit</h3><p>指定了消费者是否自动提交偏移量，默认值是 true，自动提交。</p><p>设为 false 可以程序自己控制何时提交偏移量。如果设为 true，需要通过配置 auto.commit.interval.ms 属性来控制提交的频率。</p><h3 id="partition-assignment-strategy"><a href="#partition-assignment-strategy" class="headerlink" title="partition.assignment.strategy"></a>partition.assignment.strategy</h3><p>分区分配给组内消费者的策略，根据给定的消费者和 Topic，决定哪些分区应该被分配给哪个消费者。Kafka 有两个默认的分配策略：</p><ul><li>Range，把 Topic 的若干个连续的分区分配给消费者。<br>假设 consumer1 和 consumer2（c1、c2 代替）订阅了 topic1 和 topic2（t1、t2 代替），每个 Topic 都有3个分区。那么 c1 可能分配到 t1-part-0、t1-part-1、t2-part-0 和 t2-part1，而 c2 可能分配到 t1-part-2 和 t2-part-2。只要使用了 Range 策略，而且分区数量无法被消费者数量整除，就会出现这种情况。</li><li>RoundRobin，把所有分区逐个分配给消费者。<br>上面的例子如果使用 RoundRobin 策略，那么 c1 可能分配到 t1-part-0、t1-part-2 和 t2-part-1，c2 可能分配到 t1-part-1、t2-part-0 和 t2-part-2。一般来说，RoundRobin 策略会给所有消费者分配大致相同的分区数。</li></ul><p>默认值是 org.apache.kafka.clients.consumer.RangeAssignor，这个类实现了 Range 策略，org.apache.kafka.clients.consumer.RoundRobinAssignor 是 RoundRobin 策略的实现类。还可以使用自定义策略，属性值设为自定义类的名字。</p><h3 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a>client.id</h3><p>broker 用来标识从客户端发送过来的消息，可以是任意字符串，通常被用在日志、度量指标和配额中。</p><h3 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h3><p>用于控制单次调用 call() 方法能够返回的记录数量，帮助控制在轮询里需要处理的数据量。</p><h3 id="receive-buffer-bytes-和-send-buffer-bytes"><a href="#receive-buffer-bytes-和-send-buffer-bytes" class="headerlink" title="receive.buffer.bytes 和 send.buffer.bytes"></a>receive.buffer.bytes 和 send.buffer.bytes</h3><p>分别指定了 TCP socket 接收和发送数据包的缓冲区大小。如果设为-1就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p><h1 id="消费与提交"><a href="#消费与提交" class="headerlink" title="消费与提交"></a>消费与提交</h1><h2 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h2><p>每次调用 poll() 方法，总是返回 Kafka 中还没有被消费者读取过的记录，使用偏移量（offset）来记录消费者读取的分区的位置。</p><p>更新分区当前位置的操作叫做“提交（commit）”，消费者是如何提交偏移量的呢？</p><p>消费者向一个特殊的 Topic：<code>_consumer_offset</code> 发送消息，消息包含每个分区的偏移量。偏移量只有在消费者发生崩溃或者有新的消费者加入群组触发再均衡时有用。完成再均衡之后，消费者可能分配到新的分区，为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的 offset，然后从 offset 指定的地方继续处理。<br>如果提交的 offset 大于客户端处理的最后一个消息偏移量，那么处于两个偏移量之间的消息会丢失。反之则会消息重复。</p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/commit-offset-2.png" alt=""></p><p><img src="https://raw.githubusercontent.com/BowenSun90/Picture-resources/master/blog/kafka/commit-offset-1.png" alt=""></p><p>所以，处理偏移量的方式对应用程序会有很大的影响。KafkaConsumer API 提供了多种方式来提交偏移量。</p><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>最简单的方式是消费者自动提交偏移量。如果 enable.auto.commit 设为 true，那 么每过一定时间间隔，消费者会自动把从 poll() 方法接收到的最大偏移量提交上去。提交时间间隔由 auto.commit.interval.ms 控制，默认是5s。</p><p>自动提交是在轮询里进行的。消费者每次在进行轮询时会检查是否需要提交偏移量，如果是，那么会提交从上一次轮询返回的偏移量。</p><p>假设我们使用默认的5s提交时间间隔，在最近一次提交之后的3s发生了再均衡，再 均衡之后，消费者从最后一次提交的偏移量位置开始读取消息。这个时候偏移量已经落后了3s，这3s内的数据已经处理过，再次消费是还会获取到。通过调低提交时间间隔来更频繁地提交偏移量，减小可能出现重复消费的时间窗，不过这种情况是无法完全避免的。</p><p>在使用自动提交时，每次调用轮询方法都会把上一次调用返回的偏移量提交上去，并不 知道具体哪些消息已经被处理了，所以在再次调用之前最好确保所有当前调用返回的消息都已经处理完毕（在调用 close() 方法前也会进行自动提交）。</p><p>在处理异常或提前退出轮询时要格外小心。自动提交虽然方便，不过并没有为开发者留有余地来避免重复处理消息。</p><h2 id="提交当前偏移量"><a href="#提交当前偏移量" class="headerlink" title="提交当前偏移量"></a>提交当前偏移量</h2><p>KafkaConsumer API 提供的另一种提交偏移量的方式，程序主动触发提交当前偏移量，而不是基于时间间隔自动提交。</p><p>把 auto.commit.offset 设为 false，使用 commitSync() 方法提交偏移量最简单也最可靠，该方法会提交由 poll() 方法返回的最新偏移量，提交成功后马上返回，如果提交失败就抛出异常。</p><p>需要注意，commitSync() 将会提交 poll() 返回的最新偏移量，在处理完所有记录后调用 commitSync()，否则还是会有丢失消息的风险。</p><p>commitSync() 提交偏移量的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>, </div><div class="line">            record.topic(), record.partition(), record.offset(),</div><div class="line">            record.key(), record.value());</div><div class="line">        <span class="comment">// 处理消息的逻辑省略</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// poll 的数据全部处理完提交</span></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</div><div class="line">        log.error(<span class="string">"commit failed"</span>, e)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只要没有发生不可恢复的错误，commitSync() 会一直尝试直至提交成功。如果提交 失败会抛出 CommitFailedException 异常。</p><h2 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h2><p>手动提交有一个不足之处，在 broker 对提交请求作出回应之前，应用程序会阻塞，这会影响应用程序的吞吐量。可以使用异步提交的方式，不等待 broker 的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>, </div><div class="line">            record.topic(), record.partition(), record.offset(),</div><div class="line">            record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 异步提交</span></div><div class="line">    consumer.commitAsync();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在成功提交或发生无法恢复的错误之前，commitSync() 会一直尝试直至提交成功，但是 commitAsync() 不会，这也是该方法的一个问题。之所以不进行重试，是因为在收到服务器响应之前，可能有一个更大的偏移量已经提交成功。</p><p>假设我们发出一个请求提交偏移量2000，这个时候发生了短暂的通信问题，服务器收不到请求，与此同时，程序处理了另外一批消息，并成功提交了偏移量3000。如果 commitAsync() 重新尝试提交偏移量2000，有可能将偏移量3000改为2000，这个时候如果发生再均衡，就会出现重复消息。</p><p>commitAsync() 支持回调，在 broker 作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标，如果要用它来进行重试，一定要注意提交的顺序。</p><p>commitAsync() 支持回调，在 broker 作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标，如果要用它来进行重试，一定要注意提交的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">            record.topic(), record.partition(), record.offset(), </div><div class="line">            record.key(), record.value());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 提交完成时回回调此函数</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">                log.error(<span class="string">"Commit failed for offsets &#123;&#125;"</span>, offsets, e);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重试异步提交</p><p>可以使用一个单调递增的序列号来维护异步提交的顺序。在每次提交偏移量之后或在回调里提交偏移量时递增序列号。在进行重试前，先检查回调的序列号和即将提交的偏移量是否相等，如果相等，说明没有新的提交，那么可以安全地进行重试。如果序列号比较大，说明有一个新的提交已经发送出去了，放弃重试。</p><h2 id="同步与异步混合提交"><a href="#同步与异步混合提交" class="headerlink" title="同步与异步混合提交"></a>同步与异步混合提交</h2><p>一般情况下，针对偶尔出现的提交失败，不进行重试不会有太大问题，如果因为临时网络问题导致的，那么后续的提交总会有成功的。但如果这是发生在关闭消费者或再均衡前的最后一次提交，就要确保能够提交成功。</p><p>在消费者关闭前一般会组合使用 commitAsync() 和 commitSync()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">                record.topic(), record.partition(), record.offset(), </div><div class="line">                record.key(), record.value());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 异步提交</span></div><div class="line">        consumer.commitAsync();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Unexpected error"</span>, e);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 同步提交</span></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        consumer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在正常处理流程中，使用异步提交来提高性能，最后使用同步提交来保证位移提交成功。</p><h2 id="提交特定的偏移量"><a href="#提交特定的偏移量" class="headerlink" title="提交特定的偏移量"></a>提交特定的偏移量</h2><p>一般提交偏移量的频率与处理消息批次的频率是一样的。如果想要更频繁地提交怎么办？如果 poll() 方法返回一大批数据，为了避免因再均衡引起的重复处理整批消息，想要在批次中间提交偏移量该怎么办？</p><p>这种情况无法通过调用 commitSync() 或 commitAsync() 来实现，只会提交最后一个偏移量，而此时该批次里的消息还没有处理完。</p><p>KafkaConsumer API 允许在调用 commitSync() 和 commitAsync() 方法时传进去希望提交的分区和偏移量的 map。因为消费者可能不只读取一个分区，需要跟踪所有分区的偏移量，所以在这个层面上控制偏移量的提交会让代码变复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录分区的 offset 信息</span></div><div class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        System.out.printf(<span class="string">"topic=%s, partition=%s, offset=%d, customer=%s, country=%s"</span>,</div><div class="line">            record.topic(), record.partition(), record.offset(), </div><div class="line">            record.key(), record.value());</div><div class="line"></div><div class="line">        <span class="comment">// 省略消息处理逻辑 ...</span></div><div class="line"></div><div class="line">        <span class="comment">// 记录分区的 offset</span></div><div class="line">        currentOffsets.put(</div><div class="line">            <span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">            <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>, <span class="string">"no metadata"</span>)</div><div class="line">        );</div><div class="line"></div><div class="line">        <span class="comment">// 最多每处理 1000 条记录就提交一次偏移量</span></div><div class="line">        <span class="keyword">if</span> (count % <span class="number">1000</span> == <span class="number">0</span>)</div><div class="line">            consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        count++;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h1><p>消费者在退出和进行分区再均衡之前，如果消费者知道要失去对一个分区的所有权，它可能需要提交最后一个已处理记录的偏移量。KafakConsumer API 可以在消费者新增分区或者失去分区时进行处理，在调用 subscribe() 方法时传入 ConsumerRebalanceListener 对象，该对象有两个方法：</p><ul><li>public void onPartitionRevoked(Collection partitions): 在消费者停止消费消费后，在再均衡开始前调用。</li><li>public void onPartitionAssigned(Collection partitions): 在分区分配给消费者后，在消费者开始读取消息前调用。</li></ul><p>下面来看一个的例子，在消费者失去某个分区时提交 offset，以便其他消费者可以接着消费消息并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 记录分区的 offset 信息</span></div><div class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleRebalance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果发生再均衡，即将失去分区所有权时提交偏移量。</span></div><div class="line">    <span class="comment">// 提交的是最近处理过的偏移量，而不是批次中还在处理的最后一个偏移量。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Lost partitions in rebalance. Committing current offsets:"</span> </div><div class="line">            + currentOffsets);</div><div class="line">        consumer.commitSync(currentOffsets);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 把 ConsumerRebalanceListener 对象传给 subscribe() 方法</span></div><div class="line">    consumer.subscribe(topics, <span class="keyword">new</span> HandleRebalance());</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line"></div><div class="line">            currentOffsets.put(</div><div class="line">                <span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">                <span class="keyword">new</span> OffsetAndMetadata(record.offset()+<span class="number">1</span>, <span class="string">"no metadata"</span>)</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">    <span class="comment">// ignore</span></div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    log.error(<span class="string">"Unexpected error"</span>, e);</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        consumer.commitSync(currentOffsets);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        consumer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="从指定位移开始消费"><a href="#从指定位移开始消费" class="headerlink" title="从指定位移开始消费"></a>从指定位移开始消费</h1><p>除了读取最近一次提交的位置开始消费数据，有时候也需要从特定的偏移量处开始读取消息。</p><p>如果想从分区起始位置开始消费，可以使用 seekToBeginning(TopicPartition tp)；如果想从分区的最末端消费最新的消息，可以使用 seekToEnd(TopicPartition tp)。Kafka 还支持从指定 offset 处开始消费。最典型的一个是：offset 维护在其他系统（例如数据库）中，并且以其他系统的值为准。</p><p>考虑下面的场景：从 Kafka 中读取消息进行处理，最后把结果写入数据库，可能会按如下逻辑处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), </div><div class="line">            record.offset());</div><div class="line">        processRecord(record);</div><div class="line">        storeRecordInDB(record);</div><div class="line">        consumer.commitAsync(currentOffsets);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>看似正确的逻辑要注意的是，在持久化到数据库成功后，提交位移到 Kafka 可能会失败，出现不一致的情况，那么这可能会导致消息会重复处理。对于这种情况，我们需要将持久化到数据库与提交 offset 实现为原子性操作，最简单的做法，在保存记录到数据库的同时保存 offset 信息，在消费者开始消费时指定数据库的 offset 开始消费。</p><p>只需要通过 seek() 来指定分区位移开始消费即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveOffsetsOnRebalance</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在分区被回收前提交数据库事务，保存消费的记录和位移</span></div><div class="line">        commitDBTransaction();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</div><div class="line">        <span class="comment">// 在开始消费前，从数据库中获取分区的位移，使用 seek() 指定开始消费的偏移量</span></div><div class="line">        <span class="keyword">for</span>(TopicPartition partition: partitions)</div><div class="line">            consumer.seek(partition, getOffsetFromDB(partition));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">consumer.subscribe(topics, <span class="keyword">new</span> SaveOffsetOnRebalance(consumer));</div><div class="line"><span class="comment">// 调用一次 poll() 方怯，让消费者加入到消费者群组里，并获取分配到的分区</span></div><div class="line">consumer.poll(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 然后马上调用 seek() 方法定位分区的偏移量。 </span></div><div class="line"><span class="comment">// seek() 方法只更新我们正在使用的位置，在下一次调用 poll() 时就可以获得正确的消息。</span></div><div class="line"><span class="comment">// 如果 seek() 发生错误, poll() 就会抛出异常。</span></div><div class="line"><span class="keyword">for</span> (TopicPartition partition: consumer.assignment())</div><div class="line">    consumer.seek(partition, getOffsetFromDB(partition));</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">        processRecord(record);</div><div class="line">        <span class="comment">// 保存记录结果</span></div><div class="line">        storeRecordInDB(record);</div><div class="line">        <span class="comment">// 保存位移信息</span></div><div class="line">        storeOffsetInDB(record.topic(), record.partition(), record.offset());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 提交数据库事务</span></div><div class="line">    commitDBTransaction();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="优雅退出"><a href="#优雅退出" class="headerlink" title="优雅退出"></a>优雅退出</h1><p>一般情况下，在主线程中循环 poll() 消息并进行处理。当需要退出循环时，使用另一个线程调用 consumer.wakeup()，会使得 poll() 抛出 WakeupException。如果主线程正在处理消息，那么在下一次主线程调用 poll() 时会抛出异常。样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注册 JVM 关闭时的回调，当 JVM 关闭时调用</span></div><div class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Starting exit..."</span>);</div><div class="line">        <span class="comment">// 调用消费者的 wakeup 方法通知主线程退出</span></div><div class="line">        consumer.wakeup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 等待主线程退出</span></div><div class="line">            mainThread.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// 消费主线程</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</div><div class="line">    <span class="comment">// ignore</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    consumer.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="消息序列化"><a href="#消息序列化" class="headerlink" title="消息序列化"></a>消息序列化</h1><p>Kafka 生产者将对象序列化成字节数组并发送到服务器，消费者需要将字节数组转换成对象（反序列化）。序列化与反序列化需要匹配，与生产者类似，推荐使用 Avro 序列化方式。</p><h2 id="使用-Avro-反序列化"><a href="#使用-Avro-反序列化" class="headerlink" title="使用 Avro 反序列化"></a>使用 Avro 反序列化</h2><p>样例代码如下（与生产者实现类似）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Properties props = <span class="keyword">new</span> Properties();</div><div class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"broker1:9092,broker2:9092"</span>);</div><div class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"CountryCounter"</span>);</div><div class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</div><div class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"io.confluent.kafka.serializers.KafkaAvroDeserializer"</span>);</div><div class="line">props.put(<span class="string">"schema.registry.url"</span>, schemaUrl);</div><div class="line">String topic = <span class="string">"customerContacts"</span></div><div class="line"></div><div class="line">KafkaConsumer consumer = <span class="keyword">new</span> KafkaConsumer(createConsumerConfig(brokers, groupId, url));</div><div class="line">consumer.subscribe(Collections.singletonList(topic));</div><div class="line"></div><div class="line">System.out.println(<span class="string">"Reading topic:"</span> + topic);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">// 这里使用之前生产者使用的Avro生成的Customer类</span></div><div class="line">    ConsumerRecords&lt;String, Customer&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, Customer&gt; record: records) &#123;</div><div class="line">        System.out.println(<span class="string">"Current customer name is: "</span> + record.value().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    consumer.commitSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h1><p>一般情况下都是使用消费者组（即使只有一个消费者）来消费消息的，这样可以在增加或减少消费者时自动进行分区重平衡，这种方式是推荐的。</p><p>在知道主题和分区的情况下，也可以使用单个消费者来进行消费，需要实现给消费者分配分区，而不是让消费者订阅主题。代码样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取主题下所有的分区</span></div><div class="line">List&lt;PartitionInfo&gt; partitionInfos = consumer.partitionsFor(<span class="string">"topic"</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (partitionInfos != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (PartitionInfo partition : partitionInfos)</div><div class="line">        partitions.add(<span class="keyword">new</span> TopicPartition(partition.topic(), partition.partition()));</div><div class="line">    <span class="comment">// 为消费者指定分区</span></div><div class="line">    consumer.assign(partitions);</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record: records) &#123;</div><div class="line">            <span class="comment">// ...</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        consumer.commitSync();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了需要主动获取分区以及没有分区重平衡，其他的处理逻辑是一样的。需要注意的是，如果添加了新的分区，这个消费者是感知不到的，需要通过 consumer.partitionsFor() 来重新获取分区。</p><hr><p>《Kafka权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/UveOWwz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://zhangslob.github.io/2020/01/05/%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://zhangslob.github.io/2020/01/05/从尾到头打印链表/</id>
    <published>2020-01-05T09:19:25.036Z</published>
    <updated>2020-01-09T03:38:38.576Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十二篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>链表从头到尾输出会比较简单，于是我们很自然的想到把链表中链接节点的指正翻转过来，改变链表的方向，然后就可以从头到尾的输出了。但是该方法会修改原来链表的结构，这应该不是一个好的选择。</p><blockquote><p>在面试中，如果我们打算修改输入的数据，最好先问面试官是否允许修改。</p></blockquote><p>这道题肯定需要遍历链表的，但是遍历肯定是顺序，可是最终需要的是从尾到头，这就是典型的”先进先出“，可以使用栈实现。遍历该链表时，没经过一个节点，便把该节点放入栈中。遍历结束之后，再从栈顶输出所有值。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="解法一【推荐】"><a href="#解法一【推荐】" class="headerlink" title="解法一【推荐】"></a>解法一【推荐】</h2><p>遍历链表，每个链表结点值 push 进栈，最后将栈中元素依次 pop 到 list 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">        <span class="keyword">this</span>.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</div><div class="line">            stack.push(listNode.val);</div><div class="line">            listNode = listNode.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">            res.add(stack.pop());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().printListFromTailToHead(listNode));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>面试官看到使用了栈，会不会手动让你完成栈的实现呢。下面有栈的实现。</p><h2 id="解法二【不推荐】"><a href="#解法二【不推荐】" class="headerlink" title="解法二【不推荐】"></a>解法二【不推荐】</h2><p>利用递归方式：</p><ol><li>若不是链表尾结点，继续递归；</li><li>若是，添加到 list 中。</li></ol><p>这种方式不推荐，当递归层数过多时，容易发生 Stack Overflow。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">if</span> (listNode == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">        addElement(listNode, res);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(ListNode listNode, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (listNode.next != <span class="keyword">null</span>) &#123;</div><div class="line">            addElement(listNode.next, res);</div><div class="line">        &#125;</div><div class="line">        res.add(listNode.val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().printListFromTailToHead(listNode));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>通过遍历实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">        ListNode pre = <span class="keyword">null</span>;</div><div class="line">        ListNode next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</div><div class="line">            next = listNode.next;</div><div class="line">            listNode.next = pre;</div><div class="line">            pre = listNode;</div><div class="line">            listNode = next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(pre.val);</div><div class="line">            pre = pre.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</div><div class="line">        listNode.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</div><div class="line">        listNode.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</div><div class="line">        listNode.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        listNode.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        <span class="keyword">new</span> Solution().printListFromTailToHead(listNode);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>研究了下源码，简单实现了下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.EmptyStackException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2020/1/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 元素数量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elementCount;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 储存数据的数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object[] elementData;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自定义最大数组容量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法，默认大小为10</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 入栈</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> item</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (elementCount + <span class="number">1</span> - elementData.length &gt; <span class="number">0</span>) &#123;</div><div class="line">            grow(elementCount + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        elementData[elementCount++] = item;</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 出栈</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        E item;</div><div class="line">        item = peek();</div><div class="line">        removeElementAt(elementCount - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> elementCount == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 取出数组最右边元素</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = elementCount;</div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (E) elementData[len - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除数组最右边元素</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> index</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> + elementCount);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</div><div class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</div><div class="line">        &#125;</div><div class="line">        elementCount--;</div><div class="line">        elementData[elementCount] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数组长度不够时，为数组扩大空间</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> minCapacity</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">        <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (newCapacity &lt; minCapacity) &#123;</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (newCapacity &gt; MAX_ARRAY_SIZE) &#123;</div><div class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">            &#125;</div><div class="line">            newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</div><div class="line">        &#125;</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JDK源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.util;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</div><div class="line">        addElement(item);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> item;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        E       obj;</div><div class="line">        <span class="keyword">int</span>     len = size();</div><div class="line"></div><div class="line">        obj = peek();</div><div class="line">        removeElementAt(len - <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>     len = size();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> size() - i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>细节满满，想要看更多实现就需要去看<code>Vector</code>的源码了。<code>Vector</code>日常使用的太少了，是线程安全的，但实现同步需要很高的花费，因此访问比<code>ArrayList</code>慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://zhangslob.github.io/2020/01/03/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://zhangslob.github.io/2020/01/03/替换空格/</id>
    <published>2020-01-03T03:03:47.228Z</published>
    <updated>2020-01-03T06:56:40.551Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百一十一篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，将一个字符串中的每个空格替换成 <code>%20</code>。例如，当字符串为 <code>We Are Happy</code>，则经过替换之后的字符串为 <code>We%20Are%20Happy</code>。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>其实看到这道题，我最开始想到的就是字符串的replace方法，这显然不是面试官想要的答案，我就去看了下实现源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Pattern.compile(target.toString(), Pattern.LITERAL).matcher(</div><div class="line">            <span class="keyword">this</span>).replaceAll(Matcher.quoteReplacement(replacement.toString()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>原来是用正则去匹配再替换的，再去看看正则替换的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span> </span>&#123;</div><div class="line">    reset();</div><div class="line">    <span class="keyword">boolean</span> result = find();</div><div class="line">    <span class="keyword">if</span> (result) &#123;</div><div class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            appendReplacement(sb, replacement);</div><div class="line">            result = find();</div><div class="line">        &#125; <span class="keyword">while</span> (result);</div><div class="line">        appendTail(sb);</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> text.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>发现用的是<code>StringBuffer</code>，保证线程安全。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>好了，下面步入正题，创建 <code>StringBuilder</code>，遍历原字符串，遇到非空格，直接 append 到 <code>StringBuilder</code> 中，遇到空格则将 <code>%20</code> append 到 <code>StringBuilder</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str == None || str.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> str;</div><div class="line">        &#125;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> len = str.length();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</div><div class="line">            <span class="keyword">char</span> ch = str.charAt(i);</div><div class="line">            sb.append(ch == <span class="string">' '</span> ? <span class="string">"%20"</span> : ch);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"We Are Happy"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().replaceSpace(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="解法三（推荐）"><a href="#解法三（推荐）" class="headerlink" title="解法三（推荐）"></a>解法三（推荐）</h2><p>先遍历原字符串，遇到空格，则在原字符串末尾 <code>append</code> 任意两个字符，如两个空格。</p><p>用指针 <code>p</code> 指向原字符串末尾，<code>q</code> 指向现字符串末尾，<code>p</code>, <code>q</code> 从后往前遍历，当 <code>p</code> 遇到空格，<code>q</code> 位置依次要 <code>append</code> ‘02%’，若不是空格，直接 <code>append</code> <code>p</code> 指向的字符。</p><blockquote><p>🤔思路扩展<br>在合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(str);</div><div class="line">        <span class="keyword">int</span> len = stringBuilder.length();</div><div class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(stringBuilder);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (strBuilder.charAt(i) == <span class="string">' '</span>) &#123;</div><div class="line">                strBuilder.append(<span class="string">"  "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> p = len - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> q = strBuilder.length() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">char</span> ch = stringBuilder.charAt(p--);</div><div class="line">            <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'0'</span>);</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'2'</span>);</div><div class="line">                strBuilder.setCharAt(q--, <span class="string">'%'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                strBuilder.setCharAt(q--, ch);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strBuilder.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"We Are Happy"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().replaceSpace(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replace_space</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(s, str) <span class="keyword">or</span> len(s) &lt;= <span class="number">0</span> <span class="keyword">or</span> s <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span></div><div class="line"></div><div class="line">        space_num = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</div><div class="line">                space_num += <span class="number">1</span></div><div class="line"></div><div class="line">        new_str_len = len(s) + space_num * <span class="number">2</span></div><div class="line">        new_str = new_str_len * [<span class="keyword">None</span>]</div><div class="line">        index_of_origin, index_of_new = len(s) - <span class="number">1</span>, new_str_len - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> index_of_new &gt;= <span class="number">0</span> <span class="keyword">and</span> index_of_origin &lt;= index_of_new:</div><div class="line">            <span class="keyword">if</span> s[index_of_origin] == <span class="string">' '</span>:</div><div class="line">                new_str[index_of_new - <span class="number">2</span>: index_of_new + <span class="number">1</span>] = [<span class="string">'%'</span>, <span class="string">'2'</span>, <span class="string">'0'</span>]</div><div class="line">                index_of_new -= <span class="number">3</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                new_str[index_of_new] = s[index_of_origin]</div><div class="line">                index_of_new -= <span class="number">1</span></div><div class="line">            index_of_origin -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(new_str)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().replace_space(<span class="string">'We Are Happy'</span>)</div><div class="line">    print(s)</div></pre></td></tr></table></figure><blockquote><p>看着都头大</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十一篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>MapReduce例子</title>
    <link href="https://zhangslob.github.io/2019/12/30/MapReduce%E4%BE%8B%E5%AD%90/"/>
    <id>https://zhangslob.github.io/2019/12/30/MapReduce例子/</id>
    <published>2019-12-30T12:13:16.755Z</published>
    <updated>2019-12-30T12:57:07.019Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/gHMms0X.jpg" alt=""></p><pre><code>这是崔斯特的第一百一十篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><p>最近在学习《Hive编程指南》，尝试动手了第一个MapReduce案例，记录下。</p><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.StringTokenizer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/29.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorldCount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable ONE = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</div><div class="line">        <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">            String line = value.toString();</div><div class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(line);</div><div class="line">            <span class="keyword">while</span> (tokenizer.hasMoreTokens()) &#123;</div><div class="line">                word.set(tokenizer.nextToken());</div><div class="line">                context.write(value, ONE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (IntWritable val : values) &#123;</div><div class="line">                sum += val.get();</div><div class="line">            &#125;</div><div class="line">            context.write(key, <span class="keyword">new</span> IntWritable(sum));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">        Job job = <span class="keyword">new</span> Job(conf, <span class="string">"world count"</span>);</div><div class="line">        job.setOutputKeyClass(Text.class);</div><div class="line">        job.setOutputValueClass(IntWritable.class);</div><div class="line"></div><div class="line">        job.setMapperClass(Map.class);</div><div class="line">        job.setReducerClass(Reduce.class);</div><div class="line"></div><div class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</div><div class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</div><div class="line"></div><div class="line">        job.waitForCompletion(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分别继承<code>Mapper</code>和<code>Reducer</code>这两个方法，重写自己的处理逻辑，最后设置map和reduce。</p><h1 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h1><p>同样的功能用HQL来写会简单很多：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> docs (line <span class="keyword">STRING</span>);</div><div class="line"></div><div class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> INPATH <span class="string">'docs'</span> OVERWRITE <span class="keyword">INTO</span> <span class="keyword">TABLE</span> docs;</div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> world_counts <span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> world, <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> <span class="keyword">count</span></div><div class="line"><span class="keyword">FROM</span> (</div><div class="line">    <span class="keyword">SELECT</span> explode(<span class="keyword">split</span>(line, <span class="string">'\s'</span>)) <span class="keyword">AS</span> word</div><div class="line">    <span class="keyword">FROM</span> docs</div><div class="line">) w</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> word</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> word;</div></pre></td></tr></table></figure><p>so simple</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gHMms0X.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百一十篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://zhangslob.github.io/2019/12/29/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://zhangslob.github.io/2019/12/29/二维数组中的查找/</id>
    <published>2019-12-29T06:32:25.513Z</published>
    <updated>2019-12-29T07:31:45.586Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零九篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>例如下面的二维数组，如果查找7，返回true，查找5，返回false。</p><table><thead><tr><th>1</th><th>2</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>9</td><td>12</td></tr><tr><td>4</td><td>7</td><td>10</td><td>13</td></tr><tr><td>6</td><td>8</td><td>11</td><td>15</td></tr></tbody></table><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>寻找目标数字b，从数组中选一个数字a，如果<code>a=b</code>，结束查找；如果<code>a&gt;b</code>，那么接下来查找的范围就是a的左边或上边；如果<code>a&lt;b</code>，那么接下来搜索范围就是右边或下边。</p><p>当我们需要解决一个复杂的问题时，一个很有效的方法就是从一个具体的问题入手。本题可以从查找数字7入手，一步步分析过程。如果我们在二维数组中间随机选一个数字，那么下次搜索范围就是两个区域，而且有重叠。如果从数组的某一个角上开始搜索，就不会遇到这个问题。</p><p>比如从数组右上方开始，</p><ol><li>a=9，b=7，<code>a&gt;b</code>，接着查找左边和上边，由于没有上边，所以只能查找左边，也就是1、2、8这三列</li><li>a=8，<code>a&gt;b</code>，接着查找左边和上边，因为没有上边，只能接着找左边，也就是1，2这两列</li><li>a=2，<code>a&lt;b</code>，接着就是右边和下边，右边已经查找过，所以接下来就是一直往下查找，也就是1、2这两列的下方</li><li>a=4，<code>a&lt;b</code>，接着查找1、2这两列的下面两行</li><li>a=7，<code>a=b</code>，结束查找。</li></ol><p><img src="https://i.imgur.com/2rt2LSr.png" alt=""></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>从二维数组的右上方开始查找：</p><ul><li>若元素值等于 <code>target</code>，返回 <code>true</code>；</li><li>若元素值大于 <code>target</code>，砍掉这一列，即 <code>--j</code>；</li><li>若元素值小于 <code>target</code>，砍掉这一行，即 <code>++i</code>。</li></ul><p>也可以从二维数组的左下方开始查找，以下代码使用左下方作为查找的起点。</p><p>注意，不能选择左上方或者右下方的数字，因为这样无法缩小查找的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> rows = array.length;</div><div class="line">        <span class="keyword">int</span> columns = array[<span class="number">0</span>].length;</div><div class="line">        <span class="keyword">int</span> i = rows - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; columns) &#123;</div><div class="line">            <span class="keyword">if</span> (array[i][j] == target) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (array[i][j] &lt; target) &#123;</div><div class="line">                ++j;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                --i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</div><div class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</div><div class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</div><div class="line">                &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</div><div class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">boolean</span> res = <span class="keyword">new</span> Solution().find(<span class="number">7</span>, arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如果是我自己去写这道题的话，肯定想不出这样的方法，可能就是遍历所有数字，这肯定不是面试官要问的。看了书中介绍的方法，分析过程确实很重要，一步步去寻找规律。我想起了高中数学的<code>数列</code>，老师常说“数列就是列数，如果不知道规律，就多写几个例子”。对于现在的这种算法题，一定要多试几个例子，从中找到规律。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零九篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>找出数组中重复的数字</title>
    <link href="https://zhangslob.github.io/2019/12/26/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://zhangslob.github.io/2019/12/26/找出数组中重复的数字/</id>
    <published>2019-12-26T08:44:27.000Z</published>
    <updated>2019-12-27T03:13:32.809Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零八篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 <code>7</code> 的数组 <code>{2, 3, 1, 0, 2, 5, 3}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>排序后，顺序扫描，判断是否有重复，时间复杂度为 <code>O(n²)</code>。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>利用哈希表，遍历数组，如果哈希表中没有该元素，则存入哈希表中，否则返回重复的元素。时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>。</p><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>长度为 <code>n</code>，元素的数值范围也为 <code>n</code>，如果没有重复元素，那么数组每个下标对应的值与下标相等。</p><p>从头到尾遍历数组，当扫描到下标 <code>i</code> 的数字 <code>nums[i]</code>：</p><ul><li>如果等于 <code>i</code>，继续向下扫描；</li><li>如果不等于 <code>i</code>，拿它与第 <code>nums[i]</code> 个数进行比较，如果相等，说明有重复值，返回 <code>nums[i]</code>。如果不相等，就把第 <code>i</code> 个数 和第 <code>nums[i]</code> 个数交换。重复这个比较交换的过程。</li></ul><p>此算法时间复杂度为 <code>O(n)</code>，因为每个元素最多只要两次交换，就能确定位置。空间复杂度为 <code>O(1)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (array[i] != i) &#123;</div><div class="line">                <span class="keyword">if</span> (array[i] == array[array[i]]) &#123;</div><div class="line">                    <span class="keyword">return</span> array[i];</div><div class="line">                &#125;</div><div class="line">                swap(array, i, array[i]);</div><div class="line">                System.out.println(Arrays.toString(array));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中有一个两重循环，但每个数字最多只要交换两次就可以找到属于自己的位置，因此时间复杂度是O(n)。不需要额外分配内存，空间复杂度是O(1)。</p><p>Output<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1, 3, 2, 0, 2, 5, 3]</div><div class="line">[3, 1, 2, 0, 2, 5, 3]</div><div class="line">[0, 1, 2, 3, 2, 5, 3]</div><div class="line">2</div></pre></td></tr></table></figure></p><p>以数组[2, 3, 1, 0, 2, 5, 3]为例来分析找到重复数字的步骤：</p><ol><li>数组的第 0 个数字（从 0 开始计数，和数组的下标保持一致）是 2，与它的下标不相等，于是把它和下标为 2 的数字 1 交换。交换之后的数组是[1, 3, 2, 0, 2, 5, 3]。</li><li>此时第 0 个数字是 1，仍然与它的下标不相等，继续把它和下标为 1 的数字 3 交换，得到数组[3, 1, 2, 0, 2, 5, 3]</li><li>接下来继续交换第 0 个数字 3 和第 3 个数字 0，得到数组[0, 1, 2, 3, 2, 5, 3]。</li><li>此时第 0 个数字的数值为 0，接着扫描下一个数字。在接下来的几个数字中，下标为 1，2，3 的三个数字分别为 1，2，3 它们的下标和数值都分别相等，因此不需要做任何操作。</li><li>接下来扫描到下标为 4 的数字 2。由于它的数值与它的下标不相等，再比较它和下标为 2 的数字。注意到此时数组中下标为 2 的数字也是 2，也就是数字在下标为 2 和下标为 4 的两个位置都出现了，因此找到一个重复的数字。</li></ol><p>本题关键是：<strong>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内并且有重复</strong>，这说明数组是可以排序的，把每个数字交换到自己应该在的位置，排序时就能找到重复字段。理想状态下的情况：[0, 1, 2, 3, 4, x, x, x]</p><p>Python解法更简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</div><div class="line">        <span class="keyword">while</span> arr[i] != i:</div><div class="line">            tmp = arr[i]</div><div class="line">            <span class="keyword">if</span> tmp == arr[tmp]:</div><div class="line">                <span class="keyword">return</span> tmp</div><div class="line">            arr[i], arr[tmp] = arr[tmp], arr[i]</div><div class="line">            print(arr)</div><div class="line"></div><div class="line"></div><div class="line">print(solution([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]))</div></pre></td></tr></table></figure><h1 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n+1</code> 的数组里的所有数字都在 <code>1</code> 到 <code>n</code> 的范围内，数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 <code>8</code> 的数组 <code>{2, 3, 5, 4, 3, 2, 6, 7}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h3><p>创建长度为 <code>n+1</code> 的辅助数组，把原数组的元素复制到辅助数组中。如果原数组被复制的数是 <code>m</code>，则放到辅助数组第 <code>m</code> 个位置。这样很容易找出重复元素。空间复杂度为 <code>O(n)</code>。</p><h3 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h3><p>数组元素的取值范围是 <code>[1, n]</code>，对该范围对半划分，分成 <code>[1, middle]</code>, <code>[middle+1, n]</code>。计算数组中有多少个(count)元素落在 <code>[1, middle]</code> 区间内，如果 <code>count</code> 大于 <code>middle</code>，那么说明这个范围内有重复元素，否则在另一个范围内。继续对这个范围对半划分，继续统计区间内元素数量。</p><p>时间复杂度 O(n * log n)，空间复杂度 O(1)。</p><p>注意，此方法无法找出所有重复的元素。如果左右半区同时存在重复值，先算哪个半区就会先得到哪边的重复值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</div><div class="line">            <span class="keyword">int</span> middle = start + ((end - start) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> count = countRange(array, start, middle);</div><div class="line">            <span class="keyword">if</span> (end == start) &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> start;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; (middle - start) + <span class="number">1</span>) &#123;</div><div class="line">                    end = middle;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= start &amp;&amp; i &lt;= end) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>按照二分法查找的思路，如果输出长度为<code>n</code>的数组，那么函数<code>countRange</code>将被调用<code>O(log n)</code>次，每次需要<code>O(n)</code>时间，因此总的时间复杂度是<code>O(nlog n)</code> ，空间复杂度是<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零八篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>大数据学习路线</title>
    <link href="https://zhangslob.github.io/2019/12/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://zhangslob.github.io/2019/12/06/大数据学习路线/</id>
    <published>2019-12-06T02:34:57.481Z</published>
    <updated>2019-12-06T02:40:07.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><pre><code>这是崔斯特的第一百零七篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="大数据处理流程"><a href="#大数据处理流程" class="headerlink" title="大数据处理流程"></a>大数据处理流程</h1><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><p>上图是一个简化的大数据处理流程图，大数据处理的主要流程包括数据收集、数据存储、数据处理、数据应用等主要环节。下面我们逐一对各个环节所需要的技术栈进行讲解：</p><h2 id="1-1-数据收集"><a href="#1-1-数据收集" class="headerlink" title="1.1 数据收集"></a>1.1 数据收集</h2><p>大数据处理的第一步是数据的收集。现在的中大型项目通常采用微服务架构进行分布式部署，所以数据的采集需要在多台服务器上进行，且采集过程不能影响正常业务的开展。基于这种需求，就衍生了多种日志收集工具，如 Flume 、Logstash、Kibana 等，它们都能通过简单的配置完成复杂的数据收集和数据聚合。</p><h2 id="1-2-数据存储"><a href="#1-2-数据存储" class="headerlink" title="1.2 数据存储"></a>1.2 数据存储</h2><p>收集到数据后，下一个问题就是：数据该如何进行存储？通常大家最为熟知是 MySQL、Oracle 等传统的关系型数据库，它们的优点是能够快速存储结构化的数据，并支持随机访问。但大数据的数据结构通常是半结构化（如日志数据）、甚至是非结构化的（如视频、音频数据），为了解决海量半结构化和非结构化数据的存储，衍生了 Hadoop HDFS 、KFS、GFS 等分布式文件系统，它们都能够支持结构化、半结构和非结构化数据的存储，并可以通过增加机器进行横向扩展。</p><p>分布式文件系统完美地解决了海量数据存储的问题，但是一个优秀的数据存储系统需要同时考虑数据存储和访问两方面的问题，比如你希望能够对数据进行随机访问，这是传统的关系型数据库所擅长的，但却不是分布式文件系统所擅长的，那么有没有一种存储方案能够同时兼具分布式文件系统和关系型数据库的优点，基于这种需求，就产生了 HBase、MongoDB。</p><h2 id="1-3-数据分析"><a href="#1-3-数据分析" class="headerlink" title="1.3 数据分析"></a>1.3 数据分析</h2><p>大数据处理最重要的环节就是数据分析，数据分析通常分为两种：批处理和流处理。</p><ul><li><strong>批处理</strong>：对一段时间内海量的离线数据进行统一的处理，对应的处理框架有 Hadoop MapReduce、Spark、Flink 等；</li><li><strong>流处理</strong>：对运动中的数据进行处理，即在接收数据的同时就对其进行处理，对应的处理框架有 Storm、Spark Streaming、Flink Streaming 等。</li></ul><p>批处理和流处理各有其适用的场景，时间不敏感或者硬件资源有限，可以采用批处理；时间敏感和及时性要求高就可以采用流处理。随着服务器硬件的价格越来越低和大家对及时性的要求越来越高，流处理越来越普遍，如股票价格预测和电商运营数据分析等。</p><p>上面的框架都是需要通过编程来进行数据分析，那么如果你不是一个后台工程师，是不是就不能进行数据的分析了？当然不是，大数据是一个非常完善的生态圈，有需求就有解决方案。为了能够让熟悉 SQL 的人员也能够进行数据的分析，查询分析框架应运而生，常用的有 Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix 等。这些框架都能够使用标准的 SQL 或者 类 SQL 语法灵活地进行数据的查询分析。这些 SQL 经过解析优化后转换为对应的作业程序来运行，如 Hive 本质上就是将 SQL 转换为 MapReduce 作业，Spark SQL 将 SQL 转换为一系列的 RDDs 和转换关系（transformations），Phoenix 将 SQL 查询转换为一个或多个 HBase Scan。</p><h2 id="1-4-数据应用"><a href="#1-4-数据应用" class="headerlink" title="1.4 数据应用"></a>1.4 数据应用</h2><p>数据分析完成后，接下来就是数据应用的范畴，这取决于你实际的业务需求。比如你可以将数据进行可视化展现，或者将数据用于优化你的推荐算法，这种运用现在很普遍，比如短视频个性化推荐、电商商品推荐、头条新闻推荐等。当然你也可以将数据用于训练你的机器学习模型，这些都属于其他领域的范畴，都有着对应的框架和技术栈进行处理，这里就不一一赘述。</p><h2 id="1-5-其他框架"><a href="#1-5-其他框架" class="headerlink" title="1.5 其他框架"></a>1.5 其他框架</h2><p>上面是一个标准的大数据处理流程所用到的技术框架。但是实际的大数据处理流程比上面复杂很多，针对大数据处理中的各种复杂问题分别衍生了各类框架：</p><ul><li>单机的处理能力都是存在瓶颈的，所以大数据框架都是采用集群模式进行部署，为了更方便的进行集群的部署、监控和管理，衍生了 Ambari、Cloudera Manager 等集群管理工具；</li><li>想要保证集群高可用，需要用到 ZooKeeper ，ZooKeeper 是最常用的分布式协调服务，它能够解决大多数集群问题，包括首领选举、失败恢复、元数据存储及其一致性保证。同时针对集群资源管理的需求，又衍生了 Hadoop YARN ;</li><li>复杂大数据处理的另外一个显著的问题是，如何调度多个复杂的并且彼此之间存在依赖关系的作业？基于这种需求，产生了 Azkaban 和 Oozie 等工作流调度框架；</li><li>大数据流处理中使用的比较多的另外一个框架是 Kafka，它可以用于消峰，避免在秒杀等场景下并发数据对流处理程序造成冲击；</li><li>另一个常用的框架是 Sqoop ，主要是解决了数据迁移的问题，它能够通过简单的命令将关系型数据库中的数据导入到 HDFS 、Hive 或 HBase 中，或者从 HDFS 、Hive 导出到关系型数据库上。</li></ul><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>介绍完大数据框架，接着就可以介绍其对应的学习路线了，主要分为以下几个方面：</p><h2 id="2-1-语言基础"><a href="#2-1-语言基础" class="headerlink" title="2.1 语言基础"></a>2.1 语言基础</h2><h3 id="1-Java"><a href="#1-Java" class="headerlink" title="1.  Java"></a>1.  Java</h3><p>大数据框架大多采用 Java 语言进行开发，并且几乎全部的框架都会提供 Java API 。Java 是目前比较主流的后台开发语言，所以网上免费的学习资源也比较多。如果你习惯通过书本进行学习，这里推荐以下入门书籍：</p><ul><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="external">《Java 编程的逻辑》</a>：这里一本国人编写的系统入门 Java 的书籍，深入浅出，内容全面；</li><li>《Java 核心技术》：目前最新的是第 10 版，有<a href="https://book.douban.com/subject/26880667/" target="_blank" rel="external">卷一</a> 和<a href="https://book.douban.com/subject/27165931/" target="_blank" rel="external">卷二</a> 两册，卷二可以选择性阅读，因为其中很多章节的内容在实际开发中很少用到。</li></ul><p>目前大多数框架要求 Java 版本至少是 1.8，这是由于 Java 1.8 提供了函数式编程，使得可以用更精简的代码来实现之前同样的功能，比如你调用 Spark API，使用 1.8 可能比 1.7 少数倍的代码，所以这里额外推荐阅读 <a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8 实战》</a> 这本书籍。</p><h3 id="2-Scala"><a href="#2-Scala" class="headerlink" title="2. Scala"></a>2. Scala</h3><p>Scala 是一门综合了面向对象和函数式编程概念的静态类型的编程语言，它运行在 Java 虚拟机上，可以与所有的 Java 类库无缝协作，著名的 Kafka 就是采用 Scala 语言进行开发的。</p><p>为什么需要学习 Scala 语言 ？ 这是因为当前最火的计算框架 Flink 和 Spark 都提供了 Scala 语言的接口，使用它进行开发，比使用 Java 8 所需要的代码更少，且 Spark 就是使用 Scala 语言进行编写的，学习 Scala 可以帮助你更深入的理解 Spark。同样的，对于习惯书本学习的小伙伴，这里推荐两本入门书籍：</p><ul><li><a href="https://book.douban.com/subject/27093751/" target="_blank" rel="external">《快学 Scala(第 2 版)》</a> </li><li><a href="https://book.douban.com/subject/27591387/" target="_blank" rel="external">《Scala 编程 (第 3 版)》</a> </li></ul><blockquote><p>这里说明一下，如果你的时间有限，不一定要学完 Scala 才去学习大数据框架。Scala 确实足够的精简和灵活，但其在语言复杂度上略大于 Java，例如隐式转换和隐式参数等概念在初次涉及时会比较难以理解，所以你可以在了解 Spark 后再去学习 Scala，因为类似隐式转换等概念在 Spark 源码中有大量的运用。</p></blockquote><h2 id="2-2-Linux-基础"><a href="#2-2-Linux-基础" class="headerlink" title="2.2 Linux 基础"></a>2.2 Linux 基础</h2><p>通常大数据框架都部署在 Linux 服务器上，所以需要具备一定的 Linux 知识。Linux 书籍当中比较著名的是 《鸟哥私房菜》系列，这个系列很全面也很经典。但如果你希望能够快速地入门，这里推荐<a href="https://www.linuxprobe.com/" target="_blank" rel="external">《Linux 就该这么学》</a>，其网站上有免费的电子书版本。</p><h2 id="2-3-构建工具"><a href="#2-3-构建工具" class="headerlink" title="2.3  构建工具"></a>2.3  构建工具</h2><p>这里需要掌握的自动化构建工具主要是 Maven。Maven 在大数据场景中使用比较普遍，主要在以下三个方面：</p><ul><li>管理项目 JAR 包，帮助你快速构建大数据应用程序；</li><li>不论你的项目是使用 Java 语言还是 Scala 语言进行开发，提交到集群环境运行时，都需要使用 Maven 进行编译打包；</li><li>大部分大数据框架使用 Maven 进行源码管理，当你需要从其源码编译出安装包时，就需要使用到 Maven。</li></ul><h2 id="2-4-框架学习"><a href="#2-4-框架学习" class="headerlink" title="2.4 框架学习"></a>2.4 框架学习</h2><h3 id="1-框架分类"><a href="#1-框架分类" class="headerlink" title="1. 框架分类"></a>1. 框架分类</h3><p>上面我们介绍了很多大数据框架，这里进行一下分类总结：</p><p><strong>日志收集框架</strong>：Flume 、Logstash、Kibana</p><p><strong>分布式文件存储系统</strong>：Hadoop HDFS</p><p><strong>数据库系统</strong>：Mongodb、HBase</p><p><strong>分布式计算框架</strong>：</p><ul><li>批处理框架：Hadoop MapReduce</li><li>流处理框架：Storm</li><li>混合处理框架：Spark、Flink</li></ul><p><strong>查询分析框架</strong>：Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix </p><p><strong>集群资源管理器</strong>：Hadoop YARN</p><p><strong>分布式协调服务</strong>：Zookeeper</p><p><strong>数据迁移工具</strong>：Sqoop</p><p><strong>任务调度框架</strong>：Azkaban、Oozie</p><p><strong>集群部署和监控</strong>：Ambari、Cloudera Manager</p><p>上面列出的都是比较主流的大数据框架，社区都很活跃，学习资源也比较丰富。建议从 Hadoop 开始入门学习，因为它是整个大数据生态圈的基石，其它框架都直接或者间接依赖于 Hadoop 。接着就可以学习计算框架，Spark 和 Flink 都是比较主流的混合处理框架，Spark 出现得较早，所以其应用也比较广泛。 Flink 是当下最火热的新一代的混合处理框架，其凭借众多优异的特性得到了众多公司的青睐。两者可以按照你个人喜好或者实际工作需要进行学习。</p><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/HADOOP-ECOSYSTEM-Edureka.png" alt=""></p><blockquote><p><em>图片引用自</em> ：<em><a href="https://www.edureka.co/blog/hadoop-ecosystem" target="_blank" rel="external">https://www.edureka.co/blog/hadoop-ecosystem</a></em></p></blockquote><p>至于其它框架，在学习上并没有特定的先后顺序，如果你的学习时间有限，建议初次学习时候，同一类型的框架掌握一种即可，比如日志收集框架就有很多种，初次学习时候只需要掌握一种，能够完成日志收集的任务即可，之后工作上有需要可以再进行针对性地学习。</p><h3 id="2-学习资料"><a href="#2-学习资料" class="headerlink" title="2.  学习资料"></a>2.  学习资料</h3><p>大数据最权威和最全面的学习资料就是官方文档。热门的大数据框架社区都比较活跃、版本更新迭代也比较快，所以其出版物都明显滞后于其实际版本，基于这个原因采用书本学习不是一个最好的方案。比较庆幸的是，大数据框架的官方文档都写的比较好，内容完善，重点突出，同时都采用了大量配图进行辅助讲解。当然也有一些优秀的书籍历经时间的检验，至今依然很经典，这里列出部分个人阅读过的经典书籍：</p><ul><li><a href="https://book.douban.com/subject/27115351/" target="_blank" rel="external">《hadoop 权威指南 (第四版)》</a> 2017 年</li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="external">《Kafka 权威指南》</a> 2017 年</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="external">《从 Paxos 到 Zookeeper  分布式一致性原理与实践》</a>  2015 年</li><li><a href="https://book.douban.com/subject/26649141/" target="_blank" rel="external">《Spark 技术内幕  深入解析 Spark 内核架构设计与实现原理》</a> 2015 年</li><li><a href="https://book.douban.com/subject/27035127/" target="_blank" rel="external">《Spark.The.Definitive.Guide》</a> 2018 年</li><li><a href="https://book.douban.com/subject/10748460/" target="_blank" rel="external">《HBase 权威指南》</a> 2012 年</li><li><a href="https://book.douban.com/subject/25791255/" target="_blank" rel="external">《Hive 编程指南》</a> 2013 年</li></ul><h3 id="3-视频学习资料"><a href="#3-视频学习资料" class="headerlink" title="3. 视频学习资料"></a>3. 视频学习资料</h3><p>上面我推荐的都是书籍学习资料，很少推荐视频学习资料，这里说明一下原因：因为书籍历经时间的考验，能够再版的或者豆瓣等平台评价高的证明都是被大众所认可的，从概率的角度上来说，其必然更加优秀，不容易浪费大家的学习时间和精力，所以我个人更倾向于官方文档或者书本的学习方式，而不是视频。因为视频学习资料，缺少一个公共的评价平台和完善的评价机制，所以其质量良莠不齐。但是视频任然有其不可替代的好处，学习起来更直观、印象也更深刻，所以对于习惯视频学习的小伙伴，这里我各推荐一个免费的和付费的视频学习资源，大家按需选择：</p><ul><li>免费学习资源：尚硅谷大数据学习路线 ——  <a href="http://www.atguigu.com/bigdata_video.shtml#bigdata" target="_blank" rel="external">下载链接</a> \ <a href="https://space.bilibili.com/302417610/" target="_blank" rel="external">在线观看链接</a></li><li>付费学习资源：<a href="https://www.imooc.com/t/2781843" target="_blank" rel="external">慕课网 Michael PK 的系列课程</a></li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>这里推荐一些大数据常用的开发工具：</p><p><strong>Java IDE</strong>：IDEA  和 Eclipse 都可以。从个人使用习惯而言，更倾向于 IDEA ;</p><p><strong>VirtualBox</strong>：在学习过程中，你可能经常要在虚拟机上搭建服务和集群。VirtualBox 是一款开源、免费的虚拟机管理软件，虽然是轻量级软件，但功能很丰富，基本能够满足日常的使用需求；</p><p><strong>MobaXterm</strong>：大数据的框架通常都部署在服务器上，这里推荐使用 MobaXterm 进行连接。同样是免费开源的，支持多种连接协议，支持拖拽上传文件，支持使用插件扩展；</p><p><strong>Translate Man</strong>：一款浏览器上免费的翻译插件 (谷歌和火狐均支持)。它采用谷歌的翻译接口，准确性非常高，支持划词翻译，可以辅助进行官方文档的阅读。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是个人关于大数据的学习心得和路线推荐。本片文章对大数据技术栈做了比较狭义的限定，随着学习的深入，大家也可以把 Python 语言、推荐系统、机器学习等逐步加入到自己的大数据技术栈中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零七篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-394-字符串解码</title>
    <link href="https://zhangslob.github.io/2019/11/28/Leetcode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://zhangslob.github.io/2019/11/28/Leetcode-394-字符串解码/</id>
    <published>2019-11-28T03:46:18.174Z</published>
    <updated>2019-11-28T07:57:01.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><pre><code>这是崔斯特的第一百零六篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</div><div class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</div><div class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</div></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">输入:<span class="string">'3[a2[c]]'</span></div><div class="line">初始化栈: 栈nums 存要重复的次数k,栈str 存字符串</div><div class="line"></div><div class="line">遍历字符串:</div><div class="line">指针指向字符<span class="string">'3'</span>,为数字</div><div class="line">num暂存数字3</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'['</span></div><div class="line">循环次数num入栈nums，空字符串res入栈str</div><div class="line">nums: 3        res: <span class="string">''</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'a'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'a'</span>,res=<span class="string">'a'</span></div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'2'</span>,为数字</div><div class="line">num暂存数字2</div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">'['</span></div><div class="line">num入栈nums,res入栈str</div><div class="line">nums: 3 -&gt; 2    str: <span class="string">''</span> -&gt; <span class="string">'a'</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'c'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'c'</span>,res=<span class="string">'c'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数2</div><div class="line">res = res*2 = <span class="string">'cc'</span></div><div class="line">str弹出栈顶元素<span class="string">'a'</span>与res拼接并入栈:</div><div class="line">res = <span class="string">'a'</span>+<span class="string">'cc'</span>=<span class="string">'acc'</span></div><div class="line">str: <span class="string">''</span> -&gt; <span class="string">'acc'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数3</div><div class="line">res = res*3 = <span class="string">'accaccacc'</span></div><div class="line">str弹出栈顶元素空字符串<span class="string">''</span>与res拼接并入栈:</div><div class="line">res=<span class="string">''</span>+<span class="string">'accaccacc'</span>=<span class="string">'accaccacc'</span></div><div class="line">str: <span class="string">'accaccacc'</span></div><div class="line"></div><div class="line">结束返回res</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>由于重复次数可能大于10，所以暂存数字时要适当处理，如 <code>num*10+当前数字</code></li><li>在c++里可以直接修改拼接字符，但Java不支持运算符重载，可以借助 StringBuilder 或 StringBuffer 类。</li><li>用栈暂存的逻辑与递归基本一致，可以理解为用递归实现栈。</li><li>python没有栈这种数据结构，可以用 list() 数组或双端队列 deque()</li><li>python可以只用一个栈以元组的形式重复次数和字符串，如<code>(num,res)</code></li></ul><h2 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;StringBuilder&gt; str = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</div><div class="line">                str.push(res);</div><div class="line">                nums.push(num);</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">                res = <span class="keyword">new</span> StringBuilder();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</div><div class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.pop(); i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">                    stringBuilder.append(res);</div><div class="line">                &#125;</div><div class="line">                res = str.pop().append(stringBuilder);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (c - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.append(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        stack, res, num = [], <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i.isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(i)</div><div class="line">            <span class="keyword">elif</span> i.isalpha():</div><div class="line">                res += i</div><div class="line">            <span class="keyword">elif</span> i == <span class="string">'['</span>:</div><div class="line">                stack.append((res, num))</div><div class="line">                res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                last_str, this_num = stack.pop()</div><div class="line">                res = last_str + this_num * res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line">c = Solution().decodeString(<span class="string">'3[a2[c]]'</span>)  <span class="comment"># aaabcbc</span></div><div class="line">print(c)</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>发现一种解法：倒序遍历字符串<code>s</code>，如果不是<code>[</code>则直接入栈；遇到<code>[</code>时，先找出<code>[</code>前边的数字<code>nums</code>表示为<code>k</code>，然后找出编码字符串<code>encodedStr</code>，重复<code>k</code>次入栈，跳过数字继续遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"strconv"</span></div><div class="line">   <span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">   stack := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">   <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; &#123;</div><div class="line">      <span class="keyword">if</span> s[i] == <span class="string">'['</span> &#123;</div><div class="line">         nums := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</div><div class="line">            <span class="keyword">if</span> s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span> &#123;</div><div class="line">               nums = <span class="built_in">append</span>(nums, <span class="keyword">string</span>(s[j]))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">         reverse(nums)</div><div class="line">         k, _ := strconv.Atoi(strings.Join(nums, <span class="string">""</span>))</div><div class="line">         encodedStr := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="string">"]"</span> &#123;</div><div class="line">            encodedStr = <span class="built_in">append</span>(encodedStr, stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</div><div class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         &#125;</div><div class="line">         stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         reverse(encodedStr)</div><div class="line">         <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; j++ &#123;</div><div class="line">            stack = <span class="built_in">append</span>(stack, encodedStr...)</div><div class="line">         &#125;</div><div class="line">         i -= <span class="built_in">len</span>(nums)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         stack = <span class="built_in">append</span>(stack, <span class="keyword">string</span>(s[i]))</div><div class="line">      &#125;</div><div class="line">      i -= <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   reverse(stack)</div><div class="line">   <span class="keyword">return</span> strings.Join(stack, <span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(arr []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">   length := <span class="built_in">len</span>(arr)</div><div class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length/<span class="number">2</span>; i++ &#123;</div><div class="line">      arr[i], arr[length-i<span class="number">-1</span>] = arr[length-i<span class="number">-1</span>], arr[i]</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   s := <span class="string">"3[a]2[bc]"</span></div><div class="line">   r := decodeString(s)</div><div class="line">   fmt.Println(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ZdIwN57.png" alt=""></p><p>惊了惊了，这么牛逼</p><h1 id="利用递归"><a href="#利用递归" class="headerlink" title="利用递归"></a>利用递归</h1><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><p>将 s.length() 的值以参数传递，减少重复调用 length() 造成的时间损耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(s.toCharArray(), s.length()).toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">'0'</span> &amp;&amp; chars[i] &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">'['</span>) &#123;</div><div class="line">                StringBuilder tmp = dfs(chars, len);</div><div class="line">                <span class="keyword">while</span> (--num &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    str.append(tmp);</div><div class="line">                &#125;</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">']'</span>) &#123;</div><div class="line">                <span class="keyword">return</span> str;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                str.append(chars[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    i = <span class="number">-1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> self.i &lt; len(s) - <span class="number">1</span>:</div><div class="line">            self.i += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> s[self.i].isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(s[self.i])</div><div class="line">            <span class="keyword">elif</span> s[self.i].isalpha():</div><div class="line">                res += s[self.i]</div><div class="line">            <span class="keyword">elif</span> s[self.i] == <span class="string">'['</span>:</div><div class="line">                res += self.decodeString(s) * num</div><div class="line">                num = <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a]2[bc]'</span>) == <span class="string">'aaabcbc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a2[c]]'</span>) == <span class="string">'accaccacc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'2[abc]3[cd]ef'</span>) == <span class="string">'abcabccdcdcdef'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零六篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>抓包：淘宝、支付宝</title>
    <link href="https://zhangslob.github.io/2019/11/27/%E6%8A%93%E5%8C%85%EF%BC%9A%E6%B7%98%E5%AE%9D%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    <id>https://zhangslob.github.io/2019/11/27/抓包：淘宝、支付宝/</id>
    <published>2019-11-27T12:05:52.084Z</published>
    <updated>2019-11-27T12:27:44.327Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零五篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>Frida抓包技巧</code><br><a id="more"></a></p><p>对于淘宝、支付宝之类的App，想要直接抓包是不可能的，可以使用 frida 实现抓包。</p><h1 id="Frida介绍"><a href="#Frida介绍" class="headerlink" title="Frida介绍"></a>Frida介绍</h1><p>Frida是一款基于python + javascript 的hook框架，通杀android\ios\linux\win\osx等各平台，由于是基于脚本的交互，因此相比xposed和substrace cydia更加便捷。Frida的官网为：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.frida.re%2F" target="_blank" rel="external">http://www.frida.re/</a></p><p>首先要保证你的android手机已经root。通过pip安装frida:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install frida</div></pre></td></tr></table></figure><p>adb连接手机，到 <a href="https://github.com/frida/frida/releases" target="_blank" rel="external">https://github.com/frida/frida/releases</a> 下载frida-server，根据情况选择android-arm 版本，安卓手机一般是是下载<code>android-arm</code>和<code>android-arm64</code>这两种。</p><p>push到android手机上并且运行，需要取得手机root权限</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb push frida-server /data/local/tmp/</div><div class="line">adb shell</div><div class="line">su</div><div class="line"><span class="built_in">cd</span> /data/local/tmp/</div><div class="line">chmod <span class="number">777</span> frida-server</div><div class="line">./frida-server</div></pre></td></tr></table></figure><p>到此为止环境已经搭建完毕。</p><h1 id="编写抓包脚本"><a href="#编写抓包脚本" class="headerlink" title="编写抓包脚本"></a>编写抓包脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> frida</div><div class="line"></div><div class="line">rdev = frida.get_usb_device()</div><div class="line"><span class="comment"># session = rdev.attach('com.taobao.etao')</span></div><div class="line">session = rdev.attach(<span class="string">'com.taobao.taobao'</span>)</div><div class="line"><span class="comment"># session = rdev.attach('com.tmall.wireless')</span></div><div class="line"></div><div class="line">scr = <span class="string">"""</span></div><div class="line">Java.perform(function () &#123;</div><div class="line">    var SwitchConfig = Java.use('mtopsdk.mtop.global.SwitchConfig');</div><div class="line">        SwitchConfig.isGlobalSpdySwitchOpen.overload().implementation = function()&#123;</div><div class="line">            var ret = this.isGlobalSpdySwitchOpen.apply(this, arguments);</div><div class="line">            console.log("isGlobalSpdySwitchOpenl "+ret)</div><div class="line">            </div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">"""</div><div class="line"></div><div class="line">script = session.create_script(scr)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></div><div class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</div><div class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(message)</div><div class="line"></div><div class="line"></div><div class="line">script.on(<span class="string">"message"</span>, on_message)</div><div class="line">script.load()</div><div class="line">sys.stdin.read()</div></pre></td></tr></table></figure><p>运行该脚本，打开淘宝就可以抓包了。要注入的进程名已经写好了：</p><ol><li><code>com.taobao.etao</code> 是一淘</li><li><code>com.taobao.taobao</code>是淘宝</li><li><code>com.tmall.wireless</code> 是天猫</li></ol><p><img src="https://i.imgur.com/WIfQJiG.png" alt=""></p><p>想要抓淘宝App数据还有很多步要走，还有<code>x-sign</code>和<code>x-min-wua</code>等着你。(^o^)/~</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frida抓包技巧&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://zhangslob.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-581-最短无序连续子数组</title>
    <link href="https://zhangslob.github.io/2019/11/26/Leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://zhangslob.github.io/2019/11/26/Leetcode-581-最短无序连续子数组/</id>
    <published>2019-11-26T02:41:36.925Z</published>
    <updated>2019-11-26T13:07:59.036Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零四篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目详述"><a href="#题目详述" class="headerlink" title="题目详述"></a>题目详述</h1><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: [2, 6, 4, 8, 10, 9, 15]</div><div class="line">输出: 5</div><div class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</div></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><h1 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>将原数组拷贝一份，然后对拷贝后的数组进行排序。</li><li>对比原数组和排序后的数组，除去前面一部分和后面一部分相同的元素，剩余区间的长度就是结果。</li><li>时间复杂度为 O(nlogn)。</li></ul><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, nums.length);</div><div class="line">        Arrays.sort(sortedNums);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = sortedNums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] == sortedNums[i]) &#123;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] == sortedNums[j]) &#123;</div><div class="line">            --j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"sort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">   sortedNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</div><div class="line">   <span class="built_in">copy</span>(sortedNum, nums)</div><div class="line">   sort.Ints(sortedNum)</div><div class="line">   i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[i] == sortedNum[i] &#123;</div><div class="line">      i++</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[j] == sortedNum[j] &#123;</div><div class="line">      j--</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> i &gt;= j &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">   n := findUnsortedSubarray(nums)</div><div class="line">   fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        sortedarray = sorted(nums)</div><div class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] == sortedarray[i]:</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == sortedarray[j]:</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">1</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>遍历数组，同时进行从头到尾，从尾到头的遍历，分别找出无序连续子数组区间的右边和左边节点；</li><li>右边点，是从左到右不递增的点，</li><li>左边点，是从右到左不递减的点，</li><li>两点之间的距离就是所求值</li></ol><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> min = nums[n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt;= max) &#123;</div><div class="line">                max = nums[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[n - i - <span class="number">1</span>] &lt;= min) &#123;</div><div class="line">                min = nums[n - i - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = n - i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">n := <span class="built_in">len</span>(nums)</div><div class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line">start, end := n<span class="number">-1</span>, <span class="number">0</span></div><div class="line">max, min := nums[<span class="number">0</span>], nums[n<span class="number">-1</span>]</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line"><span class="keyword">if</span> nums[i] &gt;= max &#123;</div><div class="line">max = nums[i]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">end = i</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> nums[n-i<span class="number">-1</span>] &lt;= min &#123;</div><div class="line">min = nums[n-i<span class="number">-1</span>]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = n - i - <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> start &gt;= end &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> end - start + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">n := findUnsortedSubarray(nums)</div><div class="line">fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        start, end = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line">        ma, mi = nums[start], nums[end]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> ma &lt;= nums[i]:</div><div class="line">                ma = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                start = i</div><div class="line">            <span class="keyword">if</span> mi &gt;= nums[n - i - <span class="number">1</span>]:</div><div class="line">                mi = nums[n - i - <span class="number">1</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                end = n - i - <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> start &lt;= end:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> start - end + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><p>等我提交之后，发现排在第一的解法比我快很多，我当时就呵呵呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        max_num = nums[<span class="number">0</span>]</div><div class="line">        right = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt;= max_num:</div><div class="line">                max_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                right = i</div><div class="line">        left = n</div><div class="line">        min_num = nums[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] &lt;= min_num:</div><div class="line">                min_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = i</div><div class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span> <span class="keyword">if</span> right - left &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零四篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink介绍</title>
    <link href="https://zhangslob.github.io/2019/11/24/Flink%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zhangslob.github.io/2019/11/24/Flink介绍/</id>
    <published>2019-11-24T09:17:09.814Z</published>
    <updated>2019-11-24T09:43:27.250Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零三篇原创文章</code></pre><p><img src="https://flink.apache.org/img/flink-header-logo.svg" alt=""></p><p><code>Flink读书笔记（一）</code><br><a id="more"></a></p><p>最近在看一本书，《Flink原理、实战与性能优化》，记录下重点。</p><h1 id="Flink是什么"><a href="#Flink是什么" class="headerlink" title="Flink是什么"></a>Flink是什么</h1><p>Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</p><h1 id="Flink优势"><a href="#Flink优势" class="headerlink" title="Flink优势"></a>Flink优势</h1><ol><li>同时支持高吞吐、低延迟、高性能。Spark或Storm不能同时支持这三种。</li><li>支持事件事件（Event Time）概念。大多数框架仅支持系统时间（Process Time）。</li><li>支持有状态的计算。在流失计算中，将算子的中间计算结果保存在内存或磁盘中。</li><li>支持高度灵活的窗口（Window）操作。</li><li>基于轻量分布式快照（SnapShot）实现的容错。任务出现任务问题都可以从CheckPoints中自动恢复。</li><li>基于JVM实现独立的内存管理。Flink实现自身内存管理机制，通过序列化/反序列化将所有数据转化为二进制储存在内存中。</li><li>Save Points（保存点）。Flink将任务执行的快照保存在储存介质上。（和第5点类似）。</li></ol><h1 id="Flink应用场景"><a href="#Flink应用场景" class="headerlink" title="Flink应用场景"></a>Flink应用场景</h1><ol><li>实时智能推荐</li><li>复杂事件处理</li><li>实时欺诈检测</li><li>实时数仓与ETL</li><li>流数据处理</li><li>实时报表分析</li></ol><h1 id="Flink组件栈"><a href="#Flink组件栈" class="headerlink" title="Flink组件栈"></a>Flink组件栈</h1><p>Flink作为一个软件堆栈，是一个分层系统。堆栈的不同层相互叠加，并提高它们接受的程序表示的抽象级别:</p><ul><li>运行时层以JobGraph的形式接收程序。JobGraph是一个通用的并行数据流，其中包含使用和生成数据流的任意任务。</li><li>DataStream API和DataSet API都通过单独的编译过程生成JobGraphs。数据集API使用优化器来确定程序的最佳计划，而DataStream API使用流构建器。</li><li>JobGraph是根据Flink中可用的各种部署选项执行的(例如，本地、远程、Yarn等)</li><li>Connector层所能对接的技术更是丰富多样，将不同类型、不同来源的数据介入到Flink组件栈中。</li></ul><p><img src="https://raw.githubusercontent.com/Jonathan-Wei/Flink-Docs-CN/master/.gitbook/assets/4d9108a9-ab87-4380-be77-1ad455fa2d8f.png" alt=""></p><h1 id="Flink架构图"><a href="#Flink架构图" class="headerlink" title="Flink架构图"></a>Flink架构图</h1><p>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p><ul><li><strong>Client</strong> 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</li><li><strong>JobManager</strong> 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li><li><strong>TaskManager</strong> 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</li></ul><p>可以看到 Flink 的任务调度是多线程模型，并且不同Job/Task混合在一个 TaskManager 进程中。虽然这种方式可以有效提高 CPU 利用率，但是个人不太喜欢这种设计，因为不仅缺乏资源隔离机制，同时也不方便调试。类似 Storm 的进程模型，一个JVM 中只跑该 Job 的 Tasks 实际应用中更为合理。</p><p><img src="https://i.imgur.com/sg6tXAa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://flink.apache.org/img/flink-header-logo.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flink读书笔记（一）&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Flink" scheme="https://zhangslob.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 287. 寻找重复数</title>
    <link href="https://zhangslob.github.io/2019/11/21/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://zhangslob.github.io/2019/11/21/Leetcode-287-寻找重复数/</id>
    <published>2019-11-21T05:53:36.612Z</published>
    <updated>2019-11-21T06:35:36.592Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零二篇原创文章</code></pre><p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [1,3,4,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [3,1,3,4,2]</div><div class="line">输出: 3</div></pre></td></tr></table></figure><p><strong>说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">不能更改原数组（假设数组是只读的）。</div><div class="line">只能使用额外的 O(1) 的空间。</div><div class="line">时间复杂度小于 O(n2) 。</div><div class="line">数组中只有一个重复的数字，但它可能不止重复出现一次。</div></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>思路是采用了二分法+抽屉原理。首先解释一下为什么用二分法，因为O(n2)时间复杂度不能A，所以往下应该是n*logn，很容易联想到二分法，因为其复杂度为logn。</p><p>抽屉原理是说假设你有11个苹果，要放进10个抽屉，那么至少有一个抽屉里是有两个苹果的。</p><p>对应到这题，1~n的n+1个数字，有1个数字会至少重复两次。</p><p>比如取数组为｛1，2，2，3，4，5｝，一共6个数，范围是1~5，其中位数应该是（5+1）/2 = 3，那么，如果小于等于3的数的个数如果超过了3，那么重复的数字一定出现在[1，3]之间，否则出现在[4，5]之间。以该数组为例，中位数为3，小于等于3的数一共有4个，大于3的数有两个，所以重复的数字在[1,3]之间。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt;= mid) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        left, right = <span class="number">1</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right:</div><div class="line">            mid = (left + right) // <span class="number">2</span></div><div class="line">            count = sum(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums)</div><div class="line">            <span class="keyword">if</span> count &gt; mid:</div><div class="line">                right = mid</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> right</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">start, end := <span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line"><span class="keyword">for</span> start &lt; end &#123;</div><div class="line">mid := (start + end) / <span class="number">2</span></div><div class="line">count := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</div><div class="line"><span class="keyword">if</span> v &lt;= mid &#123;</div><div class="line">count++</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> count &gt; mid &#123;</div><div class="line">end = mid</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = mid + <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> start</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>数组的索引与存储的数值之间形成了特殊<strong>链表</strong>。</p><p>如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。</p><p>环的入口即为结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// 快慢指针</span></div><div class="line">        <span class="keyword">int</span> fast = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> low = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            low = nums[low];</div><div class="line">            fast = nums[nums[fast]];</div><div class="line">        &#125;<span class="keyword">while</span>(fast != low);</div><div class="line">        <span class="keyword">int</span> step = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 寻找环链表的入口，即为结果</span></div><div class="line">        <span class="keyword">while</span>(step != low)&#123;</div><div class="line">            step = nums[step];</div><div class="line">            low = nums[low];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>现在还没看懂这种方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://zhangslob.github.io/2019/11/12/%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangslob.github.io/2019/11/12/算法/</id>
    <published>2019-11-12T13:47:02.238Z</published>
    <updated>2019-11-13T05:59:37.192Z</updated>
    
    <content type="html"><![CDATA[<p>java基础  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h2 id="算法-Algorithms"><a href="#算法-Algorithms" class="headerlink" title="算法 - Algorithms"></a><strong>算法 - Algorithms</strong></h2><ol><li>排序算法：快速排序、归并排序、计数排序</li><li>搜索算法：回溯、递归、剪枝技巧</li><li>图论：最短路、最小生成树、网络流建模</li><li>动态规划：背包问题、最长子序列、计数问题</li><li>基础技巧：分治、倍增、二分、贪心</li></ol><h2 id="数据结构-Data-Structures"><a href="#数据结构-Data-Structures" class="headerlink" title="数据结构 - Data Structures"></a><strong>数据结构 - Data Structures</strong></h2><ol><li>数组与链表：单 / 双向链表、跳舞链</li><li>栈与队列</li><li>树与图：最近公共祖先、并查集</li><li>哈希表</li><li>堆：大 / 小根堆、可并堆</li><li>字符串：字典树、后缀树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合框架常见面试题</title>
    <link href="https://zhangslob.github.io/2019/11/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhangslob.github.io/2019/11/11/Java集合框架常见面试题/</id>
    <published>2019-11-11T08:21:46.065Z</published>
    <updated>2019-11-20T03:40:43.026Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="说说List-Set-Map三者的区别"><a href="#说说List-Set-Map三者的区别" class="headerlink" title="说说List,Set,Map三者的区别"></a>说说List,Set,Map三者的区别</h1><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h1><ul><li><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong><ul><li>① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li>② <strong>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响</strong>，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度应为o(n))因为需要新创立一个新的链表，复制前i-1个元素并在第i位加入新的元素，最后附上n-i个元素。</li></ul></li><li><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a><strong>补充内容:RandomAccess接口</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（</code>）方法中，它要判断传入的list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch（）</code>方法，如果不是，那么调用<code>iteratorBinarySearch（）</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</div><div class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</li><li>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</li></ul><h1 id="双向链表和双向循环链表"><a href="#双向链表和双向循环链表" class="headerlink" title="双向链表和双向循环链表"></a>双向链表和双向循环链表</h1><p><strong>双向链表：</strong> 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。</p><p><a href="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" alt="双向链表"></a></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。</p><p><a href="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" alt="双向循环链表"></a></p><h1 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h1><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p><h1 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h1><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="external">通过源码一步一步分析ArrayList 扩容机制</a></p><p>#HashMap 和 Hashtable 的区别</p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put（）</code>向map中添加元素</td><td>调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></div><div class="line">    <span class="comment">// ^ ：按位异或</span></div><div class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line"></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><a href="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" alt="jdk1.8之前的内部结构-HashMap"></a></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><a href="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" alt="jdk1.8之后的内部结构-HashMap"></a></p><blockquote><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong>推荐阅读：</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p><h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="external">https://coolshell.cn/articles/9606.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java疑难点</title>
    <link href="https://zhangslob.github.io/2019/11/11/Java%E7%96%91%E9%9A%BE%E7%82%B9/"/>
    <id>https://zhangslob.github.io/2019/11/11/Java疑难点/</id>
    <published>2019-11-11T05:57:44.804Z</published>
    <updated>2019-11-11T07:44:39.165Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="正确使用-equals-方法"><a href="#正确使用-equals-方法" class="headerlink" title="正确使用 equals 方法"></a>正确使用 equals 方法</h1><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></div><div class="line">String str = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (str.equals(<span class="string">"SnailClimb"</span>)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ..</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"SnailClimb"</span>.equals(str); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Objects.equals(<span class="keyword">null</span>,<span class="string">"SnailClimb"</span>);<span class="comment">// false</span></div></pre></td></tr></table></figure><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</div><div class="line">        <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></div><div class="line">        <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894" target="_blank" rel="external">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h1 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h1><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer x = <span class="number">3</span>;</div><div class="line">Integer y = <span class="number">3</span>;</div><div class="line">System.out.println(x == y);<span class="comment">// true</span></div><div class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</div><div class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</div><div class="line">System.out.println(a == b);<span class="comment">//false</span></div><div class="line">System.out.println(a.equals(b));<span class="comment">//true</span></div></pre></td></tr></table></figure><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。</p><h1 id="BigDecimal-的用处"><a href="#BigDecimal-的用处" class="headerlink" title="BigDecimal 的用处"></a>BigDecimal 的用处</h1><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</div><div class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</div><div class="line">System.out.println(a);<span class="comment">// 0.100000024</span></div><div class="line">System.out.println(b);<span class="comment">// 0.099999964</span></div><div class="line">System.out.println(a == b);<span class="comment">// false</span></div></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</div><div class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</div><div class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</div><div class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></div><div class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></div><div class="line">System.out.println(x.equals(y));<span class="comment">// true</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-的大小比较"><a href="#BigDecimal-的大小比较" class="headerlink" title="BigDecimal 的大小比较"></a>BigDecimal 的大小比较</h1><p><code>a.compareTo(b)</code> : 返回 -1 表示小于，0 表示 等于， 1表示 大于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</div><div class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</div><div class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-保留几位小数"><a href="#BigDecimal-保留几位小数" class="headerlink" title="BigDecimal 保留几位小数"></a>BigDecimal 保留几位小数</h1><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">"1.255433"</span>);</div><div class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</div><div class="line">System.out.println(n);<span class="comment">// 1.255</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-的使用注意事项"><a href="#BigDecimal-的使用注意事项" class="headerlink" title="BigDecimal 的使用注意事项"></a>BigDecimal 的使用注意事项</h1><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><a href="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h1 id="基本数据类型与包装数据类型的使用标准"><a href="#基本数据类型与包装数据类型的使用标准" class="headerlink" title="基本数据类型与包装数据类型的使用标准"></a>基本数据类型与包装数据类型的使用标准</h1><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="Arrays-asList-使用指南"><a href="#Arrays-asList-使用指南" class="headerlink" title="Arrays.asList()使用指南"></a>Arrays.asList()使用指南</h1><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="external">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String[] myArray = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span> &#125;； </div><div class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</div><div class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></div><div class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</div></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="阿里巴巴Java-开发手册》对其的描述"><a href="#阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="阿里巴巴Java 开发手册》对其的描述"></a>阿里巴巴Java 开发手册》对其的描述</h2><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><a href="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" alt="阿里巴巴Java开发手-Arrays.asList()方法"></a></p><h2 id="使用时的注意事项总结"><a href="#使用时的注意事项总结" class="headerlink" title="使用时的注意事项总结"></a>使用时的注意事项总结</h2><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.asList(myArray);</div><div class="line">System.out.println(myList.size());<span class="comment">//1</span></div><div class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></div><div class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></div><div class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</div><div class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></div></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div></pre></td></tr></table></figure><p><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></div><div class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></div><div class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></div></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></div></pre></td></tr></table></figure><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">  &#123;</div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">         ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList"></a>如何正确的将数组转换为ArrayList</h2><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW" target="_blank" rel="external">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JDK1.5+</span></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</div><div class="line">    l.add(s);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (l);</div><div class="line">&#125;</div><div class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></div></pre></td></tr></table></figure><p><strong>2. 最简便的方法(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</div></pre></td></tr></table></figure><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</div><div class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></div><div class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</div></pre></td></tr></table></figure><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="external"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="external"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="external"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">"string"</span>, <span class="string">"elements"</span>);  <span class="comment">// from varargs</span></div><div class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></div></pre></td></tr></table></figure><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="external"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="external"><code>newArrayList()</code></a>工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></div><div class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></div><div class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">"or"</span>, <span class="string">"string"</span>, <span class="string">"elements"</span>); <span class="comment">// from varargs</span></div></pre></td></tr></table></figure><p><strong>5. 使用 Apache Commons Collections</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">CollectionUtils.addAll(list, str);</div></pre></td></tr></table></figure><h1 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h1><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String[] s = <span class="keyword">new</span> String[]&#123;</div><div class="line">    <span class="string">"dog"</span>, <span class="string">"lazy"</span>, <span class="string">"a"</span>, <span class="string">"over"</span>, <span class="string">"jumps"</span>, <span class="string">"fox"</span>, <span class="string">"brown"</span>, <span class="string">"quick"</span>, <span class="string">"A"</span></div><div class="line">&#125;;</div><div class="line">List&lt;String&gt; list = Arrays.asList(s);</div><div class="line">Collections.reverse(list);</div><div class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></div></pre></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="external">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h1 id="不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove/add 操作"></a>不要在 foreach 循环里进行元素的 remove/add 操作</h1><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove</code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><a href="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://zhangslob.github.io/2019/11/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhangslob.github.io/2019/11/04/Java基础知识/</id>
    <published>2019-11-04T05:50:20.054Z</published>
    <updated>2019-11-07T09:11:38.694Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十九篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="面向对象-oop-与面向过程-opp-的区别"><a href="#面向对象-oop-与面向过程-opp-的区别" class="headerlink" title="面向对象(oop)与面向过程(opp)的区别"></a>面向对象(oop)与面向过程(opp)的区别</h1><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul><blockquote><p>Python也是一门面向对象的编程语言</p></blockquote><h1 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点"></a>Java 语言有哪些特点</h1><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h1 id="关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="关于 JVM JDK 和 JRE 最详细通俗的解答"></a>关于 JVM JDK 和 JRE 最详细通俗的解答</h1><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p><p><a href="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67" alt="Java程序运行过程"></a></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><blockquote><p>HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h1 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别?"></a>Java和C++的区别?</h1><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><p>补充一下JAVA和Python的区别：</p><ul><li>python虚拟机没有java强，java虚拟机是java的核心，python的核心是可以很方便地使用c语言函数或c++库</li><li>Python是动态语言，JAVA是静态语言。JAVA在编写时可以检测变量类型</li><li>Python入门比JAVA简单</li><li>Python更多用来写一些简单脚本，JAVA用来做web、大数据方面很多</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><ul><li><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</li><li><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</li></ul><h1 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h1><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h1 id="String-StringBuffer-和-StringBuilder-的区别"><a href="#String-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别"></a>String StringBuffer 和 StringBuilder 的区别</h1><p><strong>可变性</strong></p><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。</p><p>而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p><p>StringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(capacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AbstractStringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] value;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    AbstractStringBuilder() &#123;</div><div class="line">    &#125;</div><div class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</div><div class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p>StringBuffer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</div><div class="line">    toStringCache = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">super</span>.insert(offset, str);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> </span>&#123;</div><div class="line">    toStringCache = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">super</span>.setLength(newLength);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ol><p>#自动装箱与拆箱</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h1 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h1><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</p><p>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 　</p><h1 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h1><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><p>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p><h1 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h1><ol><li>从语法形式上看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h1 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h1><ol><li>名字与类名相同。</li><li>没有返回值，但不能用void声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h1 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h1><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ol><h1 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h1><p><strong>==</strong> : 它的作用是判断两个对象的<strong>地址</strong>是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。基本数据类型：byte、short、int、long、float、double、char、boolean<br>引用类型：类(class)、接口(interface)、数组(array)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></div><div class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></div><div class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></div><div class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></div><div class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"aa==bb"</span>);</div><div class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></div><div class="line">            System.out.println(<span class="string">"a==b"</span>);</div><div class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"aEQb"</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"true"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><blockquote><p>一般情况下都用equals，肯定不会错</p></blockquote><h1 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h1><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><blockquote><p>hashCode可能会返回负数</p></blockquote><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals（）</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="external">Java hashCode() 和 equals()的若干问题解答</a></p><h1 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h1><p>有时间好好看看这个：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="external">这一次，彻底解决Java的值传递和引用传递</a></p><h1 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h1><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h1 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态"></a>线程有哪些基本状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。</p><p><a href="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" alt="Java线程的状态"></a></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：</p><p><a href="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" alt="Java线程状态变迁"></a></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="external">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="external">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><a href="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" alt="RUNNABLE-VS-RUNNING"></a></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h1 id="关于-final-关键字的一些总结"><a href="#关于-final-关键字的一些总结" class="headerlink" title="关于 final 关键字的一些总结"></a>关于 final 关键字的一些总结</h1><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol><h1 id="Java-中的异常处理"><a href="#Java-中的异常处理" class="headerlink" title="Java 中的异常处理"></a>Java 中的异常处理</h1><h3 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h3><p><a href="https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67" alt="Java异常类层次结构图"></a></p><p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 <strong>Throwable类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由Java虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以0时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p><p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p><h3 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h3><ul><li><strong>public string getMessage()</strong>:返回异常发生时的简要描述</li><li><strong>public string toString()</strong>:返回异常发生时的详细信息</li><li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li><li><strong>public void printStackTrace()</strong>:在控制台上打印Throwable对象封装的异常信息</li></ul><h3 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h3><ul><li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li><li><strong>catch 块：</strong> 用于处理try捕获到的异常。</li><li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。</li></ul><p><strong>在以下4种特殊情况下，finally块不会被执行：</strong></p><ol><li>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</li><li>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ol><p>下面这部分内容来自issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190。" target="_blank" rel="external">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p><p><strong>注意：</strong> 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> value * value;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。</p><h1 id="Java序列化中如果有些字段不想进行序列化，怎么办"><a href="#Java序列化中如果有些字段不想进行序列化，怎么办" class="headerlink" title="Java序列化中如果有些字段不想进行序列化，怎么办"></a>Java序列化中如果有些字段不想进行序列化，怎么办</h1><p>对于不想进行序列化的变量，使用transient关键字修饰。</p><p>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p><h1 id="Java-中-IO-流"><a href="#Java-中-IO-流" class="headerlink" title="Java 中 IO 流"></a>Java 中 IO 流</h1><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><a href="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" alt="IO-操作方式分类"></a></p><p>按操作对象分类结构图：</p><p><a href="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" alt="IO-操作对象分类"></a></p><h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h1 id="常见关键字总结-static-final-this-super"><a href="#常见关键字总结-static-final-this-super" class="headerlink" title="常见关键字总结:static,final,this,super"></a>常见关键字总结:static,final,this,super</h1><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/final、static、this、super.md" target="_blank" rel="external"> final,static,this,super 关键字总结</a></p><h1 id="Collections-工具类和-Arrays-工具类常见方法总结"><a href="#Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法总结"></a>Collections 工具类和 Arrays 工具类常见方法总结</h1><p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/Arrays,CollectionsCommonMethods.md" target="_blank" rel="external"> Collections 工具类和 Arrays 工具类常见方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十九篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端真机调试指南</title>
    <link href="https://zhangslob.github.io/2019/10/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://zhangslob.github.io/2019/10/29/移动端真机调试指南/</id>
    <published>2019-10-29T02:06:21.667Z</published>
    <updated>2019-10-29T02:17:04.154Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/MobileDebug_900x500.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十八篇原创文章</div></pre></td></tr></table></figure><p>各种抓包方法  (๑• . •๑)</p><a id="more"></a><h1 id="系统自带调试功能"><a href="#系统自带调试功能" class="headerlink" title="系统自带调试功能"></a>系统自带调试功能</h1><h3 id="iOS-系统"><a href="#iOS-系统" class="headerlink" title="iOS 系统"></a>iOS 系统</h3><p><strong>运行环境要求</strong></p><ul><li>Mac + Safari 浏览器</li><li>iPhone（iOS 6 +） + Safari 浏览器</li></ul><p><strong>调试步骤</strong></p><p>1、使用 Lightning 数据线将 iPhone 与 Mac 相连</p><p>2、iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; 开启 Web 检查器）</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_WebInspector.jpg" alt=""></p><p>3、iPhone 使用 Safari 浏览器打开要调试的页面</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/iPhone_Safari.jpg" alt=""></p><p>4、Mac 打开 Safari 浏览器调试（菜单栏 —&gt; 开发 -&gt; iPhone 设备名 -&gt; 选择调试页面）</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_Page.jpg" alt=""></p><p>如果你的菜单栏没有“开发”选项，可以到左上角 <code>Safari</code> -&gt; <code>偏好设置</code> -&gt; <code>高级</code> -&gt; <code>在菜单栏中显示“开发”菜单</code>。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Open_SafariDevTools.jpg" alt=""></p><p>5、在弹出的 Safari Developer Tools 中调试</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_DevTools.jpg" alt=""></p><p>经过如上步骤就可在 Mac 端调试 iPhone 上 Safari 运行的页面了，但对于 WebView 页面就不适用了，另外 Windows 系统不适用此方案。</p><p><strong>当前测试环境：</strong></p><ul><li>Safari 版本 10.0.2</li><li>iPhone 7（iOS 10.1.1）</li></ul><p>没有 iPhone 设备可以在 App Store 安装 Xcode 使用其内置的 iOS 模拟器，安装完成后通过以下两种方式开启：</p><ul><li>右键 <code>Xcode 图标</code> -&gt; <code>Open Developer Tool</code> -&gt; <code>Simulator</code></li><li>右键 <code>Finder 图标</code> -&gt; <code>前往文件夹</code> -&gt; <code>/应用程序/Xcode.app/Contents/Developer/Applications/</code> -&gt; 运行 <code>Simulator.app</code></li></ul><p>运行 iOS 模拟器后，在模拟器中打开调试页面，再通过 Mac Safari 开发功能就可以调试到。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Xcode_Simulator.jpg" alt="Simulator"></p><p>如果我需要调试更低版本的 iOS 怎么办？实际使用的 iPhone 不可能去降版本，不必担心，Simulator 有。</p><p>点击左上角 <code>Xcode</code> -&gt; <code>Preferences</code> -&gt; <code>Downloads</code> 就可以看到提供了如下版本：</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Xcode_Simulator_Version.jpg" alt="iOS 版本下载"></p><h1 id="Android-系统"><a href="#Android-系统" class="headerlink" title="Android 系统"></a>Android 系统</h1><h3 id="运行环境要求"><a href="#运行环境要求" class="headerlink" title="运行环境要求"></a>运行环境要求</h3><ul><li>Chrome 版本 &gt;= 32</li><li>Android 版本 4.0 +</li></ul><h3 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li><p>使用 USB 数据线将手机与电脑相连</p></li><li><p>手机进入开发者模式，勾选 USB 调试，并允许调试</p></li></ol><h3 id="如何开启-USB-调试："><a href="#如何开启-USB-调试：" class="headerlink" title="如何开启 USB 调试："></a>如何开启 USB 调试：</h3><p><strong>索尼 Z5：</strong><code>设置</code> -&gt; <code>关于关机</code> -&gt; <code>多次点击软件版本开启</code> -&gt; <code>返回上一级</code> -&gt; <code>开发者选项</code> -&gt; <code>USB 调试</code></p><p><strong>魅蓝 Note：</strong><code>设置</code> -&gt; <code>辅助功能</code> -&gt; <code>开发者选项</code> -&gt; <code>USB 调试</code></p><p>不同 Android 设备进入开发者模式的方式有稍稍不同，瞎捣鼓一下即可开启。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_USB_Debug.jpg" alt="开启 Android 调试"></p><ol><li>电脑打开 Chrome 浏览器，在地址栏输入：chrome://inspect/#devices 并勾选 Discover USB devices 选项</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Discover_USB_devices.jpg" alt="开启 Discover USB devices"></p><ol><li>手机允许远程调试，并访问调试页面</li></ol><p>官方的教程是想让你使用手机 Chrome 开启调试页面的，但实际需求更多的是调试一些 WebView 页面，在官方的 <a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews" target="_blank" rel="external">Remote Debugging WebViews</a> 有说明是可以调试 WebView 页面的，Android 版本需要在 4.4 以上，并且 APP 需要有配置相应的启动调试代码。</p><blockquote><p>WebView debugging must be enabled from within your application. To enable WebView debugging, call the static method setWebContentsDebuggingEnabled on the WebView class.</p><p>必须在 APP 内启动 WebView 调试。要启动 WebView 调试，需要调用 WebView 类上的静态方法 setWebContentsDebuggingEnabled。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">    WebView.setWebContentsDebuggingEnabled(<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>This setting applies to all of the application’s WebViews.</p><p>此设置适用于所有 APP 的 WebView。</p><p>Tip: WebView debugging is not affected by the state of the debuggable flag in the application’s manifest. If you want to enable WebView debugging only when debuggable is true, test the flag at runtime.</p><p>提示：WebView 是否可调试状态不受 mainfest 标志变量 debuggable 的影响，如果你想在 debuggable 为 true 的时候启动 WebView 调试，请使用以下代码：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)) &#123; </div><div class="line">    WebView.setWebContentsDebuggingEnabled(<span class="literal">true</span>); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_Page.jpg" alt="Android 打开调试页面"></p><ol><li>电脑点击 inspect 按钮</li></ol><p>如果你出现无法识别到设备的情况，建议尝试以下几种方法：</p><ul><li>使用原装数据线，不要使用山寨数据线或一线多头的数据线</li><li>重新插拔 USB 数据线，让手机处于充电状态</li><li>关闭电脑相关的应用助手</li><li>重启手机</li><li>Windows 系统下自动安装驱动失败，到 <a href="https://developer.android.com/studio/run/oem-usb.html#Drivers" target="_blank" rel="external">Android Studio</a> 手动下载</li></ul><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Click_Inspect.jpg" alt="点击 inspect 按钮"></p><p>注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 <a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="external">https://chrome-devtools-frontend.appspot.com</a> 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。</p><ol><li>进入调试界面</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Chrome_DevTools.jpg" alt="Chrome DevTools"></p><p><strong>当前测试环境：</strong></p><ul><li>Chrome 版本 55.0.2883.95</li><li>索尼 Z5（Android 5.1.1）</li><li>魅蓝 Note（Android 5.1）</li><li>三星 Galaxy S7（Android 6.0.1）</li></ul><p>这里顺带提一下 <a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">TBS Studio</a> 调试工具，它在 Chrome DevTools 调试功能的基础上进行了一些功能扩展，特性如下：</p><p>1.3 TBS Studio 功能特性</p><ol><li>自动检测手机与 PC 的连接；</li><li>自动检测网页是否可进行 Inspect 调试；</li><li>自动引导开发者打开 Inspector 调试开关；</li><li>一键开启 Inspector 调试，无需打开浏览器输入 URL，方便快捷；</li><li>扩展 X5 内核独有 Inspect 选项，方便页面分析和优化；</li><li>真机远程 Inspector 调试。</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/TBS_Studio.jpg" alt="TBS Studio"></p><p>详细介绍和使用步骤可到<a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">开发者论坛</a>查看，部分 Android 机型通过 USB 可能依旧无法识别到设备，可使用后面会讲到的其他方案。</p><p>关于 Android 虚拟机也是有的，这里推荐使用 <a href="https://www.genymotion.com/" target="_blank" rel="external">Genymotion</a> 软件，使用 Genymotion 前需要安装 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtuaBox</a>，并且注册登陆后才能显示所有的虚拟设备。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Virtua_Android.jpg" alt="Genymotion"></p><h1 id="使用代理工具调试开发环境页面"><a href="#使用代理工具调试开发环境页面" class="headerlink" title="使用代理工具调试开发环境页面"></a>使用代理工具调试开发环境页面</h1><p>对于需要配 Hosts 才能访问的开发环境页面，手机在默认情况下是没有权限修改 Hosts 文件的，除非是 iOS 设备越狱后和 Android 设备 root 后，所以一般情况下手机是无法访问开发环境页面，这时需要使用到 Mac 系统的 <a href="https://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> 代理工具，Windows 系统可使用 <a href="http://www.telerik.com/fiddler" target="_blank" rel="external">Fiddler</a> 代理工具。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>Mac 作为代理服务器</li><li>手机通过 HTTP 代理连接到 Mac 电脑</li><li>手机上的请求都经过代理服务器</li><li>通过给 Mac 配 Hosts 实现目的</li></ul><h3 id="调试步骤-1"><a href="#调试步骤-1" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li>查看电脑 IP（<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>Local IP Addresses</code>）</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Local_IP.jpg" alt="本地 IP"></p><ol><li>查看端口（<code>菜单</code> -&gt; <code>Settings</code> -&gt; <code>Proxy Settings</code> -&gt; <code>Proxies</code>）</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Proxy_Port.jpg" alt="代理端口"></p><p>默认端口为：8888，勾选 <code>Enable transparent HTTP proxying</code></p><ol><li>将 IP、端口号填入手机 HTTP 代理</li></ol><p>iOS 系统：<code>设置</code> -&gt; <code>无线局域网</code> -&gt; <code>点击叹号</code> -&gt; <code>HTTP 代理</code> -&gt; <code>手动</code></p><p>Android 系统：<code>设置</code> -&gt; <code>长按当前网络</code> -&gt; <code>修改网络</code> -&gt; <code>高级选项</code> -&gt; <code>手动</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Set_HTTP_Proxy.jpg" alt="手机设置代理"></p><ol><li>Charles 允许授权</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Allow_all_IP.jpg" alt="允许授权"></p><p>每次有新设备首次连接都会提示是否授权，可以通过 <code>Proxy</code> -&gt; <code>Access Control Settings</code> 配置以下参数 <code>0.0.0.0/0</code> 来关闭。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/All_IP.jpg" alt="所有 IP 通过"></p><ol><li><p>使用 SwitchHosts! 软件给 Mac 电脑配 Hosts</p></li><li><p>手机访问开发环境页面</p></li></ol><p>到这一步手机就可以访问到开发环境下的页面了，再结合前面所讲的方案来调试页面。</p><ol><li>Charles 的调试功能</li></ol><ul><li><strong>7.1 网络映射修改文件</strong></li></ul><p>除了结合前面的方案调试，可以使用 Map Local 网络映射功能来实现对文件的修改，在<code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>Start Recording</code> 开启抓包后访问页面，找到抓取到的样式文件，点击右键 <code>Map Local</code>，在 <code>Local path</code> 中设置本地映射文件的路径，修改后刷新页面可以看到效果。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Map_Local.jpg" alt="Map Local"></p><ul><li><strong>7.2 模拟网络速度</strong></li></ul><p><code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>Throttle Settings</code> -&gt; 勾选 <code>Enable Throttling</code>，在 <code>Throttling preset</code> 中可以选择需要模拟的网络速度。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Throttling.jpg" alt="模拟网络速度"></p><ul><li><strong>7.3 抓取 HTTPS 请求</strong></li></ul><p>默认情况下，Charles 无法抓取到 HTTPS 的请求，解决步骤如下：</p><p>Mac 端安装证书：<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>SSL Proxying</code> -&gt; <code>Install Charles Root Certificate</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Install_SSL.jpg" alt="Mac 安装 SSL"></p><p>然后导出 Charles SSL 证书安装到手机，<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>SSL Proxying</code> -&gt; <code>Save Charles Root Certificate</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Save_SSL.jpg" alt="导出 SSL"></p><p>Android 设备导出的 Charles SSL 证书存储到手机中并安装。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_Setup_SSL.jpg" alt="Android 安装 SSL"></p><p>iOS 设备用 Safari 打开 <a href="http://www.charlesproxy.com/getssl/" target="_blank" rel="external">http://www.charlesproxy.com/getssl/</a> 页面，下载 Charles SSL 证书并安装。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/iOS_Setup_SSL.jpg" alt="iOS 安装 SSL"></p><p>证书安装完成后，还需要给 Charles SSL 代理配置域名和端口号，<code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>SSL Proxying Settings</code> 勾选 <code>Enable SSL Proxying</code> 点击 <code>Add</code> 填入域名和端口号，经过以上步骤就可以抓取到 HTTPS 的请求了。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/SSL_Proxying_Settings.jpg" alt="设置 SSL 端口"></p><ul><li><strong>7.4 断点调试请求和响应内容</strong></li></ul><p>开启 Charles 断点 <code>Proxy</code> -&gt; <code>Breakpoints Settings</code> -&gt; <code>Enable Breakpoints</code>点击 <code>Add</code> 可设置断点条件或者单独对需要的文件右键 <code>Breakpoints</code> 设置断点。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Breakpoints.jpg" alt="开启断点"></p><p>访问页面后，即可编辑请求和响应的内容，点击 <code>Execute</code> 按钮完成。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Edit_Content.jpg" alt="编辑抓包内容"></p><h1 id="Weinre-调试工具"><a href="#Weinre-调试工具" class="headerlink" title="Weinre 调试工具"></a>Weinre 调试工具</h1><p>Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。</p><p><strong>调试步骤：</strong></p><p><strong>1、安装 Weinre</strong></p><p>使用 NPM 全局安装 Weinre</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm -g install weinre</div></pre></td></tr></table></figure><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Install_Weinre.jpg" alt="安装 Weinre"></p><p><strong>2、启动 Weinre 监听服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ipconfig getifaddr en0 // 查看本机 IP</div><div class="line">$ weinre --boundHost 10.14.217.14 --httpPort 8090</div></pre></td></tr></table></figure><p><code>--boundHost</code> 后填入你本机 IP 地址，<code>--httpPort</code> 后填入端口号，默认为 8080</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/run_weinre.jpg" alt="启动监听"></p><p><strong>3、进入 Weinre 管理页面</strong></p><p>使用 Chrome 浏览器访问 <a href="http://10.14.217.14:8090/" target="_blank" rel="external">http://10.14.217.14:8090</a>，在管理页面你可以看到使用相关的说明，有进入客户端调试界面的地址、使用的文档、DEMO 页面等等，说明中要求将一段 JS 脚本 <code>&lt;script src=&quot;http://10.14.217.14:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;</code> 插入到需要调试的页面中，插入代码后手机访问调试页面。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Target_Script.jpg" alt="需要插入的脚本"></p><p><strong>4、进入客户端调试界面</strong></p><p>点击 debug client user interface：<a href="http://10.14.217.14:8090/client/#anonymous" target="_blank" rel="external">http://10.14.217.14:8090/client/#anonymous</a> 的链接。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Weinre_Remote.jpg" alt="Weinre Remote"></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Weinre_Element.jpg" alt="Weinre Element"></p><p><strong>5、JS 脚本注入</strong></p><p>手动加入 JS 脚本不优雅，这里可以结合我们前面提到的 Charles 代理工具实现动态 HTTP Script 注入。</p><p>打开<code>菜单</code> -&gt; <code>Rewrite</code> -&gt; 勾选 <code>Enable Rewrite</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Rewrite.jpg" alt="Charles Rewrite"></p><p>输入 Rewrite 的名字并且在 Rules 一项添加匹配的规则，Location 一项是用于指定的域名和端口添加规则用的，这里我们不填默认匹配所有请求。</p><p>Type 允许对需要匹配的请求进行 Rewrite，一共提供了 11 种：</p><ul><li><code>Add Header</code></li><li><code>Modify Header</code></li><li><code>Remove Header</code></li><li><code>Host</code></li><li><code>Path</code></li><li><code>URL</code></li><li><code>Add Query Param</code></li><li><code>Modify Query Param</code></li><li><code>Remove Query Param</code></li><li><code>Response Status</code></li><li><code>Body</code></li></ul><p>这里我们需要使用到的是 <code>Body</code>，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 <code>&lt;/body&gt;</code> 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Rewrite_Rule.jpg" alt="Rewrite Rule"></p><p>另外，也有基于 Weinre 进行功能扩展的工具，比如早期版本的 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信 Web 开发者工具 v0.7.0</a> 和 <a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">spy-debugger</a>，都在 Weinre 的基础上简化了要给每个调试页面添加 JS 脚本的步骤，spy-debugger 还增加了对 HTTPS 的支持。</p><hr><p>感谢你的阅读，如果你还有其他更为实用的调试方案，欢迎下方留言交流。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html" target="_blank" rel="external">Safari Web Inspector Guide</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/" target="_blank" rel="external">Get Started with Remote Debugging Android Devices</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews" target="_blank" rel="external">Remote Debugging WebViews</a></li><li><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Running.html" target="_blank" rel="external">weinre - Running</a></li><li><a href="https://www.charlesproxy.com/documentation/welcome/" target="_blank" rel="external">Charles Web Debugging Proxy</a></li><li><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">wuchangming/spy-debugger</a></li><li><a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">TBS 开发调试利器 —— TBS Studio - QQ 浏览器移动产品论坛</a></li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信 web 开发者工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://misc.aotu.io/ONE-SUNDAY/MobileDebug/MobileDebug_900x500.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十八篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;各种抓包方法  (๑• . •๑)&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://zhangslob.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis SCAN的使用</title>
    <link href="https://zhangslob.github.io/2019/09/25/Redis-SCAN%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhangslob.github.io/2019/09/25/Redis-SCAN的使用/</id>
    <published>2019-09-25T02:09:09.679Z</published>
    <updated>2019-09-25T02:18:29.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/carbon.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十八篇原创文章</div></pre></td></tr></table></figure><p>了解下redis的更多用法</p><a id="more"></a><h1 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h1><p>有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？</p><p>Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli keys key67*</div><div class="line">  1) <span class="string">"key6764"</span></div><div class="line">  2) <span class="string">"key6738"</span></div><div class="line">  3) <span class="string">"key6774"</span></div><div class="line">  4) <span class="string">"key673"</span></div><div class="line">  5) <span class="string">"key6710"</span></div><div class="line">  6) <span class="string">"key6759"</span></div><div class="line">  7) <span class="string">"key6715"</span></div><div class="line">  8) <span class="string">"key6746"</span></div><div class="line">  9) <span class="string">"key6796"</span></div></pre></td></tr></table></figure><p>这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。</p><ul><li><p>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，</p><p>当你看到满屏的字符串刷的没有尽头时，你就知道难受了。</p></li><li><p>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，</p><p>所有读写 Redis 的其它的指令都会被延后甚至会超时报错，</p><p>因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</p></li><li><p>建议生产环境屏蔽keys命令</p></li></ul><p>Redis 为了解决这个问题，它在 2.8 版本中加入了指令——scan。</p><p>scan 相比 keys 具备有以下特点:</p><ul><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li><li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li></ul><h1 id="scan-基础使用"><a href="#scan-基础使用" class="headerlink" title="scan 基础使用"></a>scan 基础使用</h1><p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong></p><p>初始执行scan命令例如scan 0。SCAN命令是一个基于游标的迭代器。</p><p>这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。</p><p>当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，</p><p>表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。</p><blockquote><p>scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。</p><p>第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。</p><p>一直遍历到返回的 cursor 值为 0 时结束。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli scan 0 match key99* count 1000</div><div class="line">1) <span class="string">"13912"</span></div><div class="line">2)  1) <span class="string">"key997"</span></div><div class="line">    2) <span class="string">"key9906"</span></div><div class="line">    3) <span class="string">"key9957"</span></div><div class="line">    4) <span class="string">"key9902"</span></div><div class="line">    5) <span class="string">"key9971"</span></div><div class="line">    6) <span class="string">"key9935"</span></div><div class="line">    7) <span class="string">"key9958"</span></div><div class="line">    8) <span class="string">"key9928"</span></div><div class="line">    9) <span class="string">"key9931"</span></div><div class="line">   10) <span class="string">"key9961"</span></div><div class="line">   11) <span class="string">"key9948"</span></div><div class="line">   12) <span class="string">"key9965"</span></div><div class="line">   13) <span class="string">"key9937"</span></div><div class="line">   </div><div class="line"><span class="variable">$redis</span>-cli scan 13912 match key99* count 1000</div><div class="line">1) <span class="string">"5292"</span></div><div class="line">2)  1) <span class="string">"key996"</span></div><div class="line">    2) <span class="string">"key9960"</span></div><div class="line">    3) <span class="string">"key9973"</span></div><div class="line">    4) <span class="string">"key9978"</span></div><div class="line">    5) <span class="string">"key9927"</span></div><div class="line">    6) <span class="string">"key995"</span></div><div class="line">    7) <span class="string">"key9992"</span></div><div class="line">    8) <span class="string">"key9993"</span></div><div class="line">    9) <span class="string">"key9964"</span></div><div class="line">   10) <span class="string">"key9934"</span></div></pre></td></tr></table></figure><blockquote><p>返回结果分为两个部分：第一部分即 1) 就是下一次迭代游标，第二部分即 2) 就是本次迭代结果集。</p></blockquote><p>从上面的过程可以看到虽然提供的 limit 是 1000，但是返回的结果只有 10 个左右。</p><p>因为这个 limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。</p><p>如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli scan 0 match key99* count 10</div><div class="line">1) <span class="string">"15360"</span></div><div class="line">2) (empty list or <span class="built_in">set</span>)</div><div class="line"></div><div class="line"><span class="variable">$redis</span>-cli scan 15360 match key99* count 10</div><div class="line">1) <span class="string">"2304"</span></div><div class="line">2) (empty list or <span class="built_in">set</span>)</div></pre></td></tr></table></figure><h1 id="更多的-scan-指令"><a href="#更多的-scan-指令" class="headerlink" title="更多的 scan 指令"></a>更多的 scan 指令</h1><p>scan 指令是一系列指令，除了可以遍历所有的 key 之外，还可以对指定的容器集合进行遍历。</p><p>zscan 遍历 zset 集合元素，</p><p>hscan 遍历 hash 字典的元素、</p><p>sscan 遍历 set 集合的元素。</p><p><strong>注意点：</strong></p><p>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</p><p>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</p><h1 id="大-key-扫描"><a href="#大-key-扫描" class="headerlink" title="大 key 扫描"></a>大 key 扫描</h1><p>有时候会因为业务人员使用不当，在 Redis 实例中会形成很大的对象，比如一个很大的 hash，一个很大的 zset 这都是经常出现的。</p><p>这样的对象对 Redis 的集群数据迁移带来了很大的问题，因为在集群环境下，如果某个 key 太大，会让数据导致迁移卡顿。</p><p>另外在内存分配上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一块内存，这也会导致卡顿。</p><p>如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p><p><strong>在平时的业务开发中，要尽量避免大 key 的产生。</strong></p><p>如果你观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的，这时候你就需要定位出具体是那个 key，</p><p>进一步定位出具体的业务来源，然后再改进相关业务代码设计。</p><p><strong>那如何定位大 key 呢？</strong></p><p>为了避免对线上 Redis 带来卡顿，这就要用到 scan 指令，对于扫描出来的每一个 key，使用 type 指令获得 key 的类型，</p><p>然后使用相应数据结构的 size 或者 len 方法来得到它的大小，对于每一种类型，保留大小的前 N 名作为扫描结果展示出来。</p><p>上面这样的过程需要编写脚本，比较繁琐，不过 Redis 官方已经在 redis-cli 指令中提供了这样的扫描功能，我们可以直接拿来即用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli  --bigkeys</div><div class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></div><div class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></div><div class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></div><div class="line"></div><div class="line">[00.00%] Biggest string found so far <span class="string">'key316'</span> with 3 bytes</div><div class="line">[00.00%] Biggest string found so far <span class="string">'key7806'</span> with 4 bytes</div><div class="line">[12.79%] Biggest zset   found so far <span class="string">'salary'</span> with 1 members</div><div class="line">[13.19%] Biggest string found so far <span class="string">'counter:__rand_int__'</span> with 6 bytes</div><div class="line">[13.50%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'websit'</span> with 2 fields</div><div class="line">[14.37%] Biggest <span class="built_in">set</span>    found so far <span class="string">'bbs'</span> with 3 members</div><div class="line">[14.67%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'website'</span> with 3 fields</div><div class="line">[30.41%] Biggest list   found so far <span class="string">'mylist'</span> with 100000 items</div><div class="line">[95.53%] Biggest zset   found so far <span class="string">'page_rank'</span> with 3 members</div><div class="line"></div><div class="line">-------- summary -------</div><div class="line"></div><div class="line">Sampled 10019 keys <span class="keyword">in</span> the keyspace!</div><div class="line">Total key length <span class="keyword">in</span> bytes is 68990 (avg len 6.89)</div><div class="line"></div><div class="line">Biggest string found <span class="string">'counter:__rand_int__'</span> has 6 bytes</div><div class="line">Biggest   list found <span class="string">'mylist'</span> has 100000 items</div><div class="line">Biggest    <span class="built_in">set</span> found <span class="string">'bbs'</span> has 3 members</div><div class="line">Biggest   <span class="built_in">hash</span> found <span class="string">'website'</span> has 3 fields</div><div class="line">Biggest   zset found <span class="string">'page_rank'</span> has 3 members</div><div class="line"></div><div class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</div><div class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</div><div class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</div><div class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</div><div class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</div></pre></td></tr></table></figure><p>如果你担心这个指令会大幅抬升 Redis 的 ops 导致线上报警，还可以增加一个休眠参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli  --bigkeys -i 0.1</div><div class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></div><div class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></div><div class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></div><div class="line"></div><div class="line">[00.00%] Biggest string found so far <span class="string">'key316'</span> with 3 bytes</div><div class="line">[00.00%] Biggest string found so far <span class="string">'key7806'</span> with 4 bytes</div><div class="line">[12.79%] Biggest zset   found so far <span class="string">'salary'</span> with 1 members</div><div class="line">[13.19%] Biggest string found so far <span class="string">'counter:__rand_int__'</span> with 6 bytes</div><div class="line">[13.50%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'websit'</span> with 2 fields</div><div class="line">[14.37%] Biggest <span class="built_in">set</span>    found so far <span class="string">'bbs'</span> with 3 members</div><div class="line">[14.67%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'website'</span> with 3 fields</div><div class="line">[30.41%] Biggest list   found so far <span class="string">'mylist'</span> with 100000 items</div><div class="line">[95.53%] Biggest zset   found so far <span class="string">'page_rank'</span> with 3 members</div><div class="line"></div><div class="line">-------- summary -------</div><div class="line"></div><div class="line">Sampled 10019 keys <span class="keyword">in</span> the keyspace!</div><div class="line">Total key length <span class="keyword">in</span> bytes is 68990 (avg len 6.89)</div><div class="line"></div><div class="line">Biggest string found <span class="string">'counter:__rand_int__'</span> has 6 bytes</div><div class="line">Biggest   list found <span class="string">'mylist'</span> has 100000 items</div><div class="line">Biggest    <span class="built_in">set</span> found <span class="string">'bbs'</span> has 3 members</div><div class="line">Biggest   <span class="built_in">hash</span> found <span class="string">'website'</span> has 3 fields</div><div class="line">Biggest   zset found <span class="string">'page_rank'</span> has 3 members</div><div class="line"></div><div class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</div><div class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</div><div class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</div><div class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</div><div class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</div></pre></td></tr></table></figure><p>上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。</p><p>需要注意的是，这个bigkeys得到的最大，不一定是最大。</p><p>说明原因前，首先说明bigkeys的原理，非常简单，通过scan命令遍历，各种不同数据结构的key，分别通过不同的命令得到最大的key：</p><ul><li>如果是string结构，通过strlen判断；</li><li>如果是list结构，通过llen判断；</li><li>如果是hash结构，通过hlen判断；</li><li>如果是set结构，通过scard判断；</li><li>如果是sorted set结构，通过zcard判断。</li></ul><blockquote><p>正因为这样的判断方式，虽然string结构肯定可以正确的筛选出最占用缓存，也可以说最大的key。</p><p>但是list不一定，例如，现在有两个list类型的key，分别是：numberlist–[0,1,2]，stringlist–[“123456789123456789”]，</p><p>由于通过llen判断，所以numberlist要大于stringlist。</p><p>而事实上stringlist更占用内存。其他三种数据结构hash，set，sorted set都会存在这个问题。</p><p>使用bigkeys一定要注意这一点。</p></blockquote><h3 id="slowlog命令"><a href="#slowlog命令" class="headerlink" title="slowlog命令"></a>slowlog命令</h3><p>上面提到不能使用keys命令，如果就有开发这么做了呢，我们如何得知？</p><p>与其他任意存储系统例如mysql，mongodb可以查看慢日志一样，redis也可以，即通过命令slowlog。</p><p>用法如下</p><p><strong>SLOWLOG subcommand [argument]</strong></p><p>subcommand主要有：</p><ul><li>get，用法：slowlog get [argument]，获取argument参数指定数量的慢日志。</li><li>len，用法：slowlog len，总慢日志数量。</li><li>reset，用法：slowlog reset，清空慢日志。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli slowlog get 5</div><div class="line">1) 1) (<span class="built_in">integer</span>) 2</div><div class="line">   2) (<span class="built_in">integer</span>) 1537786953</div><div class="line">   3) (<span class="built_in">integer</span>) 17980</div><div class="line">   4) 1) <span class="string">"scan"</span></div><div class="line">      2) <span class="string">"0"</span></div><div class="line">      3) <span class="string">"match"</span></div><div class="line">      4) <span class="string">"key99*"</span></div><div class="line">      5) <span class="string">"count"</span></div><div class="line">      6) <span class="string">"1000"</span></div><div class="line">   5) <span class="string">"127.0.0.1:50129"</span></div><div class="line">   6) <span class="string">""</span></div><div class="line">2) 1) (<span class="built_in">integer</span>) 1</div><div class="line">   2) (<span class="built_in">integer</span>) 1537785886</div><div class="line">   3) (<span class="built_in">integer</span>) 39537</div><div class="line">   4) 1) <span class="string">"keys"</span></div><div class="line">      2) <span class="string">"*"</span></div><div class="line">   5) <span class="string">"127.0.0.1:49701"</span></div><div class="line">   6) <span class="string">""</span></div><div class="line">3) 1) (<span class="built_in">integer</span>) 0</div><div class="line">   2) (<span class="built_in">integer</span>) 1537681701</div><div class="line">   3) (<span class="built_in">integer</span>) 18276</div><div class="line">   4) 1) <span class="string">"ZADD"</span></div><div class="line">      2) <span class="string">"page_rank"</span></div><div class="line">      3) <span class="string">"10"</span></div><div class="line">      4) <span class="string">"google.com"</span></div><div class="line">   5) <span class="string">"127.0.0.1:52334"</span></div><div class="line">   6) <span class="string">""</span></div></pre></td></tr></table></figure><p>命令耗时超过多少才会保存到slowlog中，可以通过命令config set slowlog-log-slower-than 2000配置并且不需要重启redis。</p><p>注意：单位是微妙，2000微妙即2毫秒。</p><h3 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h3><p>为了防止把问题带到生产环境，我们可以通过配置文件重命名一些危险命令，</p><p>例如keys等一些高危命令。操作非常简单，</p><p>只需要在conf配置文件增加如下所示配置即可：</p><blockquote><p>rename-command flushdb flushddbb</p><p>rename-command flushall flushallall</p><p>rename-command keys keysys</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/carbon.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十八篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;了解下redis的更多用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://zhangslob.github.io/categories/redis/"/>
    
    
  </entry>
  
</feed>
