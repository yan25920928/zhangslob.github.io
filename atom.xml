<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小歪的博客</title>
  
  <subtitle>人生苦短，我学Python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangslob.github.io/"/>
  <updated>2019-12-27T03:13:32.809Z</updated>
  <id>https://zhangslob.github.io/</id>
  
  <author>
    <name>崔斯特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>找出数组中重复的数字</title>
    <link href="https://zhangslob.github.io/2019/12/26/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://zhangslob.github.io/2019/12/26/找出数组中重复的数字/</id>
    <published>2019-12-26T08:44:27.000Z</published>
    <updated>2019-12-27T03:13:32.809Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零八篇原创文章</code></pre><p>努力、奋斗  (๑• . •๑)</p><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><a id="more"></a><h1 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 <code>7</code> 的数组 <code>{2, 3, 1, 0, 2, 5, 3}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>排序后，顺序扫描，判断是否有重复，时间复杂度为 <code>O(n²)</code>。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>利用哈希表，遍历数组，如果哈希表中没有该元素，则存入哈希表中，否则返回重复的元素。时间复杂度为 <code>O(n)</code>，空间复杂度为 <code>O(n)</code>。</p><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>长度为 <code>n</code>，元素的数值范围也为 <code>n</code>，如果没有重复元素，那么数组每个下标对应的值与下标相等。</p><p>从头到尾遍历数组，当扫描到下标 <code>i</code> 的数字 <code>nums[i]</code>：</p><ul><li>如果等于 <code>i</code>，继续向下扫描；</li><li>如果不等于 <code>i</code>，拿它与第 <code>nums[i]</code> 个数进行比较，如果相等，说明有重复值，返回 <code>nums[i]</code>。如果不相等，就把第 <code>i</code> 个数 和第 <code>nums[i]</code> 个数交换。重复这个比较交换的过程。</li></ul><p>此算法时间复杂度为 <code>O(n)</code>，因为每个元素最多只要两次交换，就能确定位置。空间复杂度为 <code>O(1)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (array[i] != i) &#123;</div><div class="line">                <span class="keyword">if</span> (array[i] == array[array[i]]) &#123;</div><div class="line">                    <span class="keyword">return</span> array[i];</div><div class="line">                &#125;</div><div class="line">                swap(array, i, array[i]);</div><div class="line">                System.out.println(Arrays.toString(array));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = t;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码中有一个两重循环，但每个数字最多只要交换两次就可以找到属于自己的位置，因此时间复杂度是O(n)。不需要额外分配内存，空间复杂度是O(1)。</p><p>Output<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[1, 3, 2, 0, 2, 5, 3]</div><div class="line">[3, 1, 2, 0, 2, 5, 3]</div><div class="line">[0, 1, 2, 3, 2, 5, 3]</div><div class="line">2</div></pre></td></tr></table></figure></p><p>以数组[2, 3, 1, 0, 2, 5, 3]为例来分析找到重复数字的步骤：</p><ol><li>数组的第 0 个数字（从 0 开始计数，和数组的下标保持一致）是 2，与它的下标不相等，于是把它和下标为 2 的数字 1 交换。交换之后的数组是[1, 3, 2, 0, 2, 5, 3]。</li><li>此时第 0 个数字是 1，仍然与它的下标不相等，继续把它和下标为 1 的数字 3 交换，得到数组[3, 1, 2, 0, 2, 5, 3]</li><li>接下来继续交换第 0 个数字 3 和第 3 个数字 0，得到数组[0, 1, 2, 3, 2, 5, 3]。</li><li>此时第 0 个数字的数值为 0，接着扫描下一个数字。在接下来的几个数字中，下标为 1，2，3 的三个数字分别为 1，2，3 它们的下标和数值都分别相等，因此不需要做任何操作。</li><li>接下来扫描到下标为 4 的数字 2。由于它的数值与它的下标不相等，再比较它和下标为 2 的数字。注意到此时数组中下标为 2 的数字也是 2，也就是数字在下标为 2 和下标为 4 的两个位置都出现了，因此找到一个重复的数字。</li></ol><p>本题关键是：<strong>在一个长度为 <code>n</code> 的数组里的所有数字都在 <code>0</code> 到 <code>n-1</code> 的范围内并且有重复</strong>，这说明数组是可以排序的，把每个数字交换到自己应该在的位置，排序时就能找到重复字段。理想状态下的情况：[0, 1, 2, 3, 4, x, x, x]</p><p>Python解法更简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</div><div class="line">        <span class="keyword">while</span> arr[i] != i:</div><div class="line">            tmp = arr[i]</div><div class="line">            <span class="keyword">if</span> tmp == arr[tmp]:</div><div class="line">                <span class="keyword">return</span> tmp</div><div class="line">            arr[i], arr[tmp] = arr[tmp], arr[i]</div><div class="line">            print(arr)</div><div class="line"></div><div class="line"></div><div class="line">print(solution([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>]))</div></pre></td></tr></table></figure><h1 id="不修改数组找出重复的数字"><a href="#不修改数组找出重复的数字" class="headerlink" title="不修改数组找出重复的数字"></a>不修改数组找出重复的数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n+1</code> 的数组里的所有数字都在 <code>1</code> 到 <code>n</code> 的范围内，数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 <code>8</code> 的数组 <code>{2, 3, 5, 4, 3, 2, 6, 7}</code>，那么对应的输出是重复的数字 <code>2</code> 或者 <code>3</code>。</p><h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h3><p>创建长度为 <code>n+1</code> 的辅助数组，把原数组的元素复制到辅助数组中。如果原数组被复制的数是 <code>m</code>，则放到辅助数组第 <code>m</code> 个位置。这样很容易找出重复元素。空间复杂度为 <code>O(n)</code>。</p><h3 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h3><p>数组元素的取值范围是 <code>[1, n]</code>，对该范围对半划分，分成 <code>[1, middle]</code>, <code>[middle+1, n]</code>。计算数组中有多少个(count)元素落在 <code>[1, middle]</code> 区间内，如果 <code>count</code> 大于 <code>middle</code>，那么说明这个范围内有重复元素，否则在另一个范围内。继续对这个范围对半划分，继续统计区间内元素数量。</p><p>时间复杂度 O(n * log n)，空间复杂度 O(1)。</p><p>注意，此方法无法找出所有重复的元素。如果左右半区同时存在重复值，先算哪个半区就会先得到哪边的重复值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> zhujian on 2019/12/26.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</div><div class="line">            <span class="keyword">int</span> middle = start + ((end - start) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> count = countRange(array, start, middle);</div><div class="line">            <span class="keyword">if</span> (end == start) &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> start;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; (middle - start) + <span class="number">1</span>) &#123;</div><div class="line">                    end = middle;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = middle + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</div><div class="line">            <span class="keyword">if</span> (i &gt;= start &amp;&amp; i &lt;= end) &#123;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</div><div class="line">        <span class="keyword">int</span> res = <span class="keyword">new</span> Solution().findDuplicate(arr);</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>按照二分法查找的思路，如果输出长度为<code>n</code>的数组，那么函数<code>countRange</code>将被调用<code>O(log n)</code>次，每次需要<code>O(n)</code>时间，因此总的时间复杂度是<code>O(nlog n)</code> ，空间复杂度是<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零八篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;努力、奋斗  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://zhangslob.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>大数据学习路线</title>
    <link href="https://zhangslob.github.io/2019/12/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>https://zhangslob.github.io/2019/12/06/大数据学习路线/</id>
    <published>2019-12-06T02:34:57.481Z</published>
    <updated>2019-12-06T02:40:07.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><pre><code>这是崔斯特的第一百零七篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="大数据处理流程"><a href="#大数据处理流程" class="headerlink" title="大数据处理流程"></a>大数据处理流程</h1><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt=""></p><p>上图是一个简化的大数据处理流程图，大数据处理的主要流程包括数据收集、数据存储、数据处理、数据应用等主要环节。下面我们逐一对各个环节所需要的技术栈进行讲解：</p><h2 id="1-1-数据收集"><a href="#1-1-数据收集" class="headerlink" title="1.1 数据收集"></a>1.1 数据收集</h2><p>大数据处理的第一步是数据的收集。现在的中大型项目通常采用微服务架构进行分布式部署，所以数据的采集需要在多台服务器上进行，且采集过程不能影响正常业务的开展。基于这种需求，就衍生了多种日志收集工具，如 Flume 、Logstash、Kibana 等，它们都能通过简单的配置完成复杂的数据收集和数据聚合。</p><h2 id="1-2-数据存储"><a href="#1-2-数据存储" class="headerlink" title="1.2 数据存储"></a>1.2 数据存储</h2><p>收集到数据后，下一个问题就是：数据该如何进行存储？通常大家最为熟知是 MySQL、Oracle 等传统的关系型数据库，它们的优点是能够快速存储结构化的数据，并支持随机访问。但大数据的数据结构通常是半结构化（如日志数据）、甚至是非结构化的（如视频、音频数据），为了解决海量半结构化和非结构化数据的存储，衍生了 Hadoop HDFS 、KFS、GFS 等分布式文件系统，它们都能够支持结构化、半结构和非结构化数据的存储，并可以通过增加机器进行横向扩展。</p><p>分布式文件系统完美地解决了海量数据存储的问题，但是一个优秀的数据存储系统需要同时考虑数据存储和访问两方面的问题，比如你希望能够对数据进行随机访问，这是传统的关系型数据库所擅长的，但却不是分布式文件系统所擅长的，那么有没有一种存储方案能够同时兼具分布式文件系统和关系型数据库的优点，基于这种需求，就产生了 HBase、MongoDB。</p><h2 id="1-3-数据分析"><a href="#1-3-数据分析" class="headerlink" title="1.3 数据分析"></a>1.3 数据分析</h2><p>大数据处理最重要的环节就是数据分析，数据分析通常分为两种：批处理和流处理。</p><ul><li><strong>批处理</strong>：对一段时间内海量的离线数据进行统一的处理，对应的处理框架有 Hadoop MapReduce、Spark、Flink 等；</li><li><strong>流处理</strong>：对运动中的数据进行处理，即在接收数据的同时就对其进行处理，对应的处理框架有 Storm、Spark Streaming、Flink Streaming 等。</li></ul><p>批处理和流处理各有其适用的场景，时间不敏感或者硬件资源有限，可以采用批处理；时间敏感和及时性要求高就可以采用流处理。随着服务器硬件的价格越来越低和大家对及时性的要求越来越高，流处理越来越普遍，如股票价格预测和电商运营数据分析等。</p><p>上面的框架都是需要通过编程来进行数据分析，那么如果你不是一个后台工程师，是不是就不能进行数据的分析了？当然不是，大数据是一个非常完善的生态圈，有需求就有解决方案。为了能够让熟悉 SQL 的人员也能够进行数据的分析，查询分析框架应运而生，常用的有 Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix 等。这些框架都能够使用标准的 SQL 或者 类 SQL 语法灵活地进行数据的查询分析。这些 SQL 经过解析优化后转换为对应的作业程序来运行，如 Hive 本质上就是将 SQL 转换为 MapReduce 作业，Spark SQL 将 SQL 转换为一系列的 RDDs 和转换关系（transformations），Phoenix 将 SQL 查询转换为一个或多个 HBase Scan。</p><h2 id="1-4-数据应用"><a href="#1-4-数据应用" class="headerlink" title="1.4 数据应用"></a>1.4 数据应用</h2><p>数据分析完成后，接下来就是数据应用的范畴，这取决于你实际的业务需求。比如你可以将数据进行可视化展现，或者将数据用于优化你的推荐算法，这种运用现在很普遍，比如短视频个性化推荐、电商商品推荐、头条新闻推荐等。当然你也可以将数据用于训练你的机器学习模型，这些都属于其他领域的范畴，都有着对应的框架和技术栈进行处理，这里就不一一赘述。</p><h2 id="1-5-其他框架"><a href="#1-5-其他框架" class="headerlink" title="1.5 其他框架"></a>1.5 其他框架</h2><p>上面是一个标准的大数据处理流程所用到的技术框架。但是实际的大数据处理流程比上面复杂很多，针对大数据处理中的各种复杂问题分别衍生了各类框架：</p><ul><li>单机的处理能力都是存在瓶颈的，所以大数据框架都是采用集群模式进行部署，为了更方便的进行集群的部署、监控和管理，衍生了 Ambari、Cloudera Manager 等集群管理工具；</li><li>想要保证集群高可用，需要用到 ZooKeeper ，ZooKeeper 是最常用的分布式协调服务，它能够解决大多数集群问题，包括首领选举、失败恢复、元数据存储及其一致性保证。同时针对集群资源管理的需求，又衍生了 Hadoop YARN ;</li><li>复杂大数据处理的另外一个显著的问题是，如何调度多个复杂的并且彼此之间存在依赖关系的作业？基于这种需求，产生了 Azkaban 和 Oozie 等工作流调度框架；</li><li>大数据流处理中使用的比较多的另外一个框架是 Kafka，它可以用于消峰，避免在秒杀等场景下并发数据对流处理程序造成冲击；</li><li>另一个常用的框架是 Sqoop ，主要是解决了数据迁移的问题，它能够通过简单的命令将关系型数据库中的数据导入到 HDFS 、Hive 或 HBase 中，或者从 HDFS 、Hive 导出到关系型数据库上。</li></ul><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><p>介绍完大数据框架，接着就可以介绍其对应的学习路线了，主要分为以下几个方面：</p><h2 id="2-1-语言基础"><a href="#2-1-语言基础" class="headerlink" title="2.1 语言基础"></a>2.1 语言基础</h2><h3 id="1-Java"><a href="#1-Java" class="headerlink" title="1.  Java"></a>1.  Java</h3><p>大数据框架大多采用 Java 语言进行开发，并且几乎全部的框架都会提供 Java API 。Java 是目前比较主流的后台开发语言，所以网上免费的学习资源也比较多。如果你习惯通过书本进行学习，这里推荐以下入门书籍：</p><ul><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="external">《Java 编程的逻辑》</a>：这里一本国人编写的系统入门 Java 的书籍，深入浅出，内容全面；</li><li>《Java 核心技术》：目前最新的是第 10 版，有<a href="https://book.douban.com/subject/26880667/" target="_blank" rel="external">卷一</a> 和<a href="https://book.douban.com/subject/27165931/" target="_blank" rel="external">卷二</a> 两册，卷二可以选择性阅读，因为其中很多章节的内容在实际开发中很少用到。</li></ul><p>目前大多数框架要求 Java 版本至少是 1.8，这是由于 Java 1.8 提供了函数式编程，使得可以用更精简的代码来实现之前同样的功能，比如你调用 Spark API，使用 1.8 可能比 1.7 少数倍的代码，所以这里额外推荐阅读 <a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8 实战》</a> 这本书籍。</p><h3 id="2-Scala"><a href="#2-Scala" class="headerlink" title="2. Scala"></a>2. Scala</h3><p>Scala 是一门综合了面向对象和函数式编程概念的静态类型的编程语言，它运行在 Java 虚拟机上，可以与所有的 Java 类库无缝协作，著名的 Kafka 就是采用 Scala 语言进行开发的。</p><p>为什么需要学习 Scala 语言 ？ 这是因为当前最火的计算框架 Flink 和 Spark 都提供了 Scala 语言的接口，使用它进行开发，比使用 Java 8 所需要的代码更少，且 Spark 就是使用 Scala 语言进行编写的，学习 Scala 可以帮助你更深入的理解 Spark。同样的，对于习惯书本学习的小伙伴，这里推荐两本入门书籍：</p><ul><li><a href="https://book.douban.com/subject/27093751/" target="_blank" rel="external">《快学 Scala(第 2 版)》</a> </li><li><a href="https://book.douban.com/subject/27591387/" target="_blank" rel="external">《Scala 编程 (第 3 版)》</a> </li></ul><blockquote><p>这里说明一下，如果你的时间有限，不一定要学完 Scala 才去学习大数据框架。Scala 确实足够的精简和灵活，但其在语言复杂度上略大于 Java，例如隐式转换和隐式参数等概念在初次涉及时会比较难以理解，所以你可以在了解 Spark 后再去学习 Scala，因为类似隐式转换等概念在 Spark 源码中有大量的运用。</p></blockquote><h2 id="2-2-Linux-基础"><a href="#2-2-Linux-基础" class="headerlink" title="2.2 Linux 基础"></a>2.2 Linux 基础</h2><p>通常大数据框架都部署在 Linux 服务器上，所以需要具备一定的 Linux 知识。Linux 书籍当中比较著名的是 《鸟哥私房菜》系列，这个系列很全面也很经典。但如果你希望能够快速地入门，这里推荐<a href="https://www.linuxprobe.com/" target="_blank" rel="external">《Linux 就该这么学》</a>，其网站上有免费的电子书版本。</p><h2 id="2-3-构建工具"><a href="#2-3-构建工具" class="headerlink" title="2.3  构建工具"></a>2.3  构建工具</h2><p>这里需要掌握的自动化构建工具主要是 Maven。Maven 在大数据场景中使用比较普遍，主要在以下三个方面：</p><ul><li>管理项目 JAR 包，帮助你快速构建大数据应用程序；</li><li>不论你的项目是使用 Java 语言还是 Scala 语言进行开发，提交到集群环境运行时，都需要使用 Maven 进行编译打包；</li><li>大部分大数据框架使用 Maven 进行源码管理，当你需要从其源码编译出安装包时，就需要使用到 Maven。</li></ul><h2 id="2-4-框架学习"><a href="#2-4-框架学习" class="headerlink" title="2.4 框架学习"></a>2.4 框架学习</h2><h3 id="1-框架分类"><a href="#1-框架分类" class="headerlink" title="1. 框架分类"></a>1. 框架分类</h3><p>上面我们介绍了很多大数据框架，这里进行一下分类总结：</p><p><strong>日志收集框架</strong>：Flume 、Logstash、Kibana</p><p><strong>分布式文件存储系统</strong>：Hadoop HDFS</p><p><strong>数据库系统</strong>：Mongodb、HBase</p><p><strong>分布式计算框架</strong>：</p><ul><li>批处理框架：Hadoop MapReduce</li><li>流处理框架：Storm</li><li>混合处理框架：Spark、Flink</li></ul><p><strong>查询分析框架</strong>：Hive 、Spark SQL 、Flink SQL、 Pig、Phoenix </p><p><strong>集群资源管理器</strong>：Hadoop YARN</p><p><strong>分布式协调服务</strong>：Zookeeper</p><p><strong>数据迁移工具</strong>：Sqoop</p><p><strong>任务调度框架</strong>：Azkaban、Oozie</p><p><strong>集群部署和监控</strong>：Ambari、Cloudera Manager</p><p>上面列出的都是比较主流的大数据框架，社区都很活跃，学习资源也比较丰富。建议从 Hadoop 开始入门学习，因为它是整个大数据生态圈的基石，其它框架都直接或者间接依赖于 Hadoop 。接着就可以学习计算框架，Spark 和 Flink 都是比较主流的混合处理框架，Spark 出现得较早，所以其应用也比较广泛。 Flink 是当下最火热的新一代的混合处理框架，其凭借众多优异的特性得到了众多公司的青睐。两者可以按照你个人喜好或者实际工作需要进行学习。</p><p><img src="https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/HADOOP-ECOSYSTEM-Edureka.png" alt=""></p><blockquote><p><em>图片引用自</em> ：<em><a href="https://www.edureka.co/blog/hadoop-ecosystem" target="_blank" rel="external">https://www.edureka.co/blog/hadoop-ecosystem</a></em></p></blockquote><p>至于其它框架，在学习上并没有特定的先后顺序，如果你的学习时间有限，建议初次学习时候，同一类型的框架掌握一种即可，比如日志收集框架就有很多种，初次学习时候只需要掌握一种，能够完成日志收集的任务即可，之后工作上有需要可以再进行针对性地学习。</p><h3 id="2-学习资料"><a href="#2-学习资料" class="headerlink" title="2.  学习资料"></a>2.  学习资料</h3><p>大数据最权威和最全面的学习资料就是官方文档。热门的大数据框架社区都比较活跃、版本更新迭代也比较快，所以其出版物都明显滞后于其实际版本，基于这个原因采用书本学习不是一个最好的方案。比较庆幸的是，大数据框架的官方文档都写的比较好，内容完善，重点突出，同时都采用了大量配图进行辅助讲解。当然也有一些优秀的书籍历经时间的检验，至今依然很经典，这里列出部分个人阅读过的经典书籍：</p><ul><li><a href="https://book.douban.com/subject/27115351/" target="_blank" rel="external">《hadoop 权威指南 (第四版)》</a> 2017 年</li><li><a href="https://book.douban.com/subject/27665114/" target="_blank" rel="external">《Kafka 权威指南》</a> 2017 年</li><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="external">《从 Paxos 到 Zookeeper  分布式一致性原理与实践》</a>  2015 年</li><li><a href="https://book.douban.com/subject/26649141/" target="_blank" rel="external">《Spark 技术内幕  深入解析 Spark 内核架构设计与实现原理》</a> 2015 年</li><li><a href="https://book.douban.com/subject/27035127/" target="_blank" rel="external">《Spark.The.Definitive.Guide》</a> 2018 年</li><li><a href="https://book.douban.com/subject/10748460/" target="_blank" rel="external">《HBase 权威指南》</a> 2012 年</li><li><a href="https://book.douban.com/subject/25791255/" target="_blank" rel="external">《Hive 编程指南》</a> 2013 年</li></ul><h3 id="3-视频学习资料"><a href="#3-视频学习资料" class="headerlink" title="3. 视频学习资料"></a>3. 视频学习资料</h3><p>上面我推荐的都是书籍学习资料，很少推荐视频学习资料，这里说明一下原因：因为书籍历经时间的考验，能够再版的或者豆瓣等平台评价高的证明都是被大众所认可的，从概率的角度上来说，其必然更加优秀，不容易浪费大家的学习时间和精力，所以我个人更倾向于官方文档或者书本的学习方式，而不是视频。因为视频学习资料，缺少一个公共的评价平台和完善的评价机制，所以其质量良莠不齐。但是视频任然有其不可替代的好处，学习起来更直观、印象也更深刻，所以对于习惯视频学习的小伙伴，这里我各推荐一个免费的和付费的视频学习资源，大家按需选择：</p><ul><li>免费学习资源：尚硅谷大数据学习路线 ——  <a href="http://www.atguigu.com/bigdata_video.shtml#bigdata" target="_blank" rel="external">下载链接</a> \ <a href="https://space.bilibili.com/302417610/" target="_blank" rel="external">在线观看链接</a></li><li>付费学习资源：<a href="https://www.imooc.com/t/2781843" target="_blank" rel="external">慕课网 Michael PK 的系列课程</a></li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>这里推荐一些大数据常用的开发工具：</p><p><strong>Java IDE</strong>：IDEA  和 Eclipse 都可以。从个人使用习惯而言，更倾向于 IDEA ;</p><p><strong>VirtualBox</strong>：在学习过程中，你可能经常要在虚拟机上搭建服务和集群。VirtualBox 是一款开源、免费的虚拟机管理软件，虽然是轻量级软件，但功能很丰富，基本能够满足日常的使用需求；</p><p><strong>MobaXterm</strong>：大数据的框架通常都部署在服务器上，这里推荐使用 MobaXterm 进行连接。同样是免费开源的，支持多种连接协议，支持拖拽上传文件，支持使用插件扩展；</p><p><strong>Translate Man</strong>：一款浏览器上免费的翻译插件 (谷歌和火狐均支持)。它采用谷歌的翻译接口，准确性非常高，支持划词翻译，可以辅助进行官方文档的阅读。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是个人关于大数据的学习心得和路线推荐。本片文章对大数据技术栈做了比较狭义的限定，随着学习的深入，大家也可以把 Python 语言、推荐系统、机器学习等逐步加入到自己的大数据技术栈中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零七篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://zhangslob.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-394-字符串解码</title>
    <link href="https://zhangslob.github.io/2019/11/28/Leetcode-394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://zhangslob.github.io/2019/11/28/Leetcode-394-字符串解码/</id>
    <published>2019-11-28T03:46:18.174Z</published>
    <updated>2019-11-28T07:57:01.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><pre><code>这是崔斯特的第一百零六篇原创文章</code></pre><p><code>努力、奋斗</code><br><a id="more"></a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像<code>3a</code>或<code>2[4]</code>的输入。</p><p><strong>示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</div><div class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</div><div class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</div></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">输入:<span class="string">'3[a2[c]]'</span></div><div class="line">初始化栈: 栈nums 存要重复的次数k,栈str 存字符串</div><div class="line"></div><div class="line">遍历字符串:</div><div class="line">指针指向字符<span class="string">'3'</span>,为数字</div><div class="line">num暂存数字3</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'['</span></div><div class="line">循环次数num入栈nums，空字符串res入栈str</div><div class="line">nums: 3        res: <span class="string">''</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'a'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'a'</span>,res=<span class="string">'a'</span></div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'2'</span>,为数字</div><div class="line">num暂存数字2</div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">'['</span></div><div class="line">num入栈nums,res入栈str</div><div class="line">nums: 3 -&gt; 2    str: <span class="string">''</span> -&gt; <span class="string">'a'</span></div><div class="line">num置为0，str置空</div><div class="line"></div><div class="line">继续遍历,遇到字符<span class="string">'c'</span>,为字母</div><div class="line">空字符串res拼接字母<span class="string">'c'</span>,res=<span class="string">'c'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数2</div><div class="line">res = res*2 = <span class="string">'cc'</span></div><div class="line">str弹出栈顶元素<span class="string">'a'</span>与res拼接并入栈:</div><div class="line">res = <span class="string">'a'</span>+<span class="string">'cc'</span>=<span class="string">'acc'</span></div><div class="line">str: <span class="string">''</span> -&gt; <span class="string">'acc'</span></div><div class="line"></div><div class="line">继续遍历遇到字符<span class="string">']'</span></div><div class="line">nums弹出栈顶元素：当前字符串重复次数3</div><div class="line">res = res*3 = <span class="string">'accaccacc'</span></div><div class="line">str弹出栈顶元素空字符串<span class="string">''</span>与res拼接并入栈:</div><div class="line">res=<span class="string">''</span>+<span class="string">'accaccacc'</span>=<span class="string">'accaccacc'</span></div><div class="line">str: <span class="string">'accaccacc'</span></div><div class="line"></div><div class="line">结束返回res</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>由于重复次数可能大于10，所以暂存数字时要适当处理，如 <code>num*10+当前数字</code></li><li>在c++里可以直接修改拼接字符，但Java不支持运算符重载，可以借助 StringBuilder 或 StringBuffer 类。</li><li>用栈暂存的逻辑与递归基本一致，可以理解为用递归实现栈。</li><li>python没有栈这种数据结构，可以用 list() 数组或双端队列 deque()</li><li>python可以只用一个栈以元组的形式重复次数和字符串，如<code>(num,res)</code></li></ul><h2 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h2><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;StringBuilder&gt; str = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        Stack&lt;Integer&gt; nums = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'['</span>) &#123;</div><div class="line">                str.push(res);</div><div class="line">                nums.push(num);</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">                res = <span class="keyword">new</span> StringBuilder();</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</div><div class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.pop(); i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">                    stringBuilder.append(res);</div><div class="line">                &#125;</div><div class="line">                res = str.pop().append(stringBuilder);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (c - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                res.append(c);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        stack, res, num = [], <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> i.isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(i)</div><div class="line">            <span class="keyword">elif</span> i.isalpha():</div><div class="line">                res += i</div><div class="line">            <span class="keyword">elif</span> i == <span class="string">'['</span>:</div><div class="line">                stack.append((res, num))</div><div class="line">                res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                last_str, this_num = stack.pop()</div><div class="line">                res = last_str + this_num * res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line">c = Solution().decodeString(<span class="string">'3[a2[c]]'</span>)  <span class="comment"># aaabcbc</span></div><div class="line">print(c)</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>发现一种解法：倒序遍历字符串<code>s</code>，如果不是<code>[</code>则直接入栈；遇到<code>[</code>时，先找出<code>[</code>前边的数字<code>nums</code>表示为<code>k</code>，然后找出编码字符串<code>encodedStr</code>，重复<code>k</code>次入栈，跳过数字继续遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"strconv"</span></div><div class="line">   <span class="string">"strings"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">   stack := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">   <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; &#123;</div><div class="line">      <span class="keyword">if</span> s[i] == <span class="string">'['</span> &#123;</div><div class="line">         nums := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> j := i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</div><div class="line">            <span class="keyword">if</span> s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span> &#123;</div><div class="line">               nums = <span class="built_in">append</span>(nums, <span class="keyword">string</span>(s[j]))</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">         &#125;</div><div class="line">         reverse(nums)</div><div class="line">         k, _ := strconv.Atoi(strings.Join(nums, <span class="string">""</span>))</div><div class="line">         encodedStr := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</div><div class="line">         <span class="keyword">for</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != <span class="string">"]"</span> &#123;</div><div class="line">            encodedStr = <span class="built_in">append</span>(encodedStr, stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</div><div class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         &#125;</div><div class="line">         stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</div><div class="line">         reverse(encodedStr)</div><div class="line">         <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; k; j++ &#123;</div><div class="line">            stack = <span class="built_in">append</span>(stack, encodedStr...)</div><div class="line">         &#125;</div><div class="line">         i -= <span class="built_in">len</span>(nums)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">         stack = <span class="built_in">append</span>(stack, <span class="keyword">string</span>(s[i]))</div><div class="line">      &#125;</div><div class="line">      i -= <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   reverse(stack)</div><div class="line">   <span class="keyword">return</span> strings.Join(stack, <span class="string">""</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(arr []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">   length := <span class="built_in">len</span>(arr)</div><div class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length/<span class="number">2</span>; i++ &#123;</div><div class="line">      arr[i], arr[length-i<span class="number">-1</span>] = arr[length-i<span class="number">-1</span>], arr[i]</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   s := <span class="string">"3[a]2[bc]"</span></div><div class="line">   r := decodeString(s)</div><div class="line">   fmt.Println(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ZdIwN57.png" alt=""></p><p>惊了惊了，这么牛逼</p><h1 id="利用递归"><a href="#利用递归" class="headerlink" title="利用递归"></a>利用递归</h1><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><p>将 s.length() 的值以参数传递，减少重复调用 length() 造成的时间损耗</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> dfs(s.toCharArray(), s.length()).toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">'0'</span> &amp;&amp; chars[i] &lt;= <span class="string">'9'</span>) &#123;</div><div class="line">                num = num * <span class="number">10</span> + (chars[i] - <span class="string">'0'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">'['</span>) &#123;</div><div class="line">                StringBuilder tmp = dfs(chars, len);</div><div class="line">                <span class="keyword">while</span> (--num &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    str.append(tmp);</div><div class="line">                &#125;</div><div class="line">                num = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">']'</span>) &#123;</div><div class="line">                <span class="keyword">return</span> str;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                str.append(chars[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> str;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String s = <span class="string">"3[a]2[bc]"</span>;</div><div class="line">        System.out.println(<span class="keyword">new</span> Solution().decodeString(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    i = <span class="number">-1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s: str)</span> -&gt; str:</span></div><div class="line">        res, num = <span class="string">''</span>, <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> self.i &lt; len(s) - <span class="number">1</span>:</div><div class="line">            self.i += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> s[self.i].isdigit():</div><div class="line">                num = num * <span class="number">10</span> + int(s[self.i])</div><div class="line">            <span class="keyword">elif</span> s[self.i].isalpha():</div><div class="line">                res += s[self.i]</div><div class="line">            <span class="keyword">elif</span> s[self.i] == <span class="string">'['</span>:</div><div class="line">                res += self.decodeString(s) * num</div><div class="line">                num = <span class="number">0</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> res</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a]2[bc]'</span>) == <span class="string">'aaabcbc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'3[a2[c]]'</span>) == <span class="string">'accaccacc'</span></div><div class="line">    <span class="keyword">assert</span> Solution().decodeString(<span class="string">'2[abc]3[cd]ef'</span>) == <span class="string">'abcabccdcdcdef'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零六篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>抓包：淘宝、支付宝</title>
    <link href="https://zhangslob.github.io/2019/11/27/%E6%8A%93%E5%8C%85%EF%BC%9A%E6%B7%98%E5%AE%9D%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    <id>https://zhangslob.github.io/2019/11/27/抓包：淘宝、支付宝/</id>
    <published>2019-11-27T12:05:52.084Z</published>
    <updated>2019-11-27T12:27:44.327Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零五篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>Frida抓包技巧</code><br><a id="more"></a></p><p>对于淘宝、支付宝之类的App，想要直接抓包是不可能的，可以使用 frida 实现抓包。</p><h1 id="Frida介绍"><a href="#Frida介绍" class="headerlink" title="Frida介绍"></a>Frida介绍</h1><p>Frida是一款基于python + javascript 的hook框架，通杀android\ios\linux\win\osx等各平台，由于是基于脚本的交互，因此相比xposed和substrace cydia更加便捷。Frida的官网为：<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.frida.re%2F" target="_blank" rel="external">http://www.frida.re/</a></p><p>首先要保证你的android手机已经root。通过pip安装frida:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install frida</div></pre></td></tr></table></figure><p>adb连接手机，到 <a href="https://github.com/frida/frida/releases" target="_blank" rel="external">https://github.com/frida/frida/releases</a> 下载frida-server，根据情况选择android-arm 版本，安卓手机一般是是下载<code>android-arm</code>和<code>android-arm64</code>这两种。</p><p>push到android手机上并且运行，需要取得手机root权限</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">adb push frida-server /data/local/tmp/</div><div class="line">adb shell</div><div class="line">su</div><div class="line"><span class="built_in">cd</span> /data/local/tmp/</div><div class="line">chmod <span class="number">777</span> frida-server</div><div class="line">./frida-server</div></pre></td></tr></table></figure><p>到此为止环境已经搭建完毕。</p><h1 id="编写抓包脚本"><a href="#编写抓包脚本" class="headerlink" title="编写抓包脚本"></a>编写抓包脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> frida</div><div class="line"></div><div class="line">rdev = frida.get_usb_device()</div><div class="line"><span class="comment"># session = rdev.attach('com.taobao.etao')</span></div><div class="line">session = rdev.attach(<span class="string">'com.taobao.taobao'</span>)</div><div class="line"><span class="comment"># session = rdev.attach('com.tmall.wireless')</span></div><div class="line"></div><div class="line">scr = <span class="string">"""</span></div><div class="line">Java.perform(function () &#123;</div><div class="line">    var SwitchConfig = Java.use('mtopsdk.mtop.global.SwitchConfig');</div><div class="line">        SwitchConfig.isGlobalSpdySwitchOpen.overload().implementation = function()&#123;</div><div class="line">            var ret = this.isGlobalSpdySwitchOpen.apply(this, arguments);</div><div class="line">            console.log("isGlobalSpdySwitchOpenl "+ret)</div><div class="line">            </div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">"""</div><div class="line"></div><div class="line">script = session.create_script(scr)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></div><div class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</div><div class="line">        print(<span class="string">"[*] &#123;0&#125;"</span>.format(message[<span class="string">'payload'</span>]))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(message)</div><div class="line"></div><div class="line"></div><div class="line">script.on(<span class="string">"message"</span>, on_message)</div><div class="line">script.load()</div><div class="line">sys.stdin.read()</div></pre></td></tr></table></figure><p>运行该脚本，打开淘宝就可以抓包了。要注入的进程名已经写好了：</p><ol><li><code>com.taobao.etao</code> 是一淘</li><li><code>com.taobao.taobao</code>是淘宝</li><li><code>com.tmall.wireless</code> 是天猫</li></ol><p><img src="https://i.imgur.com/WIfQJiG.png" alt=""></p><p>想要抓淘宝App数据还有很多步要走，还有<code>x-sign</code>和<code>x-min-wua</code>等着你。(^o^)/~</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Frida抓包技巧&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://zhangslob.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode-581-最短无序连续子数组</title>
    <link href="https://zhangslob.github.io/2019/11/26/Leetcode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://zhangslob.github.io/2019/11/26/Leetcode-581-最短无序连续子数组/</id>
    <published>2019-11-26T02:41:36.925Z</published>
    <updated>2019-11-26T13:07:59.036Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零四篇原创文章</code></pre><p><img src="https://i.imgur.com/OEWbFEc.jpg" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目详述"><a href="#题目详述" class="headerlink" title="题目详述"></a>题目详述</h1><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: [2, 6, 4, 8, 10, 9, 15]</div><div class="line">输出: 5</div><div class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</div></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><h1 id="题目详解"><a href="#题目详解" class="headerlink" title="题目详解"></a>题目详解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>将原数组拷贝一份，然后对拷贝后的数组进行排序。</li><li>对比原数组和排序后的数组，除去前面一部分和后面一部分相同的元素，剩余区间的长度就是结果。</li><li>时间复杂度为 O(nlogn)。</li></ul><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, nums.length);</div><div class="line">        Arrays.sort(sortedNums);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> j = sortedNums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[i] == sortedNums[i]) &#123;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (i &lt;= j &amp;&amp; nums[j] == sortedNums[j]) &#123;</div><div class="line">            --j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">   <span class="string">"fmt"</span></div><div class="line">   <span class="string">"sort"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">   sortedNum := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</div><div class="line">   <span class="built_in">copy</span>(sortedNum, nums)</div><div class="line">   sort.Ints(sortedNum)</div><div class="line">   i, j := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[i] == sortedNum[i] &#123;</div><div class="line">      i++</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> i &lt;= j &amp;&amp; nums[j] == sortedNum[j] &#123;</div><div class="line">      j--</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> i &gt;= j &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">   nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">   n := findUnsortedSubarray(nums)</div><div class="line">   fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        sortedarray = sorted(nums)</div><div class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] == sortedarray[i]:</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == sortedarray[j]:</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">1</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol><li>遍历数组，同时进行从头到尾，从尾到头的遍历，分别找出无序连续子数组区间的右边和左边节点；</li><li>右边点，是从左到右不递增的点，</li><li>左边点，是从右到左不递减的点，</li><li>两点之间的距离就是所求值</li></ol><h3 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> min = nums[n - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt;= max) &#123;</div><div class="line">                max = nums[i];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                end = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (nums[n - i - <span class="number">1</span>] &lt;= min) &#123;</div><div class="line">                min = nums[n - i - <span class="number">1</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = n - i - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>&#125;;</div><div class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Solution().findUnsortedSubarray(nums);</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">n := <span class="built_in">len</span>(nums)</div><div class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line">start, end := n<span class="number">-1</span>, <span class="number">0</span></div><div class="line">max, min := nums[<span class="number">0</span>], nums[n<span class="number">-1</span>]</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</div><div class="line"><span class="keyword">if</span> nums[i] &gt;= max &#123;</div><div class="line">max = nums[i]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">end = i</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> nums[n-i<span class="number">-1</span>] &lt;= min &#123;</div><div class="line">min = nums[n-i<span class="number">-1</span>]</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = n - i - <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> start &gt;= end &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> end - start + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</div><div class="line">n := findUnsortedSubarray(nums)</div><div class="line">fmt.Println(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        start, end = <span class="number">0</span>, n - <span class="number">1</span></div><div class="line">        ma, mi = nums[start], nums[end]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> ma &lt;= nums[i]:</div><div class="line">                ma = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                start = i</div><div class="line">            <span class="keyword">if</span> mi &gt;= nums[n - i - <span class="number">1</span>]:</div><div class="line">                mi = nums[n - i - <span class="number">1</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                end = n - i - <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> start &lt;= end:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> start - end + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    s = Solution().findUnsortedSubarray([<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">15</span>])</div><div class="line">    print(s)</div></pre></td></tr></table></figure><p>等我提交之后，发现排在第一的解法比我快很多，我当时就呵呵呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></div><div class="line">        n = len(nums)</div><div class="line">        max_num = nums[<span class="number">0</span>]</div><div class="line">        right = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">            <span class="keyword">if</span> nums[i] &gt;= max_num:</div><div class="line">                max_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                right = i</div><div class="line">        left = n</div><div class="line">        min_num = nums[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[i] &lt;= min_num:</div><div class="line">                min_num = nums[i]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = i</div><div class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span> <span class="keyword">if</span> right - left &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零四篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OEWbFEc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink介绍</title>
    <link href="https://zhangslob.github.io/2019/11/24/Flink%E4%BB%8B%E7%BB%8D/"/>
    <id>https://zhangslob.github.io/2019/11/24/Flink介绍/</id>
    <published>2019-11-24T09:17:09.814Z</published>
    <updated>2019-11-24T09:43:27.250Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零三篇原创文章</code></pre><p><img src="https://flink.apache.org/img/flink-header-logo.svg" alt=""></p><p><code>Flink读书笔记（一）</code><br><a id="more"></a></p><p>最近在看一本书，《Flink原理、实战与性能优化》，记录下重点。</p><h1 id="Flink是什么"><a href="#Flink是什么" class="headerlink" title="Flink是什么"></a>Flink是什么</h1><p>Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</p><h1 id="Flink优势"><a href="#Flink优势" class="headerlink" title="Flink优势"></a>Flink优势</h1><ol><li>同时支持高吞吐、低延迟、高性能。Spark或Storm不能同时支持这三种。</li><li>支持事件事件（Event Time）概念。大多数框架仅支持系统时间（Process Time）。</li><li>支持有状态的计算。在流失计算中，将算子的中间计算结果保存在内存或磁盘中。</li><li>支持高度灵活的窗口（Window）操作。</li><li>基于轻量分布式快照（SnapShot）实现的容错。任务出现任务问题都可以从CheckPoints中自动恢复。</li><li>基于JVM实现独立的内存管理。Flink实现自身内存管理机制，通过序列化/反序列化将所有数据转化为二进制储存在内存中。</li><li>Save Points（保存点）。Flink将任务执行的快照保存在储存介质上。（和第5点类似）。</li></ol><h1 id="Flink应用场景"><a href="#Flink应用场景" class="headerlink" title="Flink应用场景"></a>Flink应用场景</h1><ol><li>实时智能推荐</li><li>复杂事件处理</li><li>实时欺诈检测</li><li>实时数仓与ETL</li><li>流数据处理</li><li>实时报表分析</li></ol><h1 id="Flink组件栈"><a href="#Flink组件栈" class="headerlink" title="Flink组件栈"></a>Flink组件栈</h1><p>Flink作为一个软件堆栈，是一个分层系统。堆栈的不同层相互叠加，并提高它们接受的程序表示的抽象级别:</p><ul><li>运行时层以JobGraph的形式接收程序。JobGraph是一个通用的并行数据流，其中包含使用和生成数据流的任意任务。</li><li>DataStream API和DataSet API都通过单独的编译过程生成JobGraphs。数据集API使用优化器来确定程序的最佳计划，而DataStream API使用流构建器。</li><li>JobGraph是根据Flink中可用的各种部署选项执行的(例如，本地、远程、Yarn等)</li><li>Connector层所能对接的技术更是丰富多样，将不同类型、不同来源的数据介入到Flink组件栈中。</li></ul><p><img src="https://raw.githubusercontent.com/Jonathan-Wei/Flink-Docs-CN/master/.gitbook/assets/4d9108a9-ab87-4380-be77-1ad455fa2d8f.png" alt=""></p><h1 id="Flink架构图"><a href="#Flink架构图" class="headerlink" title="Flink架构图"></a>Flink架构图</h1><p>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p><ul><li><strong>Client</strong> 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</li><li><strong>JobManager</strong> 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</li><li><strong>TaskManager</strong> 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</li></ul><p>可以看到 Flink 的任务调度是多线程模型，并且不同Job/Task混合在一个 TaskManager 进程中。虽然这种方式可以有效提高 CPU 利用率，但是个人不太喜欢这种设计，因为不仅缺乏资源隔离机制，同时也不方便调试。类似 Storm 的进程模型，一个JVM 中只跑该 Job 的 Tasks 实际应用中更为合理。</p><p><img src="https://i.imgur.com/sg6tXAa.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://flink.apache.org/img/flink-header-logo.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Flink读书笔记（一）&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Flink" scheme="https://zhangslob.github.io/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode 287. 寻找重复数</title>
    <link href="https://zhangslob.github.io/2019/11/21/Leetcode-287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
    <id>https://zhangslob.github.io/2019/11/21/Leetcode-287-寻找重复数/</id>
    <published>2019-11-21T05:53:36.612Z</published>
    <updated>2019-11-21T06:35:36.592Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第一百零二篇原创文章</code></pre><p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png" alt=""></p><p><code>努力、奋斗</code><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [1,3,4,2,2]</div><div class="line">输出: 2</div></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: [3,1,3,4,2]</div><div class="line">输出: 3</div></pre></td></tr></table></figure><p><strong>说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">不能更改原数组（假设数组是只读的）。</div><div class="line">只能使用额外的 O(1) 的空间。</div><div class="line">时间复杂度小于 O(n2) 。</div><div class="line">数组中只有一个重复的数字，但它可能不止重复出现一次。</div></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>思路是采用了二分法+抽屉原理。首先解释一下为什么用二分法，因为O(n2)时间复杂度不能A，所以往下应该是n*logn，很容易联想到二分法，因为其复杂度为logn。</p><p>抽屉原理是说假设你有11个苹果，要放进10个抽屉，那么至少有一个抽屉里是有两个苹果的。</p><p>对应到这题，1~n的n+1个数字，有1个数字会至少重复两次。</p><p>比如取数组为｛1，2，2，3，4，5｝，一共6个数，范围是1~5，其中位数应该是（5+1）/2 = 3，那么，如果小于等于3的数的个数如果超过了3，那么重复的数字一定出现在[1，3]之间，否则出现在[4，5]之间。以该数组为例，中位数为3，小于等于3的数一共有4个，大于3的数有两个，所以重复的数字在[1,3]之间。</p><h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</div><div class="line">            <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</div><div class="line">                <span class="keyword">if</span> (i &lt;= mid) &#123;</div><div class="line">                    count++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (count &gt; mid) &#123;</div><div class="line">                end = mid;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                start = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></div><div class="line">        left, right = <span class="number">1</span>, len(nums) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> left &lt; right:</div><div class="line">            mid = (left + right) // <span class="number">2</span></div><div class="line">            count = sum(i &lt;= mid <span class="keyword">for</span> i <span class="keyword">in</span> nums)</div><div class="line">            <span class="keyword">if</span> count &gt; mid:</div><div class="line">                right = mid</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                left = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> right</div></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">start, end := <span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></div><div class="line"><span class="keyword">for</span> start &lt; end &#123;</div><div class="line">mid := (start + end) / <span class="number">2</span></div><div class="line">count := <span class="number">0</span></div><div class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</div><div class="line"><span class="keyword">if</span> v &lt;= mid &#123;</div><div class="line">count++</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> count &gt; mid &#123;</div><div class="line">end = mid</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">start = mid + <span class="number">1</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> start</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>数组的索引与存储的数值之间形成了特殊<strong>链表</strong>。</p><p>如果存在重复的数，因为数组大小是 n+1，数字范围是1~n，所以该链表存在环。</p><p>环的入口即为结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// 快慢指针</span></div><div class="line">        <span class="keyword">int</span> fast = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> low = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">do</span>&#123;</div><div class="line">            low = nums[low];</div><div class="line">            fast = nums[nums[fast]];</div><div class="line">        &#125;<span class="keyword">while</span>(fast != low);</div><div class="line">        <span class="keyword">int</span> step = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// 寻找环链表的入口，即为结果</span></div><div class="line">        <span class="keyword">while</span>(step != low)&#123;</div><div class="line">            step = nums[step];</div><div class="line">            low = nums[low];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> low;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>现在还没看懂这种方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第一百零二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/6XJqh3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;努力、奋斗&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://zhangslob.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://zhangslob.github.io/2019/11/12/%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangslob.github.io/2019/11/12/算法/</id>
    <published>2019-11-12T13:47:02.238Z</published>
    <updated>2019-11-13T05:59:37.192Z</updated>
    
    <content type="html"><![CDATA[<p>java基础  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h2 id="算法-Algorithms"><a href="#算法-Algorithms" class="headerlink" title="算法 - Algorithms"></a><strong>算法 - Algorithms</strong></h2><ol><li>排序算法：快速排序、归并排序、计数排序</li><li>搜索算法：回溯、递归、剪枝技巧</li><li>图论：最短路、最小生成树、网络流建模</li><li>动态规划：背包问题、最长子序列、计数问题</li><li>基础技巧：分治、倍增、二分、贪心</li></ol><h2 id="数据结构-Data-Structures"><a href="#数据结构-Data-Structures" class="headerlink" title="数据结构 - Data Structures"></a><strong>数据结构 - Data Structures</strong></h2><ol><li>数组与链表：单 / 双向链表、跳舞链</li><li>栈与队列</li><li>树与图：最近公共祖先、并查集</li><li>哈希表</li><li>堆：大 / 小根堆、可并堆</li><li>字符串：字典树、后缀树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zhangslob.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合框架常见面试题</title>
    <link href="https://zhangslob.github.io/2019/11/11/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://zhangslob.github.io/2019/11/11/Java集合框架常见面试题/</id>
    <published>2019-11-11T08:21:46.065Z</published>
    <updated>2019-11-20T03:40:43.026Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百零一篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="说说List-Set-Map三者的区别"><a href="#说说List-Set-Map三者的区别" class="headerlink" title="说说List,Set,Map三者的区别"></a>说说List,Set,Map三者的区别</h1><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h1><ul><li><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong>Object 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong><ul><li>① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li>② <strong>LinkedList 采用链表存储，所以对于add(E e)方法的插入，删除元素时间复杂度不受元素位置的影响</strong>，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度应为o(n))因为需要新创立一个新的链表，复制前i-1个元素并在第i位加入新的元素，最后附上n-i个元素。</li></ul></li><li><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>5. 内存空间占用：</strong> ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h3 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a><strong>补充内容:RandomAccess接口</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（</code>）方法中，它要判断传入的list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch（）</code>方法，如果不是，那么调用<code>iteratorBinarySearch（）</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</div><div class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</li><li>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），大size的数据，千万不要使用普通for循环</li></ul><h1 id="双向链表和双向循环链表"><a href="#双向链表和双向循环链表" class="headerlink" title="双向链表和双向循环链表"></a>双向链表和双向循环链表</h1><p><strong>双向链表：</strong> 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。</p><p><a href="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/7d452b4b9f1402669f346c243b4777cb1b9e032c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67" alt="双向链表"></a></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。</p><p><a href="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/cbb13185522a7d66d9419fada0715051778e867c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67" alt="双向循环链表"></a></p><h1 id="ArrayList-与-Vector-区别"><a href="#ArrayList-与-Vector-区别" class="headerlink" title="ArrayList 与 Vector 区别"></a>ArrayList 与 Vector 区别</h1><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p><h1 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h1><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="external">通过源码一步一步分析ArrayList 扩容机制</a></p><p>#HashMap 和 Hashtable 的区别</p><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put（）</code>向map中添加元素</td><td>调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></div><div class="line">    <span class="comment">// ^ ：按位异或</span></div><div class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line"></div><div class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><a href="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/04f7d7f070f31c50f3d09da26f9459fdea2a7b4a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f6a646b312e382545342542392538422545352538392538442545372539412538342545352538362538352545392538332541382545372542422539332545362539452538342d486173684d61702e6a7067" alt="jdk1.8之前的内部结构-HashMap"></a></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><a href="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/d166a0184320055811ed72e61ece4491b6d80af1/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f4a444b312e38254534254239253842254535253930253845254537253941253834486173684d61702545352542412539352545352542312538322545362539352542302545362538442541452545372542422539332545362539452538342e6a7067" alt="jdk1.8之后的内部结构-HashMap"></a></p><blockquote><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong>推荐阅读：</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p><h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="external">https://coolshell.cn/articles/9606.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百零一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java疑难点</title>
    <link href="https://zhangslob.github.io/2019/11/11/Java%E7%96%91%E9%9A%BE%E7%82%B9/"/>
    <id>https://zhangslob.github.io/2019/11/11/Java疑难点/</id>
    <published>2019-11-11T05:57:44.804Z</published>
    <updated>2019-11-11T07:44:39.165Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第一百篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="正确使用-equals-方法"><a href="#正确使用-equals-方法" class="headerlink" title="正确使用 equals 方法"></a>正确使用 equals 方法</h1><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></div><div class="line">String str = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (str.equals(<span class="string">"SnailClimb"</span>)) &#123;</div><div class="line">  ...</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ..</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"SnailClimb"</span>.equals(str); <span class="comment">// false</span></div></pre></td></tr></table></figure><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Objects.equals(<span class="keyword">null</span>,<span class="string">"SnailClimb"</span>);<span class="comment">// false</span></div></pre></td></tr></table></figure><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</div><div class="line">        <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></div><div class="line">        <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894" target="_blank" rel="external">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h1 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h1><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer x = <span class="number">3</span>;</div><div class="line">Integer y = <span class="number">3</span>;</div><div class="line">System.out.println(x == y);<span class="comment">// true</span></div><div class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</div><div class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</div><div class="line">System.out.println(a == b);<span class="comment">//false</span></div><div class="line">System.out.println(a.equals(b));<span class="comment">//true</span></div></pre></td></tr></table></figure><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。</p><h1 id="BigDecimal-的用处"><a href="#BigDecimal-的用处" class="headerlink" title="BigDecimal 的用处"></a>BigDecimal 的用处</h1><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</div><div class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</div><div class="line">System.out.println(a);<span class="comment">// 0.100000024</span></div><div class="line">System.out.println(b);<span class="comment">// 0.099999964</span></div><div class="line">System.out.println(a == b);<span class="comment">// false</span></div></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</div><div class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</div><div class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</div><div class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></div><div class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></div><div class="line">System.out.println(x.equals(y));<span class="comment">// true</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-的大小比较"><a href="#BigDecimal-的大小比较" class="headerlink" title="BigDecimal 的大小比较"></a>BigDecimal 的大小比较</h1><p><code>a.compareTo(b)</code> : 返回 -1 表示小于，0 表示 等于， 1表示 大于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</div><div class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</div><div class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-保留几位小数"><a href="#BigDecimal-保留几位小数" class="headerlink" title="BigDecimal 保留几位小数"></a>BigDecimal 保留几位小数</h1><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">"1.255433"</span>);</div><div class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</div><div class="line">System.out.println(n);<span class="comment">// 1.255</span></div></pre></td></tr></table></figure><h1 id="BigDecimal-的使用注意事项"><a href="#BigDecimal-的使用注意事项" class="headerlink" title="BigDecimal 的使用注意事项"></a>BigDecimal 的使用注意事项</h1><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><a href="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/b1c115758fbdca06d975ccb2ea9d948184d8478f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f426967446563696d616c2e706e67" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h1 id="基本数据类型与包装数据类型的使用标准"><a href="#基本数据类型与包装数据类型的使用标准" class="headerlink" title="基本数据类型与包装数据类型的使用标准"></a>基本数据类型与包装数据类型的使用标准</h1><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="Arrays-asList-使用指南"><a href="#Arrays-asList-使用指南" class="headerlink" title="Arrays.asList()使用指南"></a>Arrays.asList()使用指南</h1><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="external">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String[] myArray = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span> &#125;； </div><div class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</div><div class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></div><div class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</div></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</div><div class="line"> */ </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="阿里巴巴Java-开发手册》对其的描述"><a href="#阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="阿里巴巴Java 开发手册》对其的描述"></a>阿里巴巴Java 开发手册》对其的描述</h2><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><a href="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/26b4048f6dd0109fcbb839ab6be16a088427a16d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382542462545392538372538432545352542372542342545352542372542344a6176612545352542432538302545352538462539312545362538392538422d4172726179732e61734c69737428292545362539362542392545362542332539352e706e67" alt="阿里巴巴Java开发手-Arrays.asList()方法"></a></p><h2 id="使用时的注意事项总结"><a href="#使用时的注意事项总结" class="headerlink" title="使用时的注意事项总结"></a>使用时的注意事项总结</h2><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.asList(myArray);</div><div class="line">System.out.println(myList.size());<span class="comment">//1</span></div><div class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></div><div class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></div><div class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</div><div class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></div></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div></pre></td></tr></table></figure><p><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></div><div class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></div><div class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></div></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></div></pre></td></tr></table></figure><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div><div class="line">  &#123;</div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">         ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="如何正确的将数组转换为ArrayList"><a href="#如何正确的将数组转换为ArrayList" class="headerlink" title="如何正确的将数组转换为ArrayList"></a>如何正确的将数组转换为ArrayList</h2><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW" target="_blank" rel="external">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JDK1.5+</span></div><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</div><div class="line">    l.add(s);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (l);</div><div class="line">&#125;</div><div class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></div></pre></td></tr></table></figure><p><strong>2. 最简便的方法(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</div></pre></td></tr></table></figure><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</div><div class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></div><div class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</div></pre></td></tr></table></figure><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="external"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="external"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="external"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">"string"</span>, <span class="string">"elements"</span>);  <span class="comment">// from varargs</span></div><div class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></div></pre></td></tr></table></figure><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="external"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="external"><code>newArrayList()</code></a>工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></div><div class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></div><div class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">"or"</span>, <span class="string">"string"</span>, <span class="string">"elements"</span>); <span class="comment">// from varargs</span></div></pre></td></tr></table></figure><p><strong>5. 使用 Apache Commons Collections</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">CollectionUtils.addAll(list, str);</div></pre></td></tr></table></figure><h1 id="Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="Collection.toArray()方法使用的坑&amp;如何反转数组"></a>Collection.toArray()方法使用的坑&amp;如何反转数组</h1><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String[] s = <span class="keyword">new</span> String[]&#123;</div><div class="line">    <span class="string">"dog"</span>, <span class="string">"lazy"</span>, <span class="string">"a"</span>, <span class="string">"over"</span>, <span class="string">"jumps"</span>, <span class="string">"fox"</span>, <span class="string">"brown"</span>, <span class="string">"quick"</span>, <span class="string">"A"</span></div><div class="line">&#125;;</div><div class="line">List&lt;String&gt; list = Arrays.asList(s);</div><div class="line">Collections.reverse(list);</div><div class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></div></pre></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="external">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h1 id="不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="不要在 foreach 循环里进行元素的 remove/add 操作"></a>不要在 foreach 循环里进行元素的 remove/add 操作</h1><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove</code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><a href="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/41587433a126cf0fb108c42d9c94df6bf40e07b3/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f666f72656163682d72656d6f76653a6164642e706e67" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第一百篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础知识</title>
    <link href="https://zhangslob.github.io/2019/11/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhangslob.github.io/2019/11/04/Java基础知识/</id>
    <published>2019-11-04T05:50:20.054Z</published>
    <updated>2019-11-07T09:11:38.694Z</updated>
    
    <content type="html"><![CDATA[<p>java基础知识  (๑• . •๑)</p><p><a href="http://vmpic.cn/image/7gdV" target="_blank" rel="external"><img src="https://u.vmpic.cn/2019/11/04/7gdV.jpg" alt="7gdV.jpg"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十九篇原创文章</div></pre></td></tr></table></figure><a id="more"></a><h1 id="面向对象-oop-与面向过程-opp-的区别"><a href="#面向对象-oop-与面向过程-opp-的区别" class="headerlink" title="面向对象(oop)与面向过程(opp)的区别"></a>面向对象(oop)与面向过程(opp)的区别</h1><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul><blockquote><p>Python也是一门面向对象的编程语言</p></blockquote><h1 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点"></a>Java 语言有哪些特点</h1><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h1 id="关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="关于 JVM JDK 和 JRE 最详细通俗的解答"></a>关于 JVM JDK 和 JRE 最详细通俗的解答</h1><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p><p><a href="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/8f6eceddf64b5948c69a398d1a0e777c9c7f8e5b/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67" alt="Java程序运行过程"></a></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><blockquote><p>HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h1 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别?"></a>Java和C++的区别?</h1><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><p>补充一下JAVA和Python的区别：</p><ul><li>python虚拟机没有java强，java虚拟机是java的核心，python的核心是可以很方便地使用c语言函数或c++库</li><li>Python是动态语言，JAVA是静态语言。JAVA在编写时可以检测变量类型</li><li>Python入门比JAVA简单</li><li>Python更多用来写一些简单脚本，JAVA用来做web、大数据方面很多</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><ul><li><strong>重载：</strong> 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</li><li><strong>重写：</strong> 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</li></ul><h1 id="Java-面向对象编程三大特性-封装-继承-多态"><a href="#Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="Java 面向对象编程三大特性: 封装 继承 多态"></a>Java 面向对象编程三大特性: 封装 继承 多态</h1><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><h1 id="String-StringBuffer-和-StringBuilder-的区别"><a href="#String-StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别"></a>String StringBuffer 和 StringBuilder 的区别</h1><p><strong>可变性</strong></p><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。</p><p>而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p><p>StringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(capacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AbstractStringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] value;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    AbstractStringBuilder() &#123;</div><div class="line">    &#125;</div><div class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</div><div class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p><p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><p>StringBuffer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</div><div class="line">    toStringCache = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">super</span>.insert(offset, str);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> </span>&#123;</div><div class="line">    toStringCache = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">super</span>.setLength(newLength);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>性能</strong></p><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ol><p>#自动装箱与拆箱</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的?"></a>在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h1 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h1><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。</p><p>因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 　</p><h1 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h1><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><p>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p><h1 id="成员变量与局部变量的区别有哪些？"><a href="#成员变量与局部变量的区别有哪些？" class="headerlink" title="成员变量与局部变量的区别有哪些？"></a>成员变量与局部变量的区别有哪些？</h1><ol><li>从语法形式上看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h1 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h1><ol><li>名字与类名相同。</li><li>没有返回值，但不能用void声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h1 id="静态方法和实例方法有何不同"><a href="#静态方法和实例方法有何不同" class="headerlink" title="静态方法和实例方法有何不同"></a>静态方法和实例方法有何不同</h1><ol><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li></ol><h1 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h1><p><strong>==</strong> : 它的作用是判断两个对象的<strong>地址</strong>是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。基本数据类型：byte、short、int、long、float、double、char、boolean<br>引用类型：类(class)、接口(interface)、数组(array)</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></div><div class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></div><div class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></div><div class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></div><div class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"aa==bb"</span>);</div><div class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></div><div class="line">            System.out.println(<span class="string">"a==b"</span>);</div><div class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"aEQb"</span>);</div><div class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></div><div class="line">            System.out.println(<span class="string">"true"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><blockquote><p>一般情况下都用equals，肯定不会错</p></blockquote><h1 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h1><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><blockquote><p>hashCode可能会返回负数</p></blockquote><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals（）</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个int整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h3 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h3><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="external">Java hashCode() 和 equals()的若干问题解答</a></p><h1 id="为什么Java中只有值传递"><a href="#为什么Java中只有值传递" class="headerlink" title="为什么Java中只有值传递"></a>为什么Java中只有值传递</h1><p>有时间好好看看这个：<a href="https://juejin.im/post/5bce68226fb9a05ce46a0476" target="_blank" rel="external">这一次，彻底解决Java的值传递和引用传递</a></p><h1 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h1><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h1 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态"></a>线程有哪些基本状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4节）。</p><p><a href="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/bd21f0c6bf04fe410fa5397897cc47b9278ae5cb/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612545372542412542462545372541382538422545372539412538342545372538412542362545362538302538312e706e67" alt="Java线程的状态"></a></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4节）：</p><p><a href="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67" alt="Java线程状态变迁"></a></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="external">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="external">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><a href="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67" alt="RUNNABLE-VS-RUNNING"></a></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h1 id="关于-final-关键字的一些总结"><a href="#关于-final-关键字的一些总结" class="headerlink" title="关于 final 关键字的一些总结"></a>关于 final 关键字的一些总结</h1><p>final关键字主要用在三个地方：变量、方法、类。</p><ol><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。</li><li>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</li></ol><h1 id="Java-中的异常处理"><a href="#Java-中的异常处理" class="headerlink" title="Java 中的异常处理"></a>Java 中的异常处理</h1><h3 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h3><p><a href="https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/27aa104d93ba0738be0f3d2e7d5b096c1619d12d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d322f457863657074696f6e2e706e67" alt="Java异常类层次结构图"></a></p><p>在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 <strong>Throwable类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由Java虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以0时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p><p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p><h3 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h3><ul><li><strong>public string getMessage()</strong>:返回异常发生时的简要描述</li><li><strong>public string toString()</strong>:返回异常发生时的详细信息</li><li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li><li><strong>public void printStackTrace()</strong>:在控制台上打印Throwable对象封装的异常信息</li></ul><h3 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h3><ul><li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li><li><strong>catch 块：</strong> 用于处理try捕获到的异常。</li><li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。</li></ul><p><strong>在以下4种特殊情况下，finally块不会被执行：</strong></p><ol><li>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</li><li>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ol><p>下面这部分内容来自issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190。" target="_blank" rel="external">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p><p><strong>注意：</strong> 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> value * value;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。</p><h1 id="Java序列化中如果有些字段不想进行序列化，怎么办"><a href="#Java序列化中如果有些字段不想进行序列化，怎么办" class="headerlink" title="Java序列化中如果有些字段不想进行序列化，怎么办"></a>Java序列化中如果有些字段不想进行序列化，怎么办</h1><p>对于不想进行序列化的变量，使用transient关键字修饰。</p><p>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p><h1 id="Java-中-IO-流"><a href="#Java-中-IO-流" class="headerlink" title="Java 中 IO 流"></a>Java 中 IO 流</h1><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><a href="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/639ec442b39898de071c3e4fd098215fb48f11e9/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545362539362542392545352542432538462545352538382538362545372542312542422e706e67" alt="IO-操作方式分类"></a></p><p>按操作对象分类结构图：</p><p><a href="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4a44e49ab13eacac26cbb0e481db73d6d11181b7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f494f2d2545362539332538442545342542442539432545352541462542392545382542312541312545352538382538362545372542312542422e706e67" alt="IO-操作对象分类"></a></p><h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h1 id="常见关键字总结-static-final-this-super"><a href="#常见关键字总结-static-final-this-super" class="headerlink" title="常见关键字总结:static,final,this,super"></a>常见关键字总结:static,final,this,super</h1><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/final、static、this、super.md" target="_blank" rel="external"> final,static,this,super 关键字总结</a></p><h1 id="Collections-工具类和-Arrays-工具类常见方法总结"><a href="#Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法总结"></a>Collections 工具类和 Arrays 工具类常见方法总结</h1><p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Basis/Arrays,CollectionsCommonMethods.md" target="_blank" rel="external"> Collections 工具类和 Arrays 工具类常见方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java基础知识  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vmpic.cn/image/7gdV&quot;&gt;&lt;img src=&quot;https://u.vmpic.cn/2019/11/04/7gdV.jpg&quot; alt=&quot;7gdV.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十九篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangslob.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端真机调试指南</title>
    <link href="https://zhangslob.github.io/2019/10/29/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>https://zhangslob.github.io/2019/10/29/移动端真机调试指南/</id>
    <published>2019-10-29T02:06:21.667Z</published>
    <updated>2019-10-29T02:17:04.154Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/MobileDebug_900x500.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十八篇原创文章</div></pre></td></tr></table></figure><p>各种抓包方法  (๑• . •๑)</p><a id="more"></a><h1 id="系统自带调试功能"><a href="#系统自带调试功能" class="headerlink" title="系统自带调试功能"></a>系统自带调试功能</h1><h3 id="iOS-系统"><a href="#iOS-系统" class="headerlink" title="iOS 系统"></a>iOS 系统</h3><p><strong>运行环境要求</strong></p><ul><li>Mac + Safari 浏览器</li><li>iPhone（iOS 6 +） + Safari 浏览器</li></ul><p><strong>调试步骤</strong></p><p>1、使用 Lightning 数据线将 iPhone 与 Mac 相连</p><p>2、iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; 开启 Web 检查器）</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_WebInspector.jpg" alt=""></p><p>3、iPhone 使用 Safari 浏览器打开要调试的页面</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/iPhone_Safari.jpg" alt=""></p><p>4、Mac 打开 Safari 浏览器调试（菜单栏 —&gt; 开发 -&gt; iPhone 设备名 -&gt; 选择调试页面）</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_Page.jpg" alt=""></p><p>如果你的菜单栏没有“开发”选项，可以到左上角 <code>Safari</code> -&gt; <code>偏好设置</code> -&gt; <code>高级</code> -&gt; <code>在菜单栏中显示“开发”菜单</code>。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Open_SafariDevTools.jpg" alt=""></p><p>5、在弹出的 Safari Developer Tools 中调试</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Safari_DevTools.jpg" alt=""></p><p>经过如上步骤就可在 Mac 端调试 iPhone 上 Safari 运行的页面了，但对于 WebView 页面就不适用了，另外 Windows 系统不适用此方案。</p><p><strong>当前测试环境：</strong></p><ul><li>Safari 版本 10.0.2</li><li>iPhone 7（iOS 10.1.1）</li></ul><p>没有 iPhone 设备可以在 App Store 安装 Xcode 使用其内置的 iOS 模拟器，安装完成后通过以下两种方式开启：</p><ul><li>右键 <code>Xcode 图标</code> -&gt; <code>Open Developer Tool</code> -&gt; <code>Simulator</code></li><li>右键 <code>Finder 图标</code> -&gt; <code>前往文件夹</code> -&gt; <code>/应用程序/Xcode.app/Contents/Developer/Applications/</code> -&gt; 运行 <code>Simulator.app</code></li></ul><p>运行 iOS 模拟器后，在模拟器中打开调试页面，再通过 Mac Safari 开发功能就可以调试到。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Xcode_Simulator.jpg" alt="Simulator"></p><p>如果我需要调试更低版本的 iOS 怎么办？实际使用的 iPhone 不可能去降版本，不必担心，Simulator 有。</p><p>点击左上角 <code>Xcode</code> -&gt; <code>Preferences</code> -&gt; <code>Downloads</code> 就可以看到提供了如下版本：</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Xcode_Simulator_Version.jpg" alt="iOS 版本下载"></p><h1 id="Android-系统"><a href="#Android-系统" class="headerlink" title="Android 系统"></a>Android 系统</h1><h3 id="运行环境要求"><a href="#运行环境要求" class="headerlink" title="运行环境要求"></a>运行环境要求</h3><ul><li>Chrome 版本 &gt;= 32</li><li>Android 版本 4.0 +</li></ul><h3 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li><p>使用 USB 数据线将手机与电脑相连</p></li><li><p>手机进入开发者模式，勾选 USB 调试，并允许调试</p></li></ol><h3 id="如何开启-USB-调试："><a href="#如何开启-USB-调试：" class="headerlink" title="如何开启 USB 调试："></a>如何开启 USB 调试：</h3><p><strong>索尼 Z5：</strong><code>设置</code> -&gt; <code>关于关机</code> -&gt; <code>多次点击软件版本开启</code> -&gt; <code>返回上一级</code> -&gt; <code>开发者选项</code> -&gt; <code>USB 调试</code></p><p><strong>魅蓝 Note：</strong><code>设置</code> -&gt; <code>辅助功能</code> -&gt; <code>开发者选项</code> -&gt; <code>USB 调试</code></p><p>不同 Android 设备进入开发者模式的方式有稍稍不同，瞎捣鼓一下即可开启。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_USB_Debug.jpg" alt="开启 Android 调试"></p><ol><li>电脑打开 Chrome 浏览器，在地址栏输入：chrome://inspect/#devices 并勾选 Discover USB devices 选项</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Discover_USB_devices.jpg" alt="开启 Discover USB devices"></p><ol><li>手机允许远程调试，并访问调试页面</li></ol><p>官方的教程是想让你使用手机 Chrome 开启调试页面的，但实际需求更多的是调试一些 WebView 页面，在官方的 <a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews" target="_blank" rel="external">Remote Debugging WebViews</a> 有说明是可以调试 WebView 页面的，Android 版本需要在 4.4 以上，并且 APP 需要有配置相应的启动调试代码。</p><blockquote><p>WebView debugging must be enabled from within your application. To enable WebView debugging, call the static method setWebContentsDebuggingEnabled on the WebView class.</p><p>必须在 APP 内启动 WebView 调试。要启动 WebView 调试，需要调用 WebView 类上的静态方法 setWebContentsDebuggingEnabled。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">    WebView.setWebContentsDebuggingEnabled(<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>This setting applies to all of the application’s WebViews.</p><p>此设置适用于所有 APP 的 WebView。</p><p>Tip: WebView debugging is not affected by the state of the debuggable flag in the application’s manifest. If you want to enable WebView debugging only when debuggable is true, test the flag at runtime.</p><p>提示：WebView 是否可调试状态不受 mainfest 标志变量 debuggable 的影响，如果你想在 debuggable 为 true 的时候启动 WebView 调试，请使用以下代码：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> != (getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)) &#123; </div><div class="line">    WebView.setWebContentsDebuggingEnabled(<span class="literal">true</span>); </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_Page.jpg" alt="Android 打开调试页面"></p><ol><li>电脑点击 inspect 按钮</li></ol><p>如果你出现无法识别到设备的情况，建议尝试以下几种方法：</p><ul><li>使用原装数据线，不要使用山寨数据线或一线多头的数据线</li><li>重新插拔 USB 数据线，让手机处于充电状态</li><li>关闭电脑相关的应用助手</li><li>重启手机</li><li>Windows 系统下自动安装驱动失败，到 <a href="https://developer.android.com/studio/run/oem-usb.html#Drivers" target="_blank" rel="external">Android Studio</a> 手动下载</li></ul><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Click_Inspect.jpg" alt="点击 inspect 按钮"></p><p>注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 <a href="https://chrome-devtools-frontend.appspot.com/" target="_blank" rel="external">https://chrome-devtools-frontend.appspot.com</a> 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。</p><ol><li>进入调试界面</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Chrome_DevTools.jpg" alt="Chrome DevTools"></p><p><strong>当前测试环境：</strong></p><ul><li>Chrome 版本 55.0.2883.95</li><li>索尼 Z5（Android 5.1.1）</li><li>魅蓝 Note（Android 5.1）</li><li>三星 Galaxy S7（Android 6.0.1）</li></ul><p>这里顺带提一下 <a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">TBS Studio</a> 调试工具，它在 Chrome DevTools 调试功能的基础上进行了一些功能扩展，特性如下：</p><p>1.3 TBS Studio 功能特性</p><ol><li>自动检测手机与 PC 的连接；</li><li>自动检测网页是否可进行 Inspect 调试；</li><li>自动引导开发者打开 Inspector 调试开关；</li><li>一键开启 Inspector 调试，无需打开浏览器输入 URL，方便快捷；</li><li>扩展 X5 内核独有 Inspect 选项，方便页面分析和优化；</li><li>真机远程 Inspector 调试。</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/TBS_Studio.jpg" alt="TBS Studio"></p><p>详细介绍和使用步骤可到<a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">开发者论坛</a>查看，部分 Android 机型通过 USB 可能依旧无法识别到设备，可使用后面会讲到的其他方案。</p><p>关于 Android 虚拟机也是有的，这里推荐使用 <a href="https://www.genymotion.com/" target="_blank" rel="external">Genymotion</a> 软件，使用 Genymotion 前需要安装 <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external">VirtuaBox</a>，并且注册登陆后才能显示所有的虚拟设备。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Virtua_Android.jpg" alt="Genymotion"></p><h1 id="使用代理工具调试开发环境页面"><a href="#使用代理工具调试开发环境页面" class="headerlink" title="使用代理工具调试开发环境页面"></a>使用代理工具调试开发环境页面</h1><p>对于需要配 Hosts 才能访问的开发环境页面，手机在默认情况下是没有权限修改 Hosts 文件的，除非是 iOS 设备越狱后和 Android 设备 root 后，所以一般情况下手机是无法访问开发环境页面，这时需要使用到 Mac 系统的 <a href="https://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> 代理工具，Windows 系统可使用 <a href="http://www.telerik.com/fiddler" target="_blank" rel="external">Fiddler</a> 代理工具。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>Mac 作为代理服务器</li><li>手机通过 HTTP 代理连接到 Mac 电脑</li><li>手机上的请求都经过代理服务器</li><li>通过给 Mac 配 Hosts 实现目的</li></ul><h3 id="调试步骤-1"><a href="#调试步骤-1" class="headerlink" title="调试步骤"></a>调试步骤</h3><ol><li>查看电脑 IP（<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>Local IP Addresses</code>）</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Local_IP.jpg" alt="本地 IP"></p><ol><li>查看端口（<code>菜单</code> -&gt; <code>Settings</code> -&gt; <code>Proxy Settings</code> -&gt; <code>Proxies</code>）</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Proxy_Port.jpg" alt="代理端口"></p><p>默认端口为：8888，勾选 <code>Enable transparent HTTP proxying</code></p><ol><li>将 IP、端口号填入手机 HTTP 代理</li></ol><p>iOS 系统：<code>设置</code> -&gt; <code>无线局域网</code> -&gt; <code>点击叹号</code> -&gt; <code>HTTP 代理</code> -&gt; <code>手动</code></p><p>Android 系统：<code>设置</code> -&gt; <code>长按当前网络</code> -&gt; <code>修改网络</code> -&gt; <code>高级选项</code> -&gt; <code>手动</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Set_HTTP_Proxy.jpg" alt="手机设置代理"></p><ol><li>Charles 允许授权</li></ol><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Allow_all_IP.jpg" alt="允许授权"></p><p>每次有新设备首次连接都会提示是否授权，可以通过 <code>Proxy</code> -&gt; <code>Access Control Settings</code> 配置以下参数 <code>0.0.0.0/0</code> 来关闭。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/All_IP.jpg" alt="所有 IP 通过"></p><ol><li><p>使用 SwitchHosts! 软件给 Mac 电脑配 Hosts</p></li><li><p>手机访问开发环境页面</p></li></ol><p>到这一步手机就可以访问到开发环境下的页面了，再结合前面所讲的方案来调试页面。</p><ol><li>Charles 的调试功能</li></ol><ul><li><strong>7.1 网络映射修改文件</strong></li></ul><p>除了结合前面的方案调试，可以使用 Map Local 网络映射功能来实现对文件的修改，在<code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>Start Recording</code> 开启抓包后访问页面，找到抓取到的样式文件，点击右键 <code>Map Local</code>，在 <code>Local path</code> 中设置本地映射文件的路径，修改后刷新页面可以看到效果。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Map_Local.jpg" alt="Map Local"></p><ul><li><strong>7.2 模拟网络速度</strong></li></ul><p><code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>Throttle Settings</code> -&gt; 勾选 <code>Enable Throttling</code>，在 <code>Throttling preset</code> 中可以选择需要模拟的网络速度。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Throttling.jpg" alt="模拟网络速度"></p><ul><li><strong>7.3 抓取 HTTPS 请求</strong></li></ul><p>默认情况下，Charles 无法抓取到 HTTPS 的请求，解决步骤如下：</p><p>Mac 端安装证书：<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>SSL Proxying</code> -&gt; <code>Install Charles Root Certificate</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Install_SSL.jpg" alt="Mac 安装 SSL"></p><p>然后导出 Charles SSL 证书安装到手机，<code>菜单</code> -&gt; <code>Help</code> -&gt; <code>SSL Proxying</code> -&gt; <code>Save Charles Root Certificate</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Save_SSL.jpg" alt="导出 SSL"></p><p>Android 设备导出的 Charles SSL 证书存储到手机中并安装。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Android_Setup_SSL.jpg" alt="Android 安装 SSL"></p><p>iOS 设备用 Safari 打开 <a href="http://www.charlesproxy.com/getssl/" target="_blank" rel="external">http://www.charlesproxy.com/getssl/</a> 页面，下载 Charles SSL 证书并安装。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/iOS_Setup_SSL.jpg" alt="iOS 安装 SSL"></p><p>证书安装完成后，还需要给 Charles SSL 代理配置域名和端口号，<code>菜单</code> -&gt; <code>Proxy</code> -&gt; <code>SSL Proxying Settings</code> 勾选 <code>Enable SSL Proxying</code> 点击 <code>Add</code> 填入域名和端口号，经过以上步骤就可以抓取到 HTTPS 的请求了。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/SSL_Proxying_Settings.jpg" alt="设置 SSL 端口"></p><ul><li><strong>7.4 断点调试请求和响应内容</strong></li></ul><p>开启 Charles 断点 <code>Proxy</code> -&gt; <code>Breakpoints Settings</code> -&gt; <code>Enable Breakpoints</code>点击 <code>Add</code> 可设置断点条件或者单独对需要的文件右键 <code>Breakpoints</code> 设置断点。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Breakpoints.jpg" alt="开启断点"></p><p>访问页面后，即可编辑请求和响应的内容，点击 <code>Execute</code> 按钮完成。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Edit_Content.jpg" alt="编辑抓包内容"></p><h1 id="Weinre-调试工具"><a href="#Weinre-调试工具" class="headerlink" title="Weinre 调试工具"></a>Weinre 调试工具</h1><p>Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。</p><p><strong>调试步骤：</strong></p><p><strong>1、安装 Weinre</strong></p><p>使用 NPM 全局安装 Weinre</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo npm -g install weinre</div></pre></td></tr></table></figure><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Install_Weinre.jpg" alt="安装 Weinre"></p><p><strong>2、启动 Weinre 监听服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ipconfig getifaddr en0 // 查看本机 IP</div><div class="line">$ weinre --boundHost 10.14.217.14 --httpPort 8090</div></pre></td></tr></table></figure><p><code>--boundHost</code> 后填入你本机 IP 地址，<code>--httpPort</code> 后填入端口号，默认为 8080</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/run_weinre.jpg" alt="启动监听"></p><p><strong>3、进入 Weinre 管理页面</strong></p><p>使用 Chrome 浏览器访问 <a href="http://10.14.217.14:8090/" target="_blank" rel="external">http://10.14.217.14:8090</a>，在管理页面你可以看到使用相关的说明，有进入客户端调试界面的地址、使用的文档、DEMO 页面等等，说明中要求将一段 JS 脚本 <code>&lt;script src=&quot;http://10.14.217.14:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;</code> 插入到需要调试的页面中，插入代码后手机访问调试页面。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Target_Script.jpg" alt="需要插入的脚本"></p><p><strong>4、进入客户端调试界面</strong></p><p>点击 debug client user interface：<a href="http://10.14.217.14:8090/client/#anonymous" target="_blank" rel="external">http://10.14.217.14:8090/client/#anonymous</a> 的链接。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Weinre_Remote.jpg" alt="Weinre Remote"></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Weinre_Element.jpg" alt="Weinre Element"></p><p><strong>5、JS 脚本注入</strong></p><p>手动加入 JS 脚本不优雅，这里可以结合我们前面提到的 Charles 代理工具实现动态 HTTP Script 注入。</p><p>打开<code>菜单</code> -&gt; <code>Rewrite</code> -&gt; 勾选 <code>Enable Rewrite</code></p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Rewrite.jpg" alt="Charles Rewrite"></p><p>输入 Rewrite 的名字并且在 Rules 一项添加匹配的规则，Location 一项是用于指定的域名和端口添加规则用的，这里我们不填默认匹配所有请求。</p><p>Type 允许对需要匹配的请求进行 Rewrite，一共提供了 11 种：</p><ul><li><code>Add Header</code></li><li><code>Modify Header</code></li><li><code>Remove Header</code></li><li><code>Host</code></li><li><code>Path</code></li><li><code>URL</code></li><li><code>Add Query Param</code></li><li><code>Modify Query Param</code></li><li><code>Remove Query Param</code></li><li><code>Response Status</code></li><li><code>Body</code></li></ul><p>这里我们需要使用到的是 <code>Body</code>，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 <code>&lt;/body&gt;</code> 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。</p><p><img src="https://misc.aotu.io/ONE-SUNDAY/MobileDebug/Charles_Rewrite_Rule.jpg" alt="Rewrite Rule"></p><p>另外，也有基于 Weinre 进行功能扩展的工具，比如早期版本的 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信 Web 开发者工具 v0.7.0</a> 和 <a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">spy-debugger</a>，都在 Weinre 的基础上简化了要给每个调试页面添加 JS 脚本的步骤，spy-debugger 还增加了对 HTTPS 的支持。</p><hr><p>感谢你的阅读，如果你还有其他更为实用的调试方案，欢迎下方留言交流。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html" target="_blank" rel="external">Safari Web Inspector Guide</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/" target="_blank" rel="external">Get Started with Remote Debugging Android Devices</a></li><li><a href="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/webviews" target="_blank" rel="external">Remote Debugging WebViews</a></li><li><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Running.html" target="_blank" rel="external">weinre - Running</a></li><li><a href="https://www.charlesproxy.com/documentation/welcome/" target="_blank" rel="external">Charles Web Debugging Proxy</a></li><li><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="external">wuchangming/spy-debugger</a></li><li><a href="http://bbs.mb.qq.com/thread-1416936-1-1.html" target="_blank" rel="external">TBS 开发调试利器 —— TBS Studio - QQ 浏览器移动产品论坛</a></li><li><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1455784140&amp;token=&amp;lang=zh_CN" target="_blank" rel="external">微信 web 开发者工具</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://misc.aotu.io/ONE-SUNDAY/MobileDebug/MobileDebug_900x500.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十八篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;各种抓包方法  (๑• . •๑)&lt;/p&gt;
    
    </summary>
    
    
      <category term="抓包" scheme="https://zhangslob.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis SCAN的使用</title>
    <link href="https://zhangslob.github.io/2019/09/25/Redis-SCAN%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://zhangslob.github.io/2019/09/25/Redis-SCAN的使用/</id>
    <published>2019-09-25T02:09:09.679Z</published>
    <updated>2019-09-25T02:18:29.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/carbon.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十八篇原创文章</div></pre></td></tr></table></figure><p>了解下redis的更多用法</p><a id="more"></a><h1 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h1><p>有时候需要从 Redis 实例成千上万的 key 中找出特定前缀的 key 列表来手动处理数据，可能是修改它的值，也可能是删除 key。这里就有一个问题，如何从海量的 key 中找出满足特定前缀的 key 列表来？</p><p>Redis 提供了一个简单暴力的指令 keys 用来列出所有满足特定正则字符串规则的 key。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli keys key67*</div><div class="line">  1) <span class="string">"key6764"</span></div><div class="line">  2) <span class="string">"key6738"</span></div><div class="line">  3) <span class="string">"key6774"</span></div><div class="line">  4) <span class="string">"key673"</span></div><div class="line">  5) <span class="string">"key6710"</span></div><div class="line">  6) <span class="string">"key6759"</span></div><div class="line">  7) <span class="string">"key6715"</span></div><div class="line">  8) <span class="string">"key6746"</span></div><div class="line">  9) <span class="string">"key6796"</span></div></pre></td></tr></table></figure><p>这个指令使用非常简单，提供一个简单的正则字符串即可，但是有很明显的两个缺点。</p><ul><li><p>没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，</p><p>当你看到满屏的字符串刷的没有尽头时，你就知道难受了。</p></li><li><p>keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，</p><p>所有读写 Redis 的其它的指令都会被延后甚至会超时报错，</p><p>因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</p></li><li><p>建议生产环境屏蔽keys命令</p></li></ul><p>Redis 为了解决这个问题，它在 2.8 版本中加入了指令——scan。</p><p>scan 相比 keys 具备有以下特点:</p><ul><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li><li>提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要客户端去重复，这点非常重要;</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li></ul><h1 id="scan-基础使用"><a href="#scan-基础使用" class="headerlink" title="scan 基础使用"></a>scan 基础使用</h1><p><strong>SCAN cursor [MATCH pattern] [COUNT count]</strong></p><p>初始执行scan命令例如scan 0。SCAN命令是一个基于游标的迭代器。</p><p>这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。</p><p>当SCAN命令的游标参数被设置为0时，服务器将开始一次新的迭代，而当redis服务器向用户返回值为0的游标时，</p><p>表示迭代已结束，这是唯一迭代结束的判定方式，而不能通过返回结果集是否为空判断迭代结束。</p><blockquote><p>scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。</p><p>第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。</p><p>一直遍历到返回的 cursor 值为 0 时结束。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli scan 0 match key99* count 1000</div><div class="line">1) <span class="string">"13912"</span></div><div class="line">2)  1) <span class="string">"key997"</span></div><div class="line">    2) <span class="string">"key9906"</span></div><div class="line">    3) <span class="string">"key9957"</span></div><div class="line">    4) <span class="string">"key9902"</span></div><div class="line">    5) <span class="string">"key9971"</span></div><div class="line">    6) <span class="string">"key9935"</span></div><div class="line">    7) <span class="string">"key9958"</span></div><div class="line">    8) <span class="string">"key9928"</span></div><div class="line">    9) <span class="string">"key9931"</span></div><div class="line">   10) <span class="string">"key9961"</span></div><div class="line">   11) <span class="string">"key9948"</span></div><div class="line">   12) <span class="string">"key9965"</span></div><div class="line">   13) <span class="string">"key9937"</span></div><div class="line">   </div><div class="line"><span class="variable">$redis</span>-cli scan 13912 match key99* count 1000</div><div class="line">1) <span class="string">"5292"</span></div><div class="line">2)  1) <span class="string">"key996"</span></div><div class="line">    2) <span class="string">"key9960"</span></div><div class="line">    3) <span class="string">"key9973"</span></div><div class="line">    4) <span class="string">"key9978"</span></div><div class="line">    5) <span class="string">"key9927"</span></div><div class="line">    6) <span class="string">"key995"</span></div><div class="line">    7) <span class="string">"key9992"</span></div><div class="line">    8) <span class="string">"key9993"</span></div><div class="line">    9) <span class="string">"key9964"</span></div><div class="line">   10) <span class="string">"key9934"</span></div></pre></td></tr></table></figure><blockquote><p>返回结果分为两个部分：第一部分即 1) 就是下一次迭代游标，第二部分即 2) 就是本次迭代结果集。</p></blockquote><p>从上面的过程可以看到虽然提供的 limit 是 1000，但是返回的结果只有 10 个左右。</p><p>因为这个 limit 不是限定返回结果的数量，而是限定服务器单次遍历的字典槽位数量(约等于)。</p><p>如果将 limit 设置为 10，你会发现返回结果是空的，但是游标值不为零，意味着遍历还没结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli scan 0 match key99* count 10</div><div class="line">1) <span class="string">"15360"</span></div><div class="line">2) (empty list or <span class="built_in">set</span>)</div><div class="line"></div><div class="line"><span class="variable">$redis</span>-cli scan 15360 match key99* count 10</div><div class="line">1) <span class="string">"2304"</span></div><div class="line">2) (empty list or <span class="built_in">set</span>)</div></pre></td></tr></table></figure><h1 id="更多的-scan-指令"><a href="#更多的-scan-指令" class="headerlink" title="更多的 scan 指令"></a>更多的 scan 指令</h1><p>scan 指令是一系列指令，除了可以遍历所有的 key 之外，还可以对指定的容器集合进行遍历。</p><p>zscan 遍历 zset 集合元素，</p><p>hscan 遍历 hash 字典的元素、</p><p>sscan 遍历 set 集合的元素。</p><p><strong>注意点：</strong></p><p>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</p><p>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</p><h1 id="大-key-扫描"><a href="#大-key-扫描" class="headerlink" title="大 key 扫描"></a>大 key 扫描</h1><p>有时候会因为业务人员使用不当，在 Redis 实例中会形成很大的对象，比如一个很大的 hash，一个很大的 zset 这都是经常出现的。</p><p>这样的对象对 Redis 的集群数据迁移带来了很大的问题，因为在集群环境下，如果某个 key 太大，会让数据导致迁移卡顿。</p><p>另外在内存分配上，如果一个 key 太大，那么当它需要扩容时，会一次性申请更大的一块内存，这也会导致卡顿。</p><p>如果这个大 key 被删除，内存会一次性回收，卡顿现象会再一次产生。</p><p><strong>在平时的业务开发中，要尽量避免大 key 的产生。</strong></p><p>如果你观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的，这时候你就需要定位出具体是那个 key，</p><p>进一步定位出具体的业务来源，然后再改进相关业务代码设计。</p><p><strong>那如何定位大 key 呢？</strong></p><p>为了避免对线上 Redis 带来卡顿，这就要用到 scan 指令，对于扫描出来的每一个 key，使用 type 指令获得 key 的类型，</p><p>然后使用相应数据结构的 size 或者 len 方法来得到它的大小，对于每一种类型，保留大小的前 N 名作为扫描结果展示出来。</p><p>上面这样的过程需要编写脚本，比较繁琐，不过 Redis 官方已经在 redis-cli 指令中提供了这样的扫描功能，我们可以直接拿来即用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli  --bigkeys</div><div class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></div><div class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></div><div class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></div><div class="line"></div><div class="line">[00.00%] Biggest string found so far <span class="string">'key316'</span> with 3 bytes</div><div class="line">[00.00%] Biggest string found so far <span class="string">'key7806'</span> with 4 bytes</div><div class="line">[12.79%] Biggest zset   found so far <span class="string">'salary'</span> with 1 members</div><div class="line">[13.19%] Biggest string found so far <span class="string">'counter:__rand_int__'</span> with 6 bytes</div><div class="line">[13.50%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'websit'</span> with 2 fields</div><div class="line">[14.37%] Biggest <span class="built_in">set</span>    found so far <span class="string">'bbs'</span> with 3 members</div><div class="line">[14.67%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'website'</span> with 3 fields</div><div class="line">[30.41%] Biggest list   found so far <span class="string">'mylist'</span> with 100000 items</div><div class="line">[95.53%] Biggest zset   found so far <span class="string">'page_rank'</span> with 3 members</div><div class="line"></div><div class="line">-------- summary -------</div><div class="line"></div><div class="line">Sampled 10019 keys <span class="keyword">in</span> the keyspace!</div><div class="line">Total key length <span class="keyword">in</span> bytes is 68990 (avg len 6.89)</div><div class="line"></div><div class="line">Biggest string found <span class="string">'counter:__rand_int__'</span> has 6 bytes</div><div class="line">Biggest   list found <span class="string">'mylist'</span> has 100000 items</div><div class="line">Biggest    <span class="built_in">set</span> found <span class="string">'bbs'</span> has 3 members</div><div class="line">Biggest   <span class="built_in">hash</span> found <span class="string">'website'</span> has 3 fields</div><div class="line">Biggest   zset found <span class="string">'page_rank'</span> has 3 members</div><div class="line"></div><div class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</div><div class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</div><div class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</div><div class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</div><div class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</div></pre></td></tr></table></figure><p>如果你担心这个指令会大幅抬升 Redis 的 ops 导致线上报警，还可以增加一个休眠参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli  --bigkeys -i 0.1</div><div class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></div><div class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></div><div class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></div><div class="line"></div><div class="line">[00.00%] Biggest string found so far <span class="string">'key316'</span> with 3 bytes</div><div class="line">[00.00%] Biggest string found so far <span class="string">'key7806'</span> with 4 bytes</div><div class="line">[12.79%] Biggest zset   found so far <span class="string">'salary'</span> with 1 members</div><div class="line">[13.19%] Biggest string found so far <span class="string">'counter:__rand_int__'</span> with 6 bytes</div><div class="line">[13.50%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'websit'</span> with 2 fields</div><div class="line">[14.37%] Biggest <span class="built_in">set</span>    found so far <span class="string">'bbs'</span> with 3 members</div><div class="line">[14.67%] Biggest <span class="built_in">hash</span>   found so far <span class="string">'website'</span> with 3 fields</div><div class="line">[30.41%] Biggest list   found so far <span class="string">'mylist'</span> with 100000 items</div><div class="line">[95.53%] Biggest zset   found so far <span class="string">'page_rank'</span> with 3 members</div><div class="line"></div><div class="line">-------- summary -------</div><div class="line"></div><div class="line">Sampled 10019 keys <span class="keyword">in</span> the keyspace!</div><div class="line">Total key length <span class="keyword">in</span> bytes is 68990 (avg len 6.89)</div><div class="line"></div><div class="line">Biggest string found <span class="string">'counter:__rand_int__'</span> has 6 bytes</div><div class="line">Biggest   list found <span class="string">'mylist'</span> has 100000 items</div><div class="line">Biggest    <span class="built_in">set</span> found <span class="string">'bbs'</span> has 3 members</div><div class="line">Biggest   <span class="built_in">hash</span> found <span class="string">'website'</span> has 3 fields</div><div class="line">Biggest   zset found <span class="string">'page_rank'</span> has 3 members</div><div class="line"></div><div class="line">10011 strings with 38919 bytes (99.92% of keys, avg size 3.89)</div><div class="line">3 lists with 100003 items (00.03% of keys, avg size 33334.33)</div><div class="line">1 sets with 3 members (00.01% of keys, avg size 3.00)</div><div class="line">2 hashs with 5 fields (00.02% of keys, avg size 2.50)</div><div class="line">2 zsets with 4 members (00.02% of keys, avg size 2.00)</div></pre></td></tr></table></figure><p>上面这个指令每隔 100 条 scan 指令就会休眠 0.1s，ops 就不会剧烈抬升，但是扫描的时间会变长。</p><p>需要注意的是，这个bigkeys得到的最大，不一定是最大。</p><p>说明原因前，首先说明bigkeys的原理，非常简单，通过scan命令遍历，各种不同数据结构的key，分别通过不同的命令得到最大的key：</p><ul><li>如果是string结构，通过strlen判断；</li><li>如果是list结构，通过llen判断；</li><li>如果是hash结构，通过hlen判断；</li><li>如果是set结构，通过scard判断；</li><li>如果是sorted set结构，通过zcard判断。</li></ul><blockquote><p>正因为这样的判断方式，虽然string结构肯定可以正确的筛选出最占用缓存，也可以说最大的key。</p><p>但是list不一定，例如，现在有两个list类型的key，分别是：numberlist–[0,1,2]，stringlist–[“123456789123456789”]，</p><p>由于通过llen判断，所以numberlist要大于stringlist。</p><p>而事实上stringlist更占用内存。其他三种数据结构hash，set，sorted set都会存在这个问题。</p><p>使用bigkeys一定要注意这一点。</p></blockquote><h3 id="slowlog命令"><a href="#slowlog命令" class="headerlink" title="slowlog命令"></a>slowlog命令</h3><p>上面提到不能使用keys命令，如果就有开发这么做了呢，我们如何得知？</p><p>与其他任意存储系统例如mysql，mongodb可以查看慢日志一样，redis也可以，即通过命令slowlog。</p><p>用法如下</p><p><strong>SLOWLOG subcommand [argument]</strong></p><p>subcommand主要有：</p><ul><li>get，用法：slowlog get [argument]，获取argument参数指定数量的慢日志。</li><li>len，用法：slowlog len，总慢日志数量。</li><li>reset，用法：slowlog reset，清空慢日志。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$redis</span>-cli slowlog get 5</div><div class="line">1) 1) (<span class="built_in">integer</span>) 2</div><div class="line">   2) (<span class="built_in">integer</span>) 1537786953</div><div class="line">   3) (<span class="built_in">integer</span>) 17980</div><div class="line">   4) 1) <span class="string">"scan"</span></div><div class="line">      2) <span class="string">"0"</span></div><div class="line">      3) <span class="string">"match"</span></div><div class="line">      4) <span class="string">"key99*"</span></div><div class="line">      5) <span class="string">"count"</span></div><div class="line">      6) <span class="string">"1000"</span></div><div class="line">   5) <span class="string">"127.0.0.1:50129"</span></div><div class="line">   6) <span class="string">""</span></div><div class="line">2) 1) (<span class="built_in">integer</span>) 1</div><div class="line">   2) (<span class="built_in">integer</span>) 1537785886</div><div class="line">   3) (<span class="built_in">integer</span>) 39537</div><div class="line">   4) 1) <span class="string">"keys"</span></div><div class="line">      2) <span class="string">"*"</span></div><div class="line">   5) <span class="string">"127.0.0.1:49701"</span></div><div class="line">   6) <span class="string">""</span></div><div class="line">3) 1) (<span class="built_in">integer</span>) 0</div><div class="line">   2) (<span class="built_in">integer</span>) 1537681701</div><div class="line">   3) (<span class="built_in">integer</span>) 18276</div><div class="line">   4) 1) <span class="string">"ZADD"</span></div><div class="line">      2) <span class="string">"page_rank"</span></div><div class="line">      3) <span class="string">"10"</span></div><div class="line">      4) <span class="string">"google.com"</span></div><div class="line">   5) <span class="string">"127.0.0.1:52334"</span></div><div class="line">   6) <span class="string">""</span></div></pre></td></tr></table></figure><p>命令耗时超过多少才会保存到slowlog中，可以通过命令config set slowlog-log-slower-than 2000配置并且不需要重启redis。</p><p>注意：单位是微妙，2000微妙即2毫秒。</p><h3 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h3><p>为了防止把问题带到生产环境，我们可以通过配置文件重命名一些危险命令，</p><p>例如keys等一些高危命令。操作非常简单，</p><p>只需要在conf配置文件增加如下所示配置即可：</p><blockquote><p>rename-command flushdb flushddbb</p><p>rename-command flushall flushallall</p><p>rename-command keys keysys</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/carbon.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十八篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;了解下redis的更多用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://zhangslob.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>25岁</title>
    <link href="https://zhangslob.github.io/2019/09/16/25%E5%B2%81/"/>
    <id>https://zhangslob.github.io/2019/09/16/25岁/</id>
    <published>2019-09-16T02:02:50.041Z</published>
    <updated>2019-09-16T02:35:48.225Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangslob/oss/master/B1sbbM.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十七篇原创文章</div></pre></td></tr></table></figure><p>25岁总结 (๑• . •๑)</p><a id="more"></a><p>Time Flies.</p><p>如果说我能活到100岁，那么现在我已经度过人生的四分之一；如果我只能活到75岁，那么我已经度过了人生的三分之一。</p><p>发现自己并写不下去这种文章，以后还是回归到技术吧。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>来到拼多多我觉得过的还是挺好的，虽然下班晚了，但是上班也晚，现在已经可以找到平衡点了。身体应该问题不大， 没有什么问题，就是自己确实是没有去锻炼，这可能会成为一个隐患。还是需要引起注意的。😔</p><p>至于工作内容方面，学习是每天工作中都会遇到的。基本上都是再用JAVA，这是个机会，以后回到武汉也可以找到JAVA相关的工作。</p><p>JAVA在某些方面用起来真的比Python要爽，但如果是写一些快速的脚本，Python当然是最佳选择。<br>很庆幸自己可以通过爬虫转型到JAVA。</p><p>在现在这个大环境下，拼多多至少不会裁员，而且每年都有涨薪，还是值得期待的，我觉得应该会在拼多多呆个三到五年。如果我还留在造数，现在的结果肯定不会是这样吧。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>每周六休息一天。如果是双休，我肯定是在打游戏，倒还不如来加班，趁着年轻多赚点钱，她还有一屁股债呢。</p><p>我是一个不愿意出门的人，无论什么放假，都不想出门去看人，自己待在家里很舒服。</p><p>至于结婚这个事情，我觉得应该是2021年吧，给自己两年时间。太早结婚并不是一个明智选择，我觉得还不够了解她，也发现了很多缺点，我要学会去包容。<del>感觉我们很难走到最后</del>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangslob/oss/master/B1sbbM.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十七篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;25岁总结 (๑• . •๑)&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://zhangslob.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>来拼多多的第一个月</title>
    <link href="https://zhangslob.github.io/2019/07/27/%E6%9D%A5%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88/"/>
    <id>https://zhangslob.github.io/2019/07/27/来拼多多的第一个月/</id>
    <published>2019-07-27T13:01:21.858Z</published>
    <updated>2019-07-27T13:58:06.868Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.pinduoduo.com/home/static/img/common/pdd_logo.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十六篇原创文章</div></pre></td></tr></table></figure><p>七月总结 (๑• . •๑)</p><a id="more"></a><p>2019年下半年，也就是7月1日，我入职了拼多多。算起来到现在已经4周了，想记录下现在到这边来的感受。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先说下在这边的工作，爬虫只是一方面，数据下游还有很长的应用链，用同事的话说，爬虫是大动脉，挂了就完了。就目前我做的一个月来说，有开发爬虫，提供数据，也有改进一些业务代码。语言的话，大环境是JAVA，爬虫有一部分是Python，我有部分业务也需要使用JAVA，然后就开始 <strong>JAVA7天从入门到精通</strong>，照着别人的代码一步步写。如何声明一个数组、Map，如何添加变量，函数返回的是什么，JSON解析的类型是什么，这种基础问题，全是一步步Google下来的，就这样下来，也算是完成了其中一个小模块，这周上线了，很有成就感😯。</p><p>工作内容确实会比较多，每天都会有做不完的事情，只要自己在其中能感受到成就感，能发挥自己的价值，每天能学到新东西，感觉就还好。只是刚来会有些不适应，慢慢就好了。</p><h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><p>就团队来说的话，我算是其中履历最差的，这里有阿里、腾讯、百度等等大厂来的，应届生也是985的，还有位5年经验的爬虫大佬带我。很多问题都可以问他们找到答案，是一个可以快速成长的地方。</p><p>拼多多现在好像有五千多号员工了，我入职那天来了几百号新员工。大佬们没有独立的办公室，所以经常会见到大佬，曾经每天上厕所都要路过一位创始人的工位。</p><h1 id="工作时间"><a href="#工作时间" class="headerlink" title="工作时间"></a>工作时间</h1><p>这个在来之前就问能不能接受“11116”，也就是早上11点到晚上11点，一周上六天班，来之前觉得挺吓人的，但是现在觉得还是OK的。</p><p>自己本来就是一个夜猫子，我的一天作息基本是这样：</p><ul><li>凌晨1点之前睡觉，早上9点起床，保证每天8个小时以上</li><li>10点到公司吃个早餐，学一个小时，现在是在看JAVA，11点正式开始工作</li><li>12点吃午饭，吃完会睡半小时，1点半开始工作</li><li>6点吃晚餐，吃完了会下去走走，7点半上来工作</li><li>晚上11点下班（有些团队是10点下班）</li></ul><p>毕竟晚上11点才能下班，所以现在也没时间写博客了，也就每周六放假了可以写点。以后爬虫的可能会少一点，会写一写JAVA基础。最近也有朋友在问怎么学爬虫，我的建议是，如果爬虫只是你的副业，掌握多线程就可以了，如果你要转行学爬虫的话，并不建议，学JAVA前景会很好，Python岗位太少。国内的话，还是JAVA第一。</p><h1 id="关于拼多多"><a href="#关于拼多多" class="headerlink" title="关于拼多多"></a>关于拼多多</h1><p>在我来之前，我也像你们一样，内心是非常抵触拼多多的，全是假货，坚决不会在上面买的。面了拼多多之后，下载了拼多多App，领了一张5元券，买了一个小风扇，最后花了<strong>0.09</strong>元。挺好用的，真香。</p><p><img src="https://s2.ax1x.com/2019/07/27/eMfbTg.md.png" alt=""></p><p>之后会经常在上面买一些小东西，确实很便宜，有个同事在拼多多上买的2019款的MBP，没啥问题。以一个内部员工的身份告诉你，拼多多里的“百亿补贴”和“品牌馆”是没有假货的，大家买买买。</p><p>最后，我们这个团队还在招人，爬虫、JAVA、算法都要，3~5年经验，这边社招的话会问很多底层的东西，不止要求你会用，还会要求你知道其中的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.pinduoduo.com/home/static/img/common/pdd_logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十六篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;七月总结 (๑• . •๑)&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://zhangslob.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>比你优秀的人不可怕，可怕的是比你优秀的人比你更努力</title>
    <link href="https://zhangslob.github.io/2019/07/13/%E6%AF%94%E4%BD%A0%E4%BC%98%E7%A7%80%E7%9A%84%E4%BA%BA%E4%B8%8D%E5%8F%AF%E6%80%95%EF%BC%8C%E5%8F%AF%E6%80%95%E7%9A%84%E6%98%AF%E6%AF%94%E4%BD%A0%E4%BC%98%E7%A7%80%E7%9A%84%E4%BA%BA%E6%AF%94%E4%BD%A0%E6%9B%B4%E5%8A%AA%E5%8A%9B/"/>
    <id>https://zhangslob.github.io/2019/07/13/比你优秀的人不可怕，可怕的是比你优秀的人比你更努力/</id>
    <published>2019-07-13T07:32:06.000Z</published>
    <updated>2019-07-13T08:19:56.174Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第九十五篇原创文章</code></pre><p>比你优秀的人不可怕，可怕的是比你优秀的人比你更努力  (๑• . •๑)</p><p><img src="https://i.vgy.me/wNYF7k.jpg" alt=""></p><a id="more"></a><p>来到拼多多有半个月了，自己总结下来，有一句话就是标题说的：<strong>比你优秀的人不可怕，可怕的是比你优秀的人比你更努力</strong>。</p><p>这句话是我的领导经常挂在嘴边的，他是一个很厉害的人，之前做C++的，来到这边开始各种学习，JAVA、Python、Node，这些都是他自学的，因为他基础好。他常常跟我说，你不是计算机专业出生，你要好好补下linux基础，然后推荐我去看《unix环境编程》。说你看完这本书之后，你和别人交谈就会有料。</p><p>这边一般是11116，我一般会10点40多过来打卡，晚上11点20下班，回到家基本就不会再学习了。他说他每天睡6个小时，晚上回去看慕课网、早上起来也看，每次我下班了他都还没下班。他跟我说他周六还会到公司这边来学习，看视频教程，学SpringBoot，给我看他周六的打卡记录。当时我是震惊的，因为大家都会觉得在拼多多加班多，工作很累，好不容易放假了，要好好休息。</p><p>就我自己来说，这边工作确实是很有挑战的。基础差是一方面，还有就是要学习新语言，这边基本上都是JAVA，之前我一直用Python。刚开始真的很难受，各种类型和跳转已经把我逼疯了，两周下来，我也能开始写一些SpringBoot。现在我把每天起床时间提前一小时，可以先来到公司学一些基础。</p><p>JAVA每次声明变量就需要给定类型，这一点刚开始很难适应，特别是处理JSON感觉很蛋疼，Python的话就根本什么都不用管，拿来就上。这一点上确实是Python简单，但是一些服务上肯定还是会选择JAVA，语言性质决定的。</p><p>还有一点感受，爬虫真的只是很小很小一部分，要更多地接触到爬虫的上下游，要把原始数据变为价值数据是一个很难的过程，这就是全新的挑战。</p><p>最后，打一个小广告，拼多多现在发展的很快，疯狂招人。这边工作时间是11116，新员工第一年是可以住宿舍的，包三餐，吃的还行（拼多多工资给的确实高），可以去Boss直聘上看拼多多的招聘岗位，有意向的可以发简历给我，然后校招的在这里<a href="https://www.nowcoder.com/careers/pinduoduo8/5338?type=neitui&amp;source=F22E6A257CF1AB262E7BB23BDA375E5BF652BAFC3A50AE436ED57099BF577FB8" target="_blank" rel="external">拼多多校招内推</a></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第九十五篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比你优秀的人不可怕，可怕的是比你优秀的人比你更努力  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.vgy.me/wNYF7k.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://zhangslob.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="学习" scheme="https://zhangslob.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="思考" scheme="https://zhangslob.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>【面试高频问题】线程、进程、协程</title>
    <link href="https://zhangslob.github.io/2019/06/22/%E3%80%90%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%E3%80%91%E7%BA%BF%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>https://zhangslob.github.io/2019/06/22/【面试高频问题】线程、进程、协程/</id>
    <published>2019-06-22T02:30:17.000Z</published>
    <updated>2019-06-22T02:36:29.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/06/22/Zpw5vQ.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十四篇原创文章</div></pre></td></tr></table></figure><p>一些面试题 (๑• . •๑)</p><a id="more"></a><p>需要先对 IO 的概念有一定的认识: IO在计算机中指Input/Output，也就是输入和输出。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><strong>并发与并行</strong></h2><p> 并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</p><p> 当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。</p><p> 并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</p><p> 区别</p><ol><li>并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。</li><li>在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。</li></ol><p>知乎上高赞例子：</p><ul><li>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</li><li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</li><li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</li></ul><p>并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是<strong>『同时』</strong>。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h2><p> 一个进程好比是一个程序，它是 资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p> 电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><p> 如果说进程和进程之间相当于程序与程序之间的关系，那么线程与线程之间就相当于程序内的任务和任务之间的关系。所以线程是依赖于进程的，也称为 「微进程」 。它是 程序执行过程中的最小单元 。</p><p> 一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是：</p><p> 拖动进度条-&gt;画面更新-&gt;声音更新。你会明显感到画面和声音和进度条不同步。</p><p> 但是加上了线程之后，线程能够共享进程的大部分资源，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a><strong>进程与线程的区别</strong></h2><ol><li>进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。</li><li>进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。</li><li>线程的调度与切换比进程快很多。</li></ol><p><strong>CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程</strong></p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a><strong>阻塞与非阻塞</strong></h2><p> 阻塞是指调用线程或者进程被操作系统挂起。 非阻塞是指调用线程或者进程不会被操作系统挂起。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a><strong>同步与异步</strong></h2><p> 同步是阻塞模式，异步是非阻塞模式。</p><ul><li>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去；</li><li>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。</li></ul><p>由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。看下图  </p><p><img src="https://s2.ax1x.com/2019/06/22/Zpw5vQ.jpg" alt="img"></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h2><p> 协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</p><p> 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此： 协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p> 协程的好处：</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销</li><li>方便切换控制流，简化编程模型</li></ol><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p><p> 缺点：  </p><ol><li>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</li><li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><ol><li>线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。</li><li>对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。</li><li>所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</li></ol><p>顺便一提，非常流行的一个爬虫框架Scrapy就是用到异步框架Twisted来进行任务的调度，这也是Scrapy框架高性能的原因之一。</p><p> 最后推荐阅读：<a href="https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&amp;mid=2247483720&amp;idx=1&amp;sn=f016c06ddd17765fd50b705fed64429c&amp;scene=21#wechat_redirect" target="_blank" rel="external">深入理解 Python 异步编程(上)</a></p><p> <a href="https://mp.weixin.qq.com/s?__biz=MzIwNjUxMTQyMA==&amp;mid=2247484702&amp;idx=1&amp;sn=8ad66afa9cef1ddf45dac9f6671ea58c&amp;chksm=9721c94da056405b132894439def3aeeb3c93e3b674c63e3a8be832b07b6fad0af846b1bc3ca&amp;token=352549795&amp;lang=zh_CN##" target="_blank" rel="external">阅读原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/06/22/Zpw5vQ.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十四篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一些面试题 (๑• . •๑)&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://zhangslob.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://zhangslob.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker通过EFK（Elasticsearch + Fluentd + Kibana）查询日志</title>
    <link href="https://zhangslob.github.io/2019/04/20/Docker%E9%80%9A%E8%BF%87EFK%EF%BC%88Elasticsearch-Fluentd-Kibana%EF%BC%89%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    <id>https://zhangslob.github.io/2019/04/20/Docker通过EFK（Elasticsearch-Fluentd-Kibana）查询日志/</id>
    <published>2019-04-20T12:47:51.000Z</published>
    <updated>2019-04-20T12:52:36.928Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第九十三篇原创文章</code></pre><p>部署相关  (๑• . •๑)</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g28xq6oyz5j31c00u0qly.jpg" alt=""></p><a id="more"></a><h1 id="Docker通过EFK（Elasticsearch-Fluentd-Kibana）查询日志"><a href="#Docker通过EFK（Elasticsearch-Fluentd-Kibana）查询日志" class="headerlink" title="Docker通过EFK（Elasticsearch + Fluentd + Kibana）查询日志"></a>Docker通过EFK（Elasticsearch + Fluentd + Kibana）查询日志</h1><p>这篇文章主要是参考<a href="https://docs.fluentd.org/v0.12/articles/docker-logging-efk-compose" target="_blank" rel="external">Docker Logging via EFK (Elasticsearch + Fluentd + Kibana) Stack with Docker Compose</a>，并在其基础上做了一些修改。</p><p>Elasticsearch是一个开源搜索引擎，以易用性着称。kibana是一个图形界面，可以在上面条件检索存储在<em>ElasticSearch</em>里数据，相当于提供了<em>ES</em>的可视化操作管理器。截图如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g25rfedkj4j31c00u07pg.jpg" alt=""></p><p>这里基本的架构是这样的</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g28vhz1565j30ka07rq3m.jpg" alt=""></p><p>这里主要解决的问题是日志查询，日志来源是docker。我们使用docker部署任务时，可以使用<code>docker logs -f &lt;容器id&gt;</code>查看日志，也可以去<code>/var/lib/docker/containers/&lt;容器id&gt;/&lt;容器id&gt;-json.log</code>查看日志文件。但是这都很难去做查询，本文介绍的EFK就可以解决这个问题。</p><p>我们会创建四个容器：</p><ul><li><a href="https://hub.docker.com/_/httpd/" target="_blank" rel="external">httpd</a> (发送日志给EFK)</li><li><a href="https://hub.docker.com/r/fluent/fluentd/" target="_blank" rel="external">Fluentd</a></li><li><a href="https://hub.docker.com/_/elasticsearch/" target="_blank" rel="external">Elasticsearch</a></li><li><a href="https://hub.docker.com/_/kibana/" target="_blank" rel="external">Kibana</a></li></ul><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>请安装最新的docker及docker-compose，老版本会有些问题。</p><p>这里是我的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker version</div><div class="line">Client: Docker Engine - Community</div><div class="line"> Version:           18.09.2</div><div class="line"> API version:       1.39</div><div class="line"> Go version:        go1.10.8</div><div class="line"> Git commit:        6247962</div><div class="line"> Built:             Sun Feb 10 04:12:39 2019</div><div class="line"> OS/Arch:           darwin/amd64</div><div class="line"> Experimental:      <span class="literal">false</span></div><div class="line"></div><div class="line">Server: Docker Engine - Community</div><div class="line"> Engine:</div><div class="line">  Version:          18.09.2</div><div class="line">  API version:      1.39 (minimum version 1.12)</div><div class="line">  Go version:       go1.10.6</div><div class="line">  Git commit:       6247962</div><div class="line">  Built:            Sun Feb 10 04:13:06 2019</div><div class="line">  OS/Arch:          linux/amd64</div><div class="line">  Experimental:     <span class="literal">false</span></div><div class="line">➜  ~ docker-compose version</div><div class="line">docker-compose version 1.23.2, build 1110ad01</div><div class="line">docker-py version: 3.6.0</div><div class="line">CPython version: 3.6.6</div><div class="line">OpenSSL version: OpenSSL 1.1.0h  27 Mar 2018</div></pre></td></tr></table></figure><h1 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h1><p>Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="attr">version:</span> <span class="string">'2'</span></div><div class="line"><span class="attr">services:</span></div><div class="line"><span class="attr">  web:</span></div><div class="line"><span class="attr">    image:</span> httpd</div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"1080:80"</span> <span class="comment">#避免和默认的80端口冲突</span></div><div class="line"><span class="attr">    links:</span></div><div class="line"><span class="bullet">      -</span> fluentd</div><div class="line"><span class="attr">    logging:</span></div><div class="line"><span class="attr">      driver:</span> <span class="string">"fluentd"</span></div><div class="line"><span class="attr">      options:</span></div><div class="line"><span class="attr">        fluentd-address:</span> localhost:<span class="number">24224</span></div><div class="line"><span class="attr">        tag:</span> httpd.access</div><div class="line"></div><div class="line"><span class="attr">  fluentd:</span></div><div class="line"><span class="attr">    build:</span> ./fluentd</div><div class="line"><span class="attr">    volumes:</span></div><div class="line"><span class="bullet">      -</span> ./fluentd/conf:/fluentd/etc</div><div class="line"><span class="attr">    links:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"elasticsearch"</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"24224:24224"</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"24224:24224/udp"</span></div><div class="line"></div><div class="line"><span class="attr">  elasticsearch:</span></div><div class="line"><span class="attr">    image:</span> elasticsearch:<span class="number">5.3</span><span class="number">.0</span></div><div class="line"><span class="attr">    expose:</span></div><div class="line"><span class="bullet">      -</span> <span class="number">9200</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"9200:9200"</span></div><div class="line"></div><div class="line"><span class="attr">  kibana:</span></div><div class="line"><span class="attr">    image:</span> kibana:<span class="number">5.3</span><span class="number">.0</span></div><div class="line"><span class="attr">    links:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"elasticsearch"</span></div><div class="line"><span class="attr">    ports:</span></div><div class="line"><span class="bullet">      -</span> <span class="string">"5601:5601"</span></div></pre></td></tr></table></figure><p>所有<code>web</code>里的日志会自动发送到<code>fluentd-address: localhost:24224</code>，也就是<code>fluentd</code>容器。</p><p>Elasticsearch 和 Kibana并不支持最新的版本，这里选择的是5.3.0，如果想要选择更新的，可以去这里查看</p><ul><li><a href="https://hub.docker.com/_/elasticsearch?tab=tags" target="_blank" rel="external">Elasticsearch image tags in DockerHub</a></li><li><a href="https://hub.docker.com/_/kibana?tab=tags" target="_blank" rel="external">Kibana image tags in DockerHub</a></li></ul><h1 id="Fluentd的配置和插件"><a href="#Fluentd的配置和插件" class="headerlink" title="Fluentd的配置和插件"></a>Fluentd的配置和插件</h1><p>新建文件<code>fluentd/Dockerfile</code>，使用官方镜像Fluentd’s <a href="https://hub.docker.com/r/fluent/fluentd/" target="_blank" rel="external">official Docker image</a>，安装需要的插件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># fluentd/Dockerfile</span></div><div class="line"><span class="keyword">FROM</span> fluent/fluentd:v0.<span class="number">12</span>-debian</div><div class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"gem"</span>, <span class="string">"install"</span>, <span class="string">"fluent-plugin-elasticsearch"</span>, <span class="string">"--no-rdoc"</span>, <span class="string">"--no-ri"</span>, <span class="string">"--version"</span>, <span class="string">"1.9.7"</span>]</span></div></pre></td></tr></table></figure><p>然后新建文件<code>fluentd/conf/fluent.conf</code>，编写Fluentd的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># fluentd/conf/fluent.conf</div><div class="line">&lt;source&gt;</div><div class="line">  @type forward</div><div class="line">  port 24224</div><div class="line">  bind 0.0.0.0</div><div class="line">&lt;/source&gt;</div><div class="line">&lt;match *.**&gt;</div><div class="line">  @type copy</div><div class="line">  &lt;store&gt;</div><div class="line">    @type elasticsearch</div><div class="line">    host elasticsearch</div><div class="line">    port 9200</div><div class="line">    logstash_format true</div><div class="line">    logstash_prefix fluentd</div><div class="line">    logstash_dateformat %Y%m%d</div><div class="line">    include_tag_key true</div><div class="line">    type_name access_log</div><div class="line">    tag_key @log_name</div><div class="line">    flush_interval 1s</div><div class="line">  &lt;/store&gt;</div><div class="line">  &lt;store&gt;</div><div class="line">    @type stdout</div><div class="line">  &lt;/store&gt;</div><div class="line">&lt;/match&gt;</div></pre></td></tr></table></figure><p>官方设置文档<a href="https://docs.fluentd.org/v0.12/articles/config-file" target="_blank" rel="external">config-file</a></p><h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><p>在后台启动，使用<code>docker-compose up -d</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ docker-compose up <span class="_">-d</span></div><div class="line">Recreating temp_elasticsearch_1 ... <span class="keyword">done</span></div><div class="line">Recreating temp_kibana_1        ... <span class="keyword">done</span></div><div class="line">Recreating temp_fluentd_1       ... <span class="keyword">done</span></div><div class="line">Recreating temp_web_1           ... <span class="keyword">done</span></div></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ docker ps</div><div class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS              PORTS                                                          NAMES</div><div class="line">03d589afc2fd        httpd                 <span class="string">"httpd-foreground"</span>       About a minute ago   Up About a minute   0.0.0.0:1080-&gt;80/tcp                                           temp_web_1</div><div class="line">e84d0753ee58        kibana:5.3.0          <span class="string">"/docker-entrypoint.…"</span>   About a minute ago   Up About a minute   0.0.0.0:5601-&gt;5601/tcp                                         temp_kibana_1</div><div class="line">0f069b8b138f        temp_fluentd          <span class="string">"tini -- /bin/entryp…"</span>   About a minute ago   Up About a minute   5140/tcp, 0.0.0.0:24224-&gt;24224/tcp, 0.0.0.0:24224-&gt;24224/udp   temp_fluentd_1</div><div class="line">fb4c6255e7ed        elasticsearch:5.3.0   <span class="string">"/docker-entrypoint.…"</span>   2 minutes ago        Up About a minute   0.0.0.0:9200-&gt;9200/tcp, 9300/tcp                               temp_elasticsearch_1</div></pre></td></tr></table></figure><h1 id="产生日志"><a href="#产生日志" class="headerlink" title="产生日志"></a>产生日志</h1><p>原文是<code>repeat 10 curl http://localhost:80/</code>，但是我在docker-compose.yml中修改了端口，所以我这里是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  repeat 10 curl http://localhost:1080/</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div><div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</div></pre></td></tr></table></figure><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>打开<code>http://localhost:5601</code>，提示需要先建索引，输入<code>fluentd-*</code>刷新即可</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g28w82fugwj31c00u07gi.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g28w95rg94j31ij0u0dma.jpg" alt=""></p><p>去<code>Discover</code>页面，然后就可以看到之前的日志了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g28w9pb14cj31c00u0nk7.jpg" alt=""></p><h1 id="如何接入其他docker日志"><a href="#如何接入其他docker日志" class="headerlink" title="如何接入其他docker日志"></a>如何接入其他docker日志</h1><p>这里是以docker-compose形式启动的一个服务，如果还有别的任务需要将日志发送到<code>fluentd</code>，需要这几个步骤。</p><p>默认情况下，docker-compose会为我们的应用创建一个网络，服务的每个容器都会加入该网络中。这样，容器就可被该网络中的其他容器访问，不仅如此，该容器还能以服务名称作为hostname被其他容器访问。</p><p>所以我们首先需要找到我们现在创建的EFK的网络名，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  docker network ls</div><div class="line">NETWORK ID          NAME                         DRIVER              SCOPE</div><div class="line">fd428cfa7264        bridge                       bridge              <span class="built_in">local</span></div><div class="line">e08505f7bfe6        docker-compose-efk_default   bridge              <span class="built_in">local</span></div><div class="line">650f2f690175        docker-efk_default           bridge              <span class="built_in">local</span></div><div class="line">35f17aeb61e9        docker-elk_elk               bridge              <span class="built_in">local</span></div><div class="line">db29d28aa5cc        esnet                        bridge              <span class="built_in">local</span></div><div class="line">56ea915974c9        host                         host                <span class="built_in">local</span></div><div class="line">4d0207065fb8        none                         null                <span class="built_in">local</span></div><div class="line">3dd60d8ddfce        temp_default                 bridge              <span class="built_in">local</span></div><div class="line">cf1a06702ae8        web_default                  bridge              <span class="built_in">local</span></div></pre></td></tr></table></figure><p>我是在temp目录下创建的docker-compose.yml文件，所以这里默认的名字就是<code>temp_default</code>。</p><p>再看看之前web的设置</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">web:</div><div class="line">  image: httpd</div><div class="line">  ports:</div><div class="line">    - <span class="string">"1080:80"</span> <span class="comment">#避免和默认的80端口冲突</span></div><div class="line">  links:</div><div class="line">    - fluentd</div><div class="line">  logging:</div><div class="line">    driver: <span class="string">"fluentd"</span></div><div class="line">    options:</div><div class="line">      fluentd-address: localhost:<span class="number">24224</span></div><div class="line">      tag: httpd.access</div></pre></td></tr></table></figure><p>有几个关键设置是：links和logging，link 用于容器直接的互通，logging则是日志的输出设置。</p><p>那我们这里再启动一个新docker需要这些设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run</div><div class="line">    --link temp_fluentd_1 \</div><div class="line">    --net temp_default  \</div><div class="line">    --log-driver=fluentd \</div><div class="line">    --log-opt fluentd-address=localhost:24224 \</div><div class="line">    --log-opt tag=httpd.access \</div><div class="line">    <span class="_">-d</span> hello-world</div></pre></td></tr></table></figure><p>我们去kibana看看，果然，日志已经发送到kibana了</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g28wo5q9s5j31c00u0wui.jpg" alt=""></p><blockquote><p>将log添加到选择字段，日志阅读起来更佳</p></blockquote><h1 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h1><p>上面说到这里选择的是<code>5.3.0</code>，我们试试新版本<code>6.7.1</code>，再看看kibana。使用<code>docker-compose stop</code>停止服务，修改docker-compose文件再启动。</p><p>但是已启动es就挂了，最</p><p>后查看日志<code>docker-compose logs | grep elasticsearch_1</code>，发现如下错误：</p><blockquote><p>“Native controller process has stopped - no new native processes can be started”</p></blockquote><p>最后在giuhub上找到答案：<a href="https://github.com/elastic/elasticsearch/issues/25067" target="_blank" rel="external">es crashes with “Native controller process has stopped - no new native processes can be started”</a></p><p>解决方法是，提高docker可用内存，mac上是这样设置，把内存从2G提高到4G，再启动就成功了。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g28xp9fmb1j30rs0pm0ux.jpg" alt=""></p><p>这里是6.7.1的界面</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g28xq6oyz5j31c00u0qly.jpg" alt=""></p><p>最后想要做的就是如何在一台服务器上搜集所有的日志，理论上来说，只需要一台服务器部署上EFK，暴露端口，其他服务器去发送即可，实际上还没试过。</p><p>如果有好的意见，欢迎来提。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第九十三篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;部署相关  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1g28xq6oyz5j31c00u0qly.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://zhangslob.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zhangslob.github.io/tags/Docker/"/>
    
      <category term="EFK" scheme="https://zhangslob.github.io/tags/EFK/"/>
    
  </entry>
  
  <entry>
    <title>对第一份工作的总结</title>
    <link href="https://zhangslob.github.io/2019/04/07/%E5%AF%B9%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangslob.github.io/2019/04/07/对第一份工作的总结/</id>
    <published>2019-04-07T05:07:30.000Z</published>
    <updated>2019-04-07T06:53:01.552Z</updated>
    
    <content type="html"><![CDATA[<pre><code>这是崔斯特的第九十二篇原创文章</code></pre><p>两年工作的总结  (๑• . •๑)</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1tzxvbdycj30is0h2wf9.jpg" alt=""></p><a id="more"></a><p>有段时间没写东西了，如果你在萌新群里，应该知道我最近换工作的事。简单说，就是辞去了北京的工作，在杭州找到了新工作。</p><p>看到手里的离职证明，想着还是写点什么，记录下我毕业后的第一份工作，在这里我做了什么，学到了什么。</p><h1 id="到来"><a href="#到来" class="headerlink" title="到来"></a>到来</h1><p>17年6月分毕业户就来到了北京，我清楚的记得去北京是坐的普快，那天晚上是欧冠决赛，皇马是冠军。我去查了下，是2017年06月04，皇马赢了尤文图斯。(我是C罗球迷)</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1u080kavdj30wh0u0n44.jpg" alt=""></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>一个人来到北京，确实有很多不适应的地方。首先住的地方，朋友帮我在6号线的东夏园租了一个1000元的小房子，小区特别偏僻，吃饭的地方很少，而且北方煎饼果子和面食特别多，刚开始很不适应，后来慢慢好了点。</p><p>公司刚开始在青年路站，后来搬去了十里堡。所以出行还是很方便的，就在6号线，早上上班还有座位可以坐。造数之前的产品主要是数据采集工具，现在可以免费试用：<a href="https://zaoshu.io/index.html" target="_blank" rel="external">造数 - 新一代智能云爬虫</a>，虽然很多网站用不了。</p><p>我刚开始做的有一部分运营的工作、也有配合其他人录制了爬虫视频教程，现在回去简直没法看，感觉太傻了，你们千万别去看。如果要学爬虫的话，等我把这个写完：<a href="https://zhangslob.github.io/docs/">数据采集从入门到放弃</a></p><h1 id="转岗"><a href="#转岗" class="headerlink" title="转岗"></a>转岗</h1><p>我是在造数内部完成的转岗，成为爬虫工程师。一方面是我有爬虫方面的基础，并一方面业务需要招了需要很多数据。转岗确实不容易，需要学习很多东西，也需要一点运气，感觉最重要是就是坚持吧。</p><p>做的第一个项目是有人带，前前后后有一个多月才算完工，虽然最终的爬虫很简单，中间却踩了不少弯路，也在使用中对Scrapy越来越熟悉，也知道如何在Scrapy的基础上再次开发，也就是造轮子，这些轮子在后来此类的项目中基本是在一直使用。</p><p>再到后来基本上就是自己独立负责N个项目了，感觉每做一个项目，就遇到一些坑，然后就会新学到一些技能，成长会比较快。这也是一个很有趣的过程。</p><p>会有加班，最晚的一次是凌晨两点吧，其实我现在回想加班的原因主要是自己能力太差，如果当时水平再好点，就不至于加班这么晚。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>我觉得自己比较大的优势在于学习吧，从最开始学习编程开始，就会把自己所学记录下来，刚开始是在知乎上，后来用hexo搭建了自己的博客，后来写公众号，打算以后再用tornado来写个博客。</p><p>关于学习这个东西，所学一定要有所用，不然一定会忘记。某个东西在需要的时候再去学习，然后将所学用到实际项目中，再有人指点一二，会很快掌握新的技能。</p><p>我一般遇到问题会有如下解决方法：</p><ol><li>首先肯定是去Google，注意需要把你的中文先翻译为英文</li><li>根据搜索结果去尝试，stackoverflow实在是太好用，可以解决一半的问题</li><li>如果尝试失败，再去问可能知道这个问题的人。不建议在网上问，效率低下，直接去找公司大佬问。</li><li>在通过各种途径解决该问题后，我会记录下来，一般会发在博客中。所以你看我的博客里，大多是针对某一个具体问题的解决方案，很少有类似于”我爬了xx数据，研究出xx结论”此类文章。</li><li>以后再遇到此类问题，我会迅速想到自己写的，就会打开博客，找到那篇文章阅读。</li></ol><p>造数有很多技术大牛，在某些领域上专攻，所以在遇到问题基本上都可以去问他们，这种方法比在微信上问别人好得多。</p><h1 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h1><p>列举下自己在造数所学到的或者能使用的技能点，我也在简历中有写出来：</p><ol><li>Python3、Scala、Go、SQl</li><li>Requests、Scrapy、Scrapy-Redis、Bloom filter</li><li>IOS逆向（静态IDA、动态hook）、JS断点</li><li>Selenium、Appium、Airtest</li><li>MongoDB、MySQL、Redis、Docker</li><li>Xpath、bs4、css、jQuery、Regular Expression</li><li>Fiddler、Charles、Wireshark、Mitmproxy</li><li>Flask、Pandas、Spark、TensorFlow</li></ol><p>以上这些技能点基本上都可以在历史文章中找到身影，这些也是做爬虫所需。当然，也还有一些我不大了解的，像aiohttp、rabbitmq、celery等，没有在实际项目中使用过，不敢说自己会用。在爬虫部署、框架开发、代理池设计等方面也需要提高。</p><h1 id="离开"><a href="#离开" class="headerlink" title="离开"></a>离开</h1><p>今年开年后，我搬到沙河，而造数在朝阳，每天6点半起床，坐两小时地铁，距离原因，所以提了离职，在朋友内推下来到小黑鱼，在杭州。</p><p>总的来说，在造数真的学到了很多，作为毕业后的第一份工作，虽然是小公司，我觉得很开心的。看我的github仓库提交记录，我只想说：真实!</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1tzxvbdycj30is0h2wf9.jpg" alt=""></p><p>2019年4月4日来到杭州，那天还下着雨，所以记得很清楚。现在已经安定下来，在公司5分钟路程租到了房子。明天就会入职新公司，希望可以好好做吧。刚来到杭州没几天，我觉得杭州很不错，住着比北京舒服，环境比北京好。如果有杭州的小伙伴，欢迎面基。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;这是崔斯特的第九十二篇原创文章
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两年工作的总结  (๑• . •๑)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79ly1g1tzxvbdycj30is0h2wf9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="https://zhangslob.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="https://zhangslob.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>scrapy去重与scrapy_redis去重与布隆过滤器</title>
    <link href="https://zhangslob.github.io/2019/03/26/scrapy%E4%B8%8Escrapy-redis%E7%9A%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://zhangslob.github.io/2019/03/26/scrapy与scrapy-redis的去重/</id>
    <published>2019-03-26T07:35:53.000Z</published>
    <updated>2019-03-27T03:06:50.394Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1g8q966ibj31380sewli.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这是崔斯特的第九十一篇原创文章</div></pre></td></tr></table></figure><hr><a id="more"></a><p>在开始介绍scrapy的去重之前，先想想我们是怎么对requests对去重的。requests只是下载器，本身并没有提供去重功能。所以我们需要自己去做。很典型的做法是事先定义一个去重队列，判断抓取的url是否在其中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">crawled_urls = set()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_url</span><span class="params">(url)</span>:</span></div><div class="line">    <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> crawled_urls:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure><p>此时的集合是保存在内存中的，随着爬虫抓取内容变多，该集合会越来越大，有什么办法呢？</p><p>接着往下看，你会知道的。</p><h1 id="scrapy的去重"><a href="#scrapy的去重" class="headerlink" title="scrapy的去重"></a>scrapy的去重</h1><p>scrapy对request不做去重很简单，只需要在request对象中设置<code>dont_filter</code>为True，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span> scrapy.Request(url, callback=self.get_response, dont_filter=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p>看看源码是如何做的，<a href="https://github.com/scrapy/scrapy/blob/master/scrapy/utils/request.py#L19" target="_blank" rel="external">位置</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_fingerprint_cache = weakref.WeakKeyDictionary()</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(request, include_headers=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> include_headers:</div><div class="line">        include_headers = tuple(to_bytes(h.lower())</div><div class="line">                                 <span class="keyword">for</span> h <span class="keyword">in</span> sorted(include_headers))</div><div class="line">    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> include_headers <span class="keyword">not</span> <span class="keyword">in</span> cache:</div><div class="line">        fp = hashlib.sha1()</div><div class="line">        fp.update(to_bytes(request.method))</div><div class="line">        fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">        fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div><div class="line">        <span class="keyword">if</span> include_headers:</div><div class="line">            <span class="keyword">for</span> hdr <span class="keyword">in</span> include_headers:</div><div class="line">                <span class="keyword">if</span> hdr <span class="keyword">in</span> request.headers:</div><div class="line">                    fp.update(hdr)</div><div class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> request.headers.getlist(hdr):</div><div class="line">                        fp.update(v)</div><div class="line">        cache[include_headers] = fp.hexdigest()</div><div class="line">    <span class="keyword">return</span> cache[include_headers]</div></pre></td></tr></table></figure><p>注释过多，我就删掉了。谷歌翻译 + 人翻</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">返回请求指纹</div><div class="line"></div><div class="line">请求指纹是唯一标识请求指向的资源的哈希。 例如，请使用以下两个网址：</div><div class="line"></div><div class="line">http://www.example.com/query?id=111&amp;cat=222</div><div class="line">http://www.example.com/query?cat=222&amp;id=111</div><div class="line"></div><div class="line">即使这两个不同的URL都指向相同的资源并且是等价的（即，它们应该返回相同的响应）</div><div class="line"></div><div class="line">另一个例子是用于存储会话ID的cookie。 假设以下页面仅可供经过身份验证的用户访问：</div><div class="line"></div><div class="line">http://www.example.com/members/offers.html</div><div class="line"></div><div class="line">许多网站使用cookie来存储会话ID，这会随机添加字段到HTTP请求，因此在计算时应该被忽略指纹。</div><div class="line"></div><div class="line">因此，计算时默认会忽略request headers。 如果要包含特定headers，请使用include_headers参数，它是要计算Request headers的列表。</div></pre></td></tr></table></figure><p>其实就是说：scrapy使用sha1算法，对每一个request对象加密，生成40为十六进制数，如：’fad8cefa4d6198af8cb1dcf46add2941b4d32d78’。</p><p>我们看源码，重点是一下三行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fp = hashlib.sha1()</div><div class="line">fp.update(to_bytes(request.method))</div><div class="line">fp.update(to_bytes(canonicalize_url(request.url)))</div><div class="line">fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</div></pre></td></tr></table></figure><p>如果没有自定义headers，只计算method、url、和二进制body，我们来计算下，代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(request_fingerprint(scrapy.Request(<span class="string">'http://www.example.com/query?id=111&amp;cat=222'</span>)))</div><div class="line">print(request_fingerprint(scrapy.Request(<span class="string">'http://www.example.com/query?cat=222&amp;id=111'</span>)))</div><div class="line">print(request_fingerprint(scrapy.Request(<span class="string">'http://www.example.com/query'</span>)))</div></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fad8cefa4d6198af8cb1dcf46add2941b4d32d78</div><div class="line">fad8cefa4d6198af8cb1dcf46add2941b4d32d78</div><div class="line">b64c43a23f5e8b99e19990ce07b75c295165a923</div></pre></td></tr></table></figure><p>可以看到第一条和第二条的密码是一样的，是因为调用了<code>canonicalize_url</code>方法，该方法返回如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> w3lib.url</div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># sorting query arguments</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>w3lib.url.canonicalize_url(<span class="string">'http://www.example.com/do?c=3&amp;b=5&amp;b=2&amp;a=50'</span>)</div><div class="line"><span class="string">'http://www.example.com/do?a=50&amp;b=2&amp;b=5&amp;c=3'</span></div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># UTF-8 conversion + percent-encoding of non-ASCII characters</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>w3lib.url.canonicalize_url(<span class="string">u'http://www.example.com/r\u00e9sum\u00e9'</span>)</div><div class="line"><span class="string">'http://www.example.com/r%C3%A9sum%C3%A9'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><blockquote><p>scrapy的去重默认会保存到内存中，如果任务重启，会导致内存中所有去重队列消失</p></blockquote><h1 id="scrapy-redis的去重"><a href="#scrapy-redis的去重" class="headerlink" title="scrapy-redis的去重"></a>scrapy-redis的去重</h1><p>scrapy-redis重写了scrapy的调度器和去重队列，所以需要在settings中修改如下两列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Enables scheduling storing requests queue in redis.</span></div><div class="line">SCHEDULER = <span class="string">"scrapy_redis.scheduler.Scheduler"</span></div><div class="line"></div><div class="line"><span class="comment"># Ensure all spiders share same duplicates filter through redis.</span></div><div class="line">DUPEFILTER_CLASS = <span class="string">"scrapy_redis.dupefilter.RFPDupeFilter"</span></div></pre></td></tr></table></figure><p>一般我们会在redis中看到这两个，分别是去重队列和种子链接</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1g9pd53l0j30mf0audhk.jpg" alt=""></p><p>先看看代码：<a href="https://github.com/rmax/scrapy-redis/blob/master/src/scrapy_redis/dupefilter.py#L86" target="_blank" rel="external">重要代码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="string">"""Returns True if request was already seen.</span></div><div class="line">    Parameters</div><div class="line">    ----------</div><div class="line">    request : scrapy.http.Request</div><div class="line">    Returns</div><div class="line">    -------</div><div class="line">    bool</div><div class="line">    """</div><div class="line">    fp = self.request_fingerprint(request)</div><div class="line">    <span class="comment"># This returns the number of values added, zero if already exists.</span></div><div class="line">    added = self.server.sadd(self.key, fp)</div><div class="line">    <span class="keyword">return</span> added == <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_fingerprint</span><span class="params">(self, request)</span>:</span></div><div class="line">    <span class="string">"""Returns a fingerprint for a given request.</span></div><div class="line">    Parameters</div><div class="line">    ----------</div><div class="line">    request : scrapy.http.Request</div><div class="line">    Returns</div><div class="line">    -------</div><div class="line">    str</div><div class="line">    """</div><div class="line">    <span class="keyword">return</span> request_fingerprint(request)</div></pre></td></tr></table></figure><p>首先拿到scrapy.http.Request会先调用self.request_fingerprint去计算，也就是scrapy的sha1算法去加密，然后会向redis中添加该指纹。</p><p>该函数的作用是：计算该请求指纹，添加到redis的去重队列，如果已经存在该指纹，返回True。</p><p>我们可以看到，只要有在settings中添加<code>DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</code>，就会在redis中新加一列去重队列，说下这样做的优劣势：</p><ol><li>优点：将内存中的去重队列序列化到redis中，及时爬虫重启或者关闭，也可以再次使用，你可以使用SCHEDULER_PERSIST来调整缓存</li><li>缺点：如果你需要去重的指纹过大，redis占用空间过大。8GB=8589934592Bytes，平均一个去重指纹40Bytes，约可以存储214,748,000个(2亿)。所以在做关系网络爬虫中，序列化到redis中可能并不是很好，保存在内存中也不好，所以就产生了布隆过滤器。</li></ol><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>它的原理是将一个元素通过 k 个哈希函数，将元素映射为 k 个比特位，在 bitmap 中把它们置为 1。在验证的时候只需要验证这些比特位是否都是 1 即可，如果其中有一个为 0，那么元素一定不在集合里，如果全为 1，则很可能在集合里。（因为可能会有其它的元素也映射到相应的比特位上）</p><p>同时这也导致不能从 Bloom filter 中删除某个元素，无法确定这个元素一定在集合中。以及带来了误报的问题，当里面的数据越来越多，这个<strong>可能</strong>在集合中的靠谱程度就越来越低。（由于哈希碰撞，可能导致把不属于集合内的元素认为属于该集合）</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1ga75f8maj30hs06ewf0.jpg" alt=""></p><p>布隆过滤器的缺点是错判，就是说，<strong>不在的一定不在，在的不一定在</strong>，而且无法删除其中数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pybloomfilter</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fruit = pybloomfilter.BloomFilter(<span class="number">100000</span>, <span class="number">0.1</span>, <span class="string">'/tmp/words.bloom'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>fruit.update((<span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(fruit)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'mike'</span> <span class="keyword">in</span> fruit</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'apple'</span> <span class="keyword">in</span> fruit</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><p>python3使用<a href="https://github.com/PrashntS/pybloomfiltermmap3" target="_blank" rel="external">pybloomfilter</a>的例子。</p><p>那么如何在scrapy中使用布隆过滤器呢，崔大大已经写好了，地址：<a href="https://github.com/Python3WebSpider/ScrapyRedisBloomFilter" target="_blank" rel="external">ScrapyRedisBloomFilter</a>，已经打包好，可以直接安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy-redis-bloomfilter</div></pre></td></tr></table></figure><p>在settings中这样配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Ensure use this Scheduler</span></div><div class="line">SCHEDULER = <span class="string">"scrapy_redis_bloomfilter.scheduler.Scheduler"</span></div><div class="line"></div><div class="line"><span class="comment"># Ensure all spiders share same duplicates filter through redis</span></div><div class="line">DUPEFILTER_CLASS = <span class="string">"scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter"</span></div><div class="line"></div><div class="line"><span class="comment"># Redis URL</span></div><div class="line">REDIS_URL = <span class="string">'redis://localhost:6379/0'</span></div><div class="line"></div><div class="line"><span class="comment"># Number of Hash Functions to use, defaults to 6</span></div><div class="line">BLOOMFILTER_HASH_NUMBER = <span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment"># Redis Memory Bit of Bloomfilter Usage, 30 means 2^30 = 128MB, defaults to 30</span></div><div class="line">BLOOMFILTER_BIT = <span class="number">30</span></div><div class="line"></div><div class="line"><span class="comment"># Persist</span></div><div class="line">SCHEDULER_PERSIST = <span class="keyword">True</span></div></pre></td></tr></table></figure><p>其实也是修改了调度器与去重方法，有兴趣的可以了解下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g1g8q966ibj31380sewli.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;这是崔斯特的第九十一篇原创文章&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="scrapy" scheme="https://zhangslob.github.io/categories/scrapy/"/>
    
    
      <category term="scrapy" scheme="https://zhangslob.github.io/tags/scrapy/"/>
    
      <category term="scrapy_redis" scheme="https://zhangslob.github.io/tags/scrapy-redis/"/>
    
  </entry>
  
</feed>
